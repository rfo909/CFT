# Readme
# --
<<<<<<<<< EOF
This script is an interface to the database implementation which exists
under Lib.Db.Db2, which is a memory-based (hashmap-oriented) store which
sync's data to files.

It is collection-based, each consisting of a number key-value pairs. 

--

To store larger amounts of objects without having to invent artificial
keys, see the Db2Obj script. It requires values to be dictionary objects, 
and autogenerate a UUID value for each stored objects. 

Locating objects are based on examining the content of objects, or by
knowing the UUID.
>>>>>>>>> EOF
/Readme


# Helper
# --
	Lib:Header("Enter collection.")
	Collections->c println("   " +c) |

	Input("collection").get
//inputCollection


		
# Store data
# --
	P(1)=>collection
	P(2)=>key
	P(3)=>value

	error(collection.startsWith("."), "Invalid collection, '.' indicates system collections")
	
	x = Lambda {syn(P(1))}
	error (x.?call(value)==false, "Value " + getType(value) + " not synthesizable")
	value = syn(value)
	
	Lib.Db.Db2.set(collection,key,value)

/Set


# Get data
# --
	P(1,inputCollection)=>collection
	P(2,Input("key").get)=>key
	P(3)=>defaultValue
	
	value=Lib.Db.Db2.get(collection,key)

	if (value == null, defaultValue, eval(value))
/Get



# Get keys in collection
# --
	P(1,inputCollection)=>collection
	Lib.Db.Db2.keys(collection)
/Keys



# Get collections
# --
	Lib.Db.Db2.collections.sort->name
		reject(name.startsWith("Obj."))  # prefix for Db2Obj collections
		out(name)
/Collections



# Delete collection
# --
	P(1,inputCollection)=>collection
	Lib.Db.Db2.deleteCollection(collection)
/DeleteCollection


# Show content
# --
	P(1,inputCollection)=>collection
	Keys(collection).sort->key
		report(collection, key, Get(collection,key))
/Show


# Edit data in collection
# --
	P(1,inputCollection) => collection

	Keys(collection).sort => keys

	Lib:Header("Current values in " + collection)

	Inner{
		count=0 
		Inner {
			keys->key 
				report(count, key, syn(Get(collection,key))) 
				count=count+1
		}->line println(line)
	}
	println
	readLine("Command .a to add new, row number to edit or ENTER to quit") => command

	if (command=="") {
		println("Quitting")
	} else if (command==".a") {
		readLine("Key") => key
		readLine("Value as code, which means quotes around Strings etc") => newValCode
		actualValue=eval(newValCode)
		Set(collection,key,actualValue)
	} else {
		# Edit row by number
		key=keys.nth(command.parseInt)
		value=syn(Get(collection,key))
		println("Current value:")
		println(value)
		readLine("New value") => newValCode
		modifiedValue=eval(newValCode)
		Set(collection,key,modifiedValue)
	}

	"Done"
/Edit


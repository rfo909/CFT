# License
<<< EOF
#
# CFT - an interactive programmable shell for automation 
# Copyright (C) 2020-2024 Roar Foshaug
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>
#
>>> EOF
/License


# Readme for script
<<< EOF

--------------------------------------------------
OS independent editor functionality

To edit a file: Lib:e (File)
To page a file: Lib:m (File)

For windows runs notepad, for Linux there is
choice. 
 
--------------------------------------------------

>>> EOF
/Readme




# Edit file
# --
    P(1,Sys.savefile) => file
    P(2,true) => detach
    
    if (!detach) {
        # Need to run editor that we can wait for
        #
        if (Sys.isWindows) {
            Dir.run("cmd","/c","notepad",file.path)
        } else {
            Dir.run("nano",file.path)
        }
    } else {
        # regular processing
        
        if(Sys.isWindows) {
            npp = Dir("C:\Program Files (x86)\Notepad++")
            if (npp.exists) {
                Dir.runDetach(npp.path + "\notepad++.exe", file.path)
            } else {
                Dir.runDetach("cmd","/c","notepad",file.path)
            }
        } else {
            ShowLinuxEditor(file)
        }
    }
/e



# "more" through file
# --
    P(1,Sys.savefile) =>file
    if(Sys.isWindows)
        Dir.run("cmd", "/c", "more", file.path)
    else
        Dir.run("more", file.path)
/m



# "more" through list of lines
# --
    P(1) as List => lines
    count=0
    lines->line
        if (count >= Term.h-3) {
                        println
            readLine("Enter to continue, 'q' to abort")=>x
            break(x=="q")
            count=0
        }
        println(line)
        count=count+1
    |
/mList
        

# Get file from lastResult if possible, otherwise error
# --
    x = Sys.lastResult
    if (getType(x)=="List") {
        files=Inner{x->e assert(getType(e)=="File") out(e)}
        error(files.empty,"No files in lastResult")
        Lib:MenuSelect(files,Lambda{P(1).name},null,true) => x
    }
    error(getType(x)!="File","Not a file")
    x
/GetLastResultFile



# Linux helper
# --
    P(1,"ls")=>program
    Dir.runCapture("which", program) => lines
    if (lines.length >= 1 && lines.first.contains("/"+program)) {
        true
    } else {
        false
    }
//LinuxHasProgram


# Show graphical file manager
# --
    P(1,Dir) => dir
    if (Sys.isWindows) {
        dir.run("explorer",dir.path)
    } else {
        if (LinuxHasProgram("nautilus")) {
            dir.runDetach("nautilus",dir.path)
        } else if (LinuxHasProgram("xfe")) {  
            dir.runDetach("xfe",dir.path)
        } else {
            error("Found no file manager")
        }
    }
/fileManager



# Show image viewer
# --
    P(1) as File => imgFile
    if (Sys.isWindows) {
        Dir.run("explorer.exe", imgFile.path)
    } else {
        error("Not implemented for linux yet")
    }
/imageViewer



# Update terminal size (if possible)
# --
    false =>updated

    if (Term.isTerminal) {
        if(!Sys.isWindows) {
            # Linux
            Dir.runCapture("which","stty").nth.contains("/stty") =>hasStty
            if(hasStty, Inner{
                Dir.runCapture("stty","size").nth.split =>list

                Term.h(list.nth(0).parseInt)
                Term.w(list.nth(1).parseInt)
                true =>updated
            })
        } else {
            # Windows (a bit slow)
            # 2021-08-18 RFO: some windows environments fail running powershell
            tryCatch ({
                Dir.runCapture("powershell","(Get-Host).UI.RawUI.WindowSize.Width").nth.parseInt =>w
                Dir.runCapture("powershell","(Get-Host).UI.RawUI.WindowSize.Height").nth.parseInt =>h
            }) => result
            if (!result.ok) {
                key="GetTerminalSize Windows Fails"
                if (Util:HasTimedOut(key,3600)) {
                    Lib:ShowWarn("GetTerminalSize() fails (windows) - using 80x24")
                    Util:SetTimeMark(key)
                }
                w=80
                h=24
            }
            Term.w(w)
            Term.h(h)
            true =>updated
        }
    }
    #if(updated, Term, null)
    Term
/GetTerminalSize
            


# Select Linux editor and remember selection for next time, open file in editor
# --
  P(1,Sys.savefile) =>file
    Dict
        .set("sublime",Lambda { P(1)=>file Dir.runDetach("subl",file.path) })
        .set("gedit", Lambda { P(1)=>file Dir.runDetach("gedit",file.path) })
        .set("leafpad",Lambda { P(1)=>file Dir.runDetach("leafpad",file.path) })
        .set("nano", Lambda { P(1)=>file Dir.run("nano", file.path) })
        .set("micro",Lambda { P(1)=>file Dir.run("micro", file.path) })
    => actions

   if(Db2:Get("Lib","linuxEditor")==null) {
        MenuSelect(actions.keys, Lambda { P(1) },"Select editor") =>ed
        Db2:Set("Lib","linuxEditor", ed)
    }


    ed = Db2:Get("Lib","linuxEditor")
    
    # invoke lambda (really a closure, since part of a Dict, but that doesn't matter here)
    actions.get(ed).call(file)
    
//ShowLinuxEditor



# Clear selected Linux editor
# --
    Db2:Set("Lib","linuxEditor",null)
    "Linux editor selection cleared"
/ClearEditor



# Open command shell in given directory
# --
    P(1) as Dir => dir
    if (Sys.isWindows) {
        dir.run("powershell -c start-process powershell".split)
    } else {
        dir.run("lxterminal") 
    }
/OpenCMD
        

# Get the private dir
# --
    Sys.homeDir.sub("private") =>d
    if(!d.exists) d.create
    d
/DirPrivate



# Create name of temp file under /tmp or under c:\temp if windows
# --
    P(1,"tmp") =>name 
    P(2,"txt") => type
    Util:Counter("Std.TmpFile.id") => x
    s=name+Std.Db.UUID+"-"+x+"."+type
    if (Sys.isWindows,
        Dir("c:\temp").file(s),
        Dir("/tmp").file(s) 
    )
/TmpFile


# Create temporary directory - remember to delete it when done
# --
    P(1,"tmp") => name
    if (Sys.isWindows,
        Dir("c:\temp\"+name+currentTimeMillis),
        Dir("/tmp/"+name+currentTimeMillis)
    ) =>d
    if (!d.exists) {
        d.create
    }
    d
/TmpDir


# Copy directory tree. Both fromDir and toDir must exist.
# --
    P(1) => fromDir
    P(2) => toDir
    P(3,false) => verbose
    P(4,true) => execute  # set false to do "dry run"
    P(5, Lambda{true}) => LInclude

    error(!fromDir.exists, "Invalid fromDir: " + fromDir.path)
    error(execute && !toDir.exists, "Invalid toDir: " + toDir.path)
    error(fromDir.path==toDir.path, "fromDir == toDir")

    fromDir.files->f 
        assert(LInclude.call(f))
        if(verbose) {
            println("FROM: " + f.path) 
            println("TO  : " + toDir.path)
        }
        if (execute) toDir.copy(f) 
    |
    fromDir.dirs->d 
        toDir.sub(d.name) => d2
        if(!d2.exists && execute) d2.create
        CopyDirTree(d,d2,verbose,execute,LInclude)
    |
/CopyDirTree



# Compare files from source tree to target tree, prints report to stdout
# --
    P(1) => fromDir
    P(2) => toDir
    P(3,true) => recurse

    error(!fromDir.exists, "Invalid fromDir: " + fromDir.path)
    error(!toDir.exists, "Invalid toDir: " + toDir.path)

    fromDir.files->f
        toDir.file(f.name) => f2
        if (f2.exists) {
            if (f2.length != f.length || f2.hash != f.hash) println("DIFFERS: " + f2.path)
        } else {
            println("NOT FOUND: " + f2.path)
        }
    |
    if (recurse) {
        fromDir.dirs->d 
            toDir.sub(d.name) => d2
            if(!d2.exists) {
                println("NO DIR: " + d2.path)
            } else {
                CompareTrees(d,d2,true)
            }
    }
/CompareTrees



# Print directory tree structure
# --
    P(1,Dir)=>dir

    # recursion control parameters
    P(2,0)=>nestCount
    P(3,List)=>output

    indent="|  ".times(nestCount)
    indent2="|  ".times(nestCount+1)
    indent2="|  ".times(nestCount+1)

    output.add(indent + "+ " + dir.name)

    error(output.length > 1000,"Over 1000 lines of text generated. Aborting.")

    Inner{
        files=dir.files
        line=indent2
        lineCount=0
        files->f 
            if (line.length+1+f.name.length >= Term.w) {
                output.add(line)
                lineCount=lineCount+1
                line=indent2
            }
            line=line + " " + f.name
            break(lineCount >= 5)
        |
        if (lineCount >= 5) {
            output.add(indent2 + " ...")
        } else {
            if (line.length > indent2.length) output.add(line)
        }
        output.add(indent2)
    }
    Inner{
        dir.dirs->d 
            reject(d.name.startsWith("."))  # ignore system directories
            ShowTree(d,nestCount+1,output)
    }

    output
/ShowTree
        


# Delete directory tree, asks for interactive confirm
# Leaves root directory
# --
    P(1)=>xdir
    Sequence(
        @
        @ ------------------------------------------
        @ ------------------------------------------
        @     Deleting directory tree confirm
        @ ------------------------------------------
        @
        xdir.path
        @
        @ ------------------------------------------
        @
    )->x println(x) |
    readLine("Are you really SURE? Type 'Yes'")=="Yes" =>ok
    error(!ok,"Aborting")
    
    xdir.allFiles->f f.delete |
    xdir.allDirs->d d.delete |
/DelDirTree



# Run external program and collect stdout, stderr and exitCode - returns intermediate Dict
# representing the running process, with a member closure called "wait", which in turn
# delivers a result Dict with the following fields:
#       cmd, stdin, stdout, stderr, exitCode
#
# Run external program in background.
#
# Example of use:
#     runProcess(...)  => a
#     runProcess(...)  => b
#     a.wait => aResult
#     b.wait => bResult
# --
    P(1,List("ls","-l")) => cmd
    P(2,List) => stdinLines
    P(3,false) => acceptErrors
    P(4,false) => showDebug

    if (getType(cmd) != "List") {
        cmd=List(cmd) # wrap as list
    }
    if (getType(stdinLines) != "List") {
        stdinLines=List(stdinLines) # wrap as List
    }

    Lib:TmpFile("in") =>inFile
    Lib:TmpFile("out") =>outFile
    Lib:TmpFile("err") =>errFile
    
    inFile.create(stdinLines)

    # The Dir.runProcess call
    process = Dir.runProcess(inFile,outFile,errFile,cmd)

    Dict
        .set("cmd", cmd)
        .set("acceptErrors", acceptErrors)
        .set("showDebug", showDebug)
        .set("stdin", inFile)
        .set("stdout", outFile)
        .set("stderr", errFile)
        .set("process", process)
        .set("isCompleted", Lambda {
            self.process==null || !self.process.isAlive
        })
        .set("wait", Lambda{
            # Delay until process terminated
            loop 
                break(self.process==null || !self.process.isAlive) 
                Sys.sleep(5) 
            |
            
            # Read temp files
            result = Dict
                .set("cmd", self.cmd)
                .set("stdin", self.stdin.read)
                .set("stdout", if(self.stdout.exists, self.stdout.read, List))
                .set("stderr", if(self.stderr.exists, self.stderr.read, List))
                .set("exitCode", if(self.process==null, -1, self.process.exitCode))

            # Delete temp-files
            # --
            # Note: Windows external processes do not allow files to be deleted
            # immediately even after returning isAlive() == false.
            
            Del = Lambda {
                P(1)=>f 
                count=0
                loop
                    if(f.exists && count <= 20) {
                        count=count+1
                        if (count>15) println("File delete failed, trying again: " + f.path)
                        Sys.sleep(5)
                        f.delete
                    } else {
                        break
                    }
            }
            Del.call(self.stdin)
            Del.call(self.stdout)
            Del.call(self.stderr)
            
            # Show debug
            
            FAIL = false
            if (result.exitCode != 0 && !self.acceptErrors) {
                FAIL = true
            }

            if(self.showDebug || FAIL) {
                Inner {  # "hide" loops inside inner block, so as not to affect return value of function
                    println("- cmd:")
                    result.get("cmd")->line println("    " + line) |

                    println("- exitCode = " + result.get("exitCode"))

                    println("- stdin:")
                    result.get("stdin")->line println("   # " + line) |

                    println("- stdout:")
                    result.get("stdout")->line println("   # " + line) |

                    println("- stderr:")
                    result.get("stderr")->line println("   # " + line) |
                    println
                }
            }
            
            error(FAIL,"run failed with error")
            
            # return value
            result

        })  # Lambda "wait"
    =>obj

    if (showDebug) Inner{
        println("--- runProcess result ---")
        Util:ShowDict(obj,true)
    }
    
    obj

/runProcess


# Run external program and collect stdout, stderr and exitCode - returns Dict
# with fields cmd, stdin, stdout, stderr, exitCode
# --
    P(1,List("ls","-l")) => cmd
    P(2,List) => stdinLines
    P(3,false) => acceptErrors
    P(4,false) => showDebug

    runProcess (cmd,stdinLines,acceptErrors,showDebug) => processDict
    
    # return value
    processDict.wait

/run





run(null,null,null,true)
/testRun



# Show a list of options
# --
    P(1,List) =>options
    P(2,Lambda { "name"}) =>LLabel
        options->x
            println("- " + LLabel.call(x))
/ShowOptions



# Select zero or more from list of options
# --
    P(1,List) =>options
    P(2,Lambda { "name"}) =>LLabel
    P(3,false) =>emptyMeansNone
    P(4,LLabel) => LValue
    
        sel=readLine("Enter exact or part of value?").trim
        if(emptyMeansNone && sel=="") {
            # empty list
            result=List
        } else Inner{
            # Look for exact match first, then if no hits, partial
            options->opt
                assert(LValue.call(opt)==sel)
                out(opt)
            | =>result
            if(result.empty) Inner{
                options->opt
                    assert(LValue.call(opt).contains(sel))
                    out(opt)
                | =>result
            }
        }
        result
/SelectOptions



# Display text with line under
# --
    P(1,"Title") =>title
    println
    println(title)
    println( "-".times(title.length) )
/Header



# Display info message
# --
    P(1,"Message") => msg
    
    println("* INFO: " + msg)
/ShowInfo


# Display warning message
# --
    P(1,"Message") => msg
    
    println
    println("### WARNING ### " + msg)
    println
/ShowWarn




# Select single value from list of options. Using lambda to extract name for each element.
# --
    P(1,List)=>options 
    P(2,Lambda {P(1)}) =>LLabel   ## display value
    P(3,"Select element") =>title 
    P(4,false) => emptyMeansNone
    P(5,LLabel) =>LValue          ## separate (narrower) value for matching input?

    error(getType(options) != "List", "Options must be a list (" + title + ")")
    error(options.length==0,"No elements in options list (" + title + ")")
    
    if(options.length==1) {
        options.first
    } else Inner {
        selectedElement=null
        loop
            println
            if(title != null) Header(title)
            if (emptyMeansNone) println("(Enter blank for none)")

            ShowOptions(options, LLabel)
            println
            SelectOptions(options, LLabel, emptyMeansNone, LValue) =>result
            
            if(result.length==1) {
                selectedElement=result.first
            } else {
                selectedElement=null
            }
            #println("SelectedElement = " + selectedElement)
            break(selectedElement != null || emptyMeansNone)
            println("** No match or not unique")
        | selectedElement
    }
/MenuSelect



# Select single value from numbered list of options. Using lambda to extract name for each element.
# --
    P(1,List)=>options 
    P(2,Lambda {P(1)}) =>LLabel   ## display value
    P(3,"Enter number to select value") =>title 

    error(getType(options) != "List", "Options must be a list (" + title + ")")
    error(options.length==0,"No elements in options list (" + title + ")")
    
    if(options.length==1) {
        options.first
    } else Inner {
        println
        if(title != null) Header(title)

        Inner{i=0 options->opt println(("  " + i).last(2),"-",opt) i=i+1}
        println
        readLine("Enter position").trim.parseInt => pos

        options.get(pos)
    }
/MenuSelectNumbered





# Ask user for input
# --
    P(1,"label") =>label 
    P(2) =>currVal
    println("")
    (label + if(currVal," ["+currVal+"]","") + " : ") =>prompt
    readLine(prompt) =>line
    if(line.trim=="", currVal, line)
/ReadValue




# Ask user for input
# --
    P(1,"label") =>label 
    P(2) =>currVal
    null =>gotResult
    loop
        ReadValue(label,""+currVal) =>val
        if(val.?parseInt) {val.parseInt =>gotResult}
        break(gotResult != null)
        println("** Integer required")
    |
    gotResult
/ReadValueInt



# Ask user for input
# --
    P(1,"label") =>label 
    P(2) =>currVal 
    P(3,"yes") =>trueVal 
    P(4,"no") =>falseVal

    null =>gotResult
    loop
        if(currVal != null, if(currVal, trueVal, falseVal), null) =>currStrVal
        
        ReadValue(label+" "+trueVal + "/" + falseVal,currStrVal) =>val
        if(val==trueVal) {true =>gotResult}
        if(val==falseVal) {false =>gotResult}
        break(gotResult != null)
        println("** Please enter '" + trueVal + "' or '"  + falseVal + "'")
    |
    gotResult
/ReadValueBoolean





# Get confirmation (true or false)
# --
    P(1,"Please confirm")=>label
    P(2,"yes")=>confirmString
    P(3,"no")=>defaultValue
    
    options=confirmString + "/" + defaultValue
    readLine(label + " " + options + " ("+defaultValue+")") => inp
    if (inp.trim=="") inp=defaultValue
    
    inp.toLower == confirmString.toLower
/Confirm



# Get confirmation or abort with error
# --
    P(1,"Continue")=>label
    P(2,"yes")=>confirmString
    P(3,"no")=>defaultValue
    
    label="!!! " + label
    println
    error(!Confirm(label,confirmString,defaultValue),"Aborting")
/HardConfirm



# If value is Dict, for each key found, return corresponding value (as list). Otherwise true if value found, false if not found
# --
    P(1,List) =>lines
    P(2) =>value
    if(getType(value)=="Dict") Inner{
        # match keys and result corresponding values as list
        dict=value
        result=List
        lines->line
            dict.keys->key 
                if(line.contains(key)) {result.add(dict.get(key))}
        |
        result.unique
    } else Inner{   
        # check for single value
        lines->line assert(line.contains(value)) out(line) | _.length>0
    }
/LinesContain



# List available save files across all code directories
# --
    Sys.codeDirs.reverse->d
        Lib:Header(d.path)
        Inner {
            d.files(Glob("savefile*.txt"))->f 
                out(Str(f.name,f)) 
            | _.sort->x
                f=x.data
                println("   " + f.name.after("savefile").before(".txt"))
        }
/Scripts



# Current user (linux)
# --
    P(1,"") => pre
    P(2,"") => post
    if (!Sys.isWindows) {
        pre + Dir.runCapture("whoami").nth.trim + post
    } else {
        ""
    }
/LoggedInUser



# Search text files under current directory
# --
    P(1,Dir) => dir
    P(2,Input("Search term").get) => st
    P(3,Input("Search files: enter partial file name, or glob pattern with '*'").get) => fname
    P(4,Input("Include sub-dirs y/n").setCurrCond("y")).get.toLower=="y" => subDirs
    
    glob=if(fname.contains("*"),Glob(fname),Glob("*"+fname+"*"))

    grep=Grep(st)

    if(subDirs,dir.allFiles(glob), dir.files(glob))->file 
        grep.file(file)->line
            report(file, file.name, line.lineNumber, line)
/SearchTextFiles

   
 

# Locate files under current directory
# --
    P(1,Dir) => dir
    P(2,Input("Locate files: enter partial file name, or glob pattern with '*'").get) => fname

    if (fname=="") fname="*"
    glob=if(fname.contains("*"),Glob(fname,true),Glob("*"+fname+"*",true))
    
    dir.allFiles(glob)->f
        out(Int(f.lastModified, f))
    | _.sort->x
        out(x.data)
/LocateFiles



# Locate dirs under current dir
# --
    P(1,Dir)=>dir
    P(2,Input("Locate dirs: enter partial name, or glob pattern with '*'").get) => dname
    if (dname=="") dname="*"
    glob=if(dname.contains("*"), Glob(dname, true), Glob("*"+dname+"*",true))
    dir.allDirs(glob)->f
        out(f.path)
/LocateDirs



# Identify all file types under current dir
# --
    P(1,Dir) => dir
    Dir.allFiles->f out(f.name.afterLast("."))
    | _.unique.sort
/GetFileTypes
    
    

# Copy files and directories into "clipboard"
# --
    P(1,Dir)=>currentDir

    data=Sys.lastResult
    files=List

    if (getType(data)=="File" || getType(data)=="Dir") {
         files.add(data)
    } else if (getType(data)=="List") Inner {
        data->x
            if (getType(x)=="File" || getType(x)=="Dir") {
                files.add(x)
            }
    }
    
    if (files.empty) {
        Db2:Set("Lib","ClipboardFiles",null)
        error("Can only copy files and directories to clipboard")
    }

    Db2:Set("Lib","ClipboardFiles",files)

    "Copied " + files.length + " " + if(files.length==1,"entry","entries") + " to clipboard"
/ClipboardCopy



# Paste file from "clipboard"
# --
    P(1,Dir) => currentDir

    Sys.stdin('cp (Db2:Get("Lib","ClipboardFiles", null)) .')
/ClipboardPaste


# Delete files from "clipboard"
# --
    files=Db2:Get("Lib","ClipboardFiles",List)
    error(files.empty,"No content in clipboard")
    fCount=dCount=0
    Lib:Header("Clipboard content")
    Inner{files->f 
        if (getType(f)=="File") fCount=fCount+1 else dCount=dCount+1
        println(f.path.last(50) + if(getType(f)=="Dir", Sys.fileSeparator, ""))
    }
    println
    confirmed = Lib:Confirm("Confirm delete")
    error(!confirmed, "Aborting")

    println
    println
    
    Sys.stdin('rm (Db2:Get("Lib","ClipboardFiles", null))')
/ClipboardDelete


# Show content of clipboard
# --
    Db2:Get("Lib","ClipboardFiles",List)->f
        println(f.path.last(50) + if(getType(f)=="Dir", Sys.fileSeparator, "") + " " + if (!f.exists,"DOES-NOT-EXIST",""))
/ClipboardList


# Diff files
# --
    P(1) as File => a
    P(2) as File => b
    if (Sys.isWindows) {
        Lib:TmpFile("tmp","ps1") => script
        script.create(Sequence(
            @ $file1 = '<<a.path>>'
            @ $file2 = '<<b.path>>'
            @ Compare-Object -ReferenceObject $(Get-Content $file1) -DifferenceObject $(Get-Content $file2) -CaseSensitive
        ).mergeExpr)
        Dir.runCapture("powershell",script.path) => result
        script.delete
        result
    } else {
        Dir.run("diff",a.path,b.path)
    }
/DiffFiles



# Remove files and dirs. 
# Service function for "rm" shell command, called via mRm lambda in CFT.props
# --
    P(1) as List => filesAndDirs

    filesAndDirs->x
        if (getType(x)=="File") {
            ok = x.delete
            report(ok,"File",x.path)
        } else if (getType(x)=="Dir") {
            ok = x.delete
            if (ok) {
                report(ok,"Dir",x.path)
            } else {
                if (Lib:Confirm("Confirm deleting " + x.path + " with content") ) {
                    {x.allFiles->f ok=f.delete report(ok,"File",f.path)}
                    {x.allDirs->d ok=d.delete report(ok,"Dir",d.path)}
                    {x->d ok=d.delete report(ok,"Dir",d.path)}
                }
            }
        }
//RmFilesAndDirs


# Symbol set
# --
    P(1) as String => symbol

    Sys.lastResult => value

    if (getType(value) != "Dir" && getType(value) != "File") {
        Lib:ShowWarn("Sys.lastResult not Dir or File, type=" + getType(value))
        error(readLine("Press y to continue, otherwise abort").toLower != "y","Aborting")
    }

#    if (getType(value) == "Dir" || getType(value) == "File") {
#        Lib:Header("Protection?")
#        println("Should the " + getType(value) + " reference be protected against destructive operations?")
#        readLine("Enter non-blank string to protect it").trim => reason
#        if (reason != "") {
#            value.protect(reason)
#        }
#    }

    Db2:Get(Sys.scriptId,"symbolDict",Dict) => data
    time=currentTimeMillis
    data.set(symbol,SymDict(value,time))
    Db2:Set(Sys.scriptId,"symbolDict",data)
    
    # Show all symbols
    println
    Inner { Lib:Symbols(false)->line println(line) }
    println
    value
//SymbolSet



# Symbol get
# --
    P(1) as String => symbol
    Db2:Get(Sys.scriptId,"symbolDict",Dict) => data
    if (data.has(symbol)) {
        data.get(symbol) => entryDict
        entryDict.time=currentTimeMillis
        Db2:Set(Sys.scriptId,"symbols",data)
        entryDict.value
    } else {
        null
    }
//SymbolGet

# Show symbols (helper)
# --
    Db2:Get(Sys.scriptId,"symbolDict",Dict)=>data
    data.keys.sort->key
        data.get(key)=>entryDict
        value=entryDict.value
        s=""+value
        if (getType(value)=="File" || getType(value)=="Dir") s=value.path
        report(key,getType(value),s)
//SymbolsReport   


# Show and optionally delete symbols
# --
    P(1,true)=>edit
    loop
        Lib:Header("Defined symbols")
        Inner {
            SymbolsReport->line println(line)
        }
        break(!edit)
        println
        readLine("Enter symbol to delete, Enter for none") => line
        break(line=="")
        Db2:Get(Sys.scriptId,"symbolDict",Dict) => data
        key=line.trim
        if (data.has(key)) {
            data.remove(key)
            Db2:Set(Sys.scriptId,"symbolDict",data)
            println
        } else {
            # No match, presumably a command
            Sys.stdin(line)
            break
        }
//Symbols


# Hash a number of files
# Called by mHash in CFT.props
# --
    space=false
    P(1) as List -> f
        if (space) out("")
        out(f.path)
        out(f.hash)
        space=true
//HashFiles


# Search through a list of files
# Called by mGrep in CFT.props
# --
    P(1) => str
    P(2) => fileList
    
    grep=Grep(str)
    fileList->file
        grep.file(file)->line
            report(line.file.name, line.lineNumber, line)
//GrepFiles



# Append to history - defined in CFT.props 'historyCommand' called from Java 
# --
    P(1) as Dir => dir
    P(2) as String => command

    currDir=dir.path

    if (command.trim != "" && command.trim != "." && command!='Db2:Get("Lib","GetCommandHistory:GotoDir").cd') {
            # That last part matches the code generated in GetCommandHistory when repeating a command !!

        data=SymDict(command,currDir)
        list=Db2:Get(Sys.scriptId,"CommandHistory",List)
        list.add(data)
        Db2:Set(Sys.scriptId,"CommandHistory", list.last(60))
    }

//HistoryAppend


# Get directories history
# --
    Lib:Header("Previous directories. Use 'cd :N' to go to dir")
    Db2:Get(Sys.scriptId,"CommandHistory",List)->dict
        out(dict.currDir)
    | _.unique.last(30)
/GetDirHistory


# Get command history
# --
    data=Db2:Get(Sys.scriptId,"CommandHistory",List).last(40)

    Lib:Header("Command history")
    pos=0
    Inner {
        data->dict
            report(pos,dict.command.replace("^t".unEsc," <TAB> "), dict.currDir)
            pos=pos+1
        | ->line
            println(line)
    }
    readLine("Enter index, or Enter to continue") => s
    if (s != "") {
        if (s.?parseInt) {
            dict=data.nth(s.parseInt)

            # Note: can not just do this:
            #
            # Dir(dict.currDir).cd 
            #
            # That does not affect the caller, because each script has 
            # their own current dir

            # Solution:

            Db2:Set("Lib","GetCommandHistory:GotoDir", Dir(dict.currDir))
            Sys.stdin('Db2:Get("Lib","GetCommandHistory:GotoDir").cd')
            Sys.stdin(dict.command)
        } else {
            # Not a number, treat as a command
            Sys.stdin(s)
        }
    }
    
/GetCommandHistory


# Platform independent "which" implementation
# --
    P(1) => str
    if (Sys.isWindows) {
        Dir.run("powershell","-c","Get-Command " + str)
    } else {
        Dir.run("which", str)
    }
/Which


# Verify Encrypt sanity
# --
    pass="this is a test".getBytes("UTF-8")
    data="some data 1234.55 CAPS"
    result="62236921515F2A063CF8EE31051AEDEE53EC4B36620B"
    Std.Util.Encrypt(pass) => enc
    
    dataBytes=data.getBytes("UTF-8")
    
    Std.Data.for(0,100,1)->i
        enc.process(dataBytes)
    |
    error(enc.process(dataBytes).hex != result,
        "Std.Util.Encrypt produces INVALID RESULT")
    "ok"
//EncryptSanityCheck



# List files sorted for change date, newest last
# --
    P(1,Dir) => dir
    dir.newestFiles(100).reverse
/ListNewestFiles


# List files newer than some limit, recursively
# --
    P(1,Dir) => dir
    P(2,Input("Number of hours").setCurrCond("24").get.parseInt) => hours
    P(3,Input("Glob pattern").setCurrCond("*").get) => glob

    limit=Date.sub(Date.Duration.hours(hours)).get
    dir.allFiles(glob)->f
        reject(f.lastModified < limit)
        out(f)
/ListNewFilesRecursively
        


# Encrypt single file
# --
    P(1) as File => f
    password = Vault:SessionSecretGet("Single File Encryption password")
    binPassword=password.getBytes("UTF-8")
    encryptedFile=File(f.path + EncryptedFileEnding)
    f.encrypt(binPassword,"",encryptedFile)
/EncryptFile


# Decrypt single file
# --
    P(1) as File => f
    password = Vault:SessionSecretGet("Single File Encryption password")
    binPassword=password.getBytes("UTF-8")
    error(!f.name.endsWith(EncryptedFileEnding), "Invalid file, encrypted files end with " + EncryptedFileEnding)

    decryptedFile=File(f.path.sub(0, f.path.length - EncryptedFileEnding.length))
    f.decrypt(binPassword,"",decryptedFile)
/DecryptFile


# Ending for encrypted files
# --
    ".r"
//EncryptedFileEnding



# Random integers
# --
    P(1,1000)=>range

    number=DB2:Get(Sys.scriptId,"randomNumber",100)
    Db2:Set(Sys.scriptId,"randomNumber",number+1)
    value=(10000005 % number)/number
    value=value*range
    # return 
    value.i
/RandomInt
    


# Back date file within last 30 days
# --
    P(1) as File => f
    P(2, 30) => rangeDays
    
    range=rangeDays*86400*1000

    created=currentTimeMillis-RandomInt(range)
    diff=currentTimeMillis-created

    modified=created+RandomInt(diff/10)
    accessed=modified+RandomInt(diff/5)

    f.setTimes(created, modified, accessed)
/BackDateFile


# Back date files in LastResult
# --
    files=Sys.lastResult
    if (getType(files) != "List") files=List(files)
    files->f
        assert(getType(f)=="File")
        out(f)
        BackDateFile(f)
/BackDateLastResultFiles



BackDateLastResultFiles
/BDLRF

    

# Convert previous return value of a file, dir or list of these into
# path strings
# --
    val=Sys.lastResult
    if (!getType(val)=="List") val=List(val)
    val->x
        if (getType(x)=="File" || getType(x)=="Dir") out(x.path) 
/Paths



# Identify duplicates in list of strings or files (Sys.lastResult if no parameter given)
# --
    P(1,Sys.lastResult) => data

    dict=Dict
    data->x
        val=x
        if (getType(val)=="File") val=val.name
        dict.set(val,dict.get(val,0)+1)
    |
    # duplicates returned as simple list, no count included
    dict.keys->key
        assert(dict.get(key) > 1)
        out(key)
/Duplicates


# Search through list of files, return single list of hits only
# --
    P(1,Sys.lastResult) => list
    P(2,Input("Enter search term").get) => term
    P(3,Lambda{P(1)}) => postProcess

    grep=Grep(term)
    list->f
        grep.file(f)->line
            out(postProcess.call(line))
/Search



# Global onload-code, when starting CFT, see CFT.props
# --
    Lib:EncryptSanityCheck 
    Util:CheckForUpdates
    Lib:GetTerminalSize 
/GlobalOnLoad

# License
<<< EOF
#
# CFT - an interactive programmable shell for automation 
# Copyright (C) 2020-2025 Roar Foshaug
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>
#
>>> EOF
/License

# Readme
<<<<<< EOF
Parsing "Ansible" text format looking like this:

# This is a comment

[OS=ubuntu]
10.0.8.200

[Auto.reboot=yes]
*.v 
s*.s   [no]
	# override the "yes" value from the header



>>>>>> EOF
/Readme


# Default hosts file
# --
	Lib:DirPrivate.file("Hosts.txt")
/DefaultHostsFile


# Parse text lines. Returns object with 'data' pointing at the
# actual data structure, and a set of lambda's 
# --
    P(1, DefaultHostsFile) as File => file
    
    data = Dict
        
    currProp=null
    currPropValue=null

    LFilter = Lambda{
        P(1,List) => list
        P(2) => regex
        list->s assert(regex.match(s)) out(s)
    }
    LApply = Lambda {
        P(1) => data
        P(2) => entities
        P(3) => name
        P(4) => value

        entities->e
            #println(e + "." + name + "=" + value)
            data.get(e,Dict).set(name,value)
    }

    file.read->line
        reject(line.trim.startsWith("#"))
        reject(line.trim=="")
        if (line.trim.startsWith("[")) {
            # property definition with default value
            line.after("[").before("]").split("=")=>x
            x.nth(0)=>currProp 
            x.nth(1)=>currPropValue 
        } else {
            # data line with optional exception
            line.before("[").trim => entity
            if (entity.contains("*")) {
                regex=Glob(entity,false).regex
            
                # keys of data dict are the entities that we filter
                entities=LFilter.call(data.keys,regex)
                if (entities.empty) {
                    println("=== Warning: pattern '" + entity + "' matches nothing")
                }
            } else {
                entities=List(entity)
            }

            # is there an exception?
            redef=line.after("[").before("]").trim
            if(redef != "") {
                LApply.call(data, entities,currProp, redef)
            } else {
                LApply.call(data, entities,currProp, currPropValue)
            }
                                        
        }
    |
    
    
    
	# Class member data and functions
	# --------------------------------
    
	self.data=data
    
	self.AllHosts=Lambda{
		self.data.keys.sort
	}
    
	self.AllProperties=Lambda{
		self.data.keys->key 
			self.data.get(key).keys->field
			out (field)
		| _.unique.sort
	}
    
	self.GetProperty=Lambda{
            P(1) as String =>host
            P(2) as String =>field
            P(3) as String? =>defaultValue
            P(4, false) as boolean => optional

            result=defaultValue

            if (self.data.has(host)) {
                e=self.data.get(host)
                if (e.has(field)) {
                    x=e.get(field)
                    if (x != null) result=x
                }
            }

	    error(result==null && !optional,"No property " + field + " for host " + host + " (and no default value)")
            result
	}
    
	self.Dump=Lambda{
            self.data.keys.sort->host
                self.data.get(host).keys->field
                    value=self.data.get(host).get(field)
                    report(host,field,value)
	}
    
	self.HasProperty=Lambda{
            P(1) as String => host
            P(2) as String => field
            P(3) as String? =>value
            ok=false
            if (self.data.has(host)) {
                e=self.data.get(host)
                if (e.has(field)) {
                    if (value==null || e.get(field)==value) ok=true
                }
            }
            ok
	}
    
	# Filtering and examining data
	# -----------------------------
    
	self.hosts=self.AllHosts
    
	self.Keep = Lambda{
		P(1) as String => propertyName
		P(2) as String => value
		P(3, false) as boolean => invert
		
		self.hosts = Inner{
			self.hosts->host
				match=self.GetProperty(host,propertyName)==value
				ok=if(invert,!match,match)
				assert(ok)
				out(host)
		}
		self
	}
	   
	self.Reject = Lambda {
		P(1) as String => propertyName
		P(2) as String => value
		
		self.Keep(propertyName, value, true)
	}    
	
	self.ShowHost = Lambda{
		P(1) as String => host
		
		self.AllProperties->field
			value=self.GetProperty(host,field,null)
			assert(value != null)
			report(host,field,value)
	}		
    
    
    	self.ShowProperty = Lambda{
		P(1) as String => propertyName
		self.AllHosts->host
			if (self.HasProperty(host,propertyName)) 
				report(host,propertyName,self.GetProperty(host,propertyName))
	}
/class HostsFile


# Test
# --
	HostsFile.Keep("OS","ubuntu").hosts
/t1

# Test
# --
	HostsFile.GetProperty("10.0.8.37","OS")
/t2

# Test
# --
	HostsFile.ShowHost("10.0.8.37")
/t3

# Test
# --
	HostsFile.ShowProperty("ssh.user")
/t4


# Test
# --
	HostsFile.Keep("OS","ubuntu").Keep("ssh.askpassword","true").hosts
/t5

# Demo of selecting hosts for apt update, upgrade, dist-upgrade
# --
	P(1,Hosts2:DefaultHostsFile) as File => hostsFile
	config=Hosts2:HostsFile
	
	config.Keep("OS","ubuntu")
	config.hosts->host
		sshUser=config.GetProperty(host,"ssh.user")
		askPassword=config.HasProperty(host,"ssh.askpassword","true")
		update=true
		upgrade=true
		distUpgrade=config.HasProperty(host,"apt.dist-upgrade","true")
		report(host, sshUser, askPassword, update, upgrade, distUpgrade)
/DemoUpdate




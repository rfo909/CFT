# License
<<< EOF
#
# CFT - an interactive programmable shell for automation 
# Copyright (C) 2020-2025 Roar Foshaug
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>
#
>>> EOF
//License


# Readme
# --
<<< EOF
A web interface for managing content in different locations which
has an date, either a "best-before" or "added to freezer".

TODO: 
When pressing Show for a named storage, we get a list. 

- Must add links on the names, where we can edit an entry, and optionally delete it
- It should contain links to decrease the count by 1, and when reaching zero, delete the entry

Must also offer edit link in the "Added to Xxx" screen


>>> EOF
/Readme

# Log file
# --
    File("WebTest_log.txt")
/LogFile

# Image dir
# --
	Dir("/home/roar/Images")
/ImageDir


# Database app id
# --
	"Freezer2"
/DbId


# Get storage name for storage id
# --
	P(1) as int => id
	Db2:Get(DbId,"Storages",List).get(id)
/GetStorageName

# Parse date
# --
	P(1) as String => datestring
	datestring.replace("-"," - ").split("-") => parts
	if (parts.length==1) parts.add("1")
	if (parts.length==2) parts.add("1")
	
	# (current year is 2026)
	
	# -9  becomes 2026-09-01
	# 30-9-2 becomes 2030-09-02
	# -10 becomes 2026-10-01
	
	y=parts.get(0).trim
	m=parts.get(1).trim
	d=parts.get(2).trim
	
	if (m.length==0) m="1"
	if (d.length==0) d="1"
	
	if (m.length==1) m="0"+m
	if (d.length==1) d="0"+d
	
	year=Date.setFormat("yyyy").fmt
	year=year.sub(0,year.length-y.length)+y
	
	str=year + "-" + m + "-" + d
	
	Date.setFormat("yyyy-MM-dd").parse(str)
/ParseDate	
	



# Initialize web server 
# --

    Std.Web.Server(8080) => server
    if (LogFile.exists) LogFile.delete
    server.setServerLogFile(LogFile)
    
    server.RootContext => Root   # The "/" path

    # Define my.css "file"
    Root.Context("my.css","text/css")
        .GET(Lambda{
            P(1) as WebRequest => requestObj

			# return text as list of lines
            Sequence(
                #@ * {font-family: courier}
                @ * {font-size: 18pt}
                @ .action {background-color: #99FF99; color: black}
                @ .link {font-weight: bold; color: #449944}
                @ .data {color:#444499}
                @ .content {padding-left:1Em}
            )
    })

    # path = /
    Root.GET(Lambda{
        P(1) as WebRequest => requestObj

	storages=Db2:Get(DbId,"Storages",List)
	hidden=Db2:Get(DbId,"HiddenStorages",List)
	
	
	content=Inner{
		pos=0
		storages->st
			if (!hidden.contains(st)) {
				line='<a class="link" href="/storage?id=' + pos + '">' + st + '</a></br><br/>'
				out(line)
			}
			pos=pos+1

	}
			

        Sequence(
            @ << BodyStart >>
            @ 
            @ << content >>
            @ <br/>
            @
            @ <form action="/addstorage" method="POST">
            @ <input type="text" name="storage" style="width:10Em">
            @ <button class="action" type="submit">Add</button>
            @ </form>

            @ <form action="/hidestorage" method="POST">
            @ <input type="text" name="storage" style="width:10Em">
            @ <button class="action" type="submit">Hide</button>
            @ </form>

            @ << BodyEnd >>
        ).mergeExpr
    })
    
    Root.Context("addstorage", "text/html")
    	.POST(Lambda{
 	    P(1) as WebRequest => requestObj
 	    bp=requestObj.bodyParams
 	    st=bp.storage.trim
 	    result=null
 	    if (st=="") {
 	    	result="Enter storage name!"
 	    } else {
 	    	Db2:Get(DbId,"Storages",List).add(st).unique => newList
 	    	Db2:Set(DbId,"Storages",newList)
 	    	
 	    	Db2:Get(DbId,"HiddenStorages",List) => hidden
 	    	hidden=Inner{
 	    		hidden->x reject(x==st) out(x)
 	    	}
 	    	Db2:Set(DbId,"HiddenStorages",hidden)
 	    	result="Storage added!"
 	    }
 	    
 	    Sequence(
	    	@ <<BodyStart>>
	    	@ <<result>>
	    	@ <a class="link" href="/"> Back </a>
	    ).mergeExpr
	   })
   	
    
    Root.Context("hidestorage", "text/html")
    	.POST(Lambda{
 	    P(1) as WebRequest => requestObj
 	    bp=requestObj.bodyParams
 	    st=bp.storage.trim
 	    result=null
 	    if (st=="") {
 	    	result="Enter storage name!"
 	    } else {
 	    	Db2:Get(DbId,"HiddenStorages",List).add(st).unique => newList
 	    	Db2:Set(DbId,"HiddenStorages",newList)
 	    }
 	    
 	    Sequence(
	    	@ <<BodyStart>>
	    	@ <<result>>
	    	@ <a class="link" href="/"> Back </a>
	    ).mergeExpr
	   })
   	
    
    Root.Context("storage","text/html")
    	.GET(Lambda{
	    P(1) as WebRequest => requestObj
	    id=requestObj.urlParams.id.parseInt
	    
	    Sequence(
	    	@ <<BodyStart>>
	    	
	    	@ <a class="link" href="/list?id=<<id>>">Show</a>
		@ <br/>
	    
	    	@ <form action="/add" method="POST">
	    	@ <input type="hidden" name="id" value="<<id>>"/>
	    	    	  	
	    	@ <h1><<GetStorageName(id)>></h1>
	    	@ <table>
	    	@ <tr>
	    	@   <td>Name</td>
	    	@   <td>Date</td>
	    	@   <td>Count</td>
	    	@ </tr>
	    	@ <tr>
	    	@   <td><input name="article" style="width:20ex"/></td>
	    	@   <td><input name="date" style="width:10ex"></td>
	    	@   <td><input name="count" style="width:5ex"></td>
	    	@ </tr>
		@ </table>
	    	@ Date: y-m-d / y-m / -m / -m-d
	    	@ <br/><br/>
	    	@ <button class="action" type="submit">Add</button>
	    	@ </form>

	    	@ <<BodyEnd>>
	    ).mergeExpr
	})		   



    # path = /add (POST)
    Root.Context("add","text/html")
    	.POST(Lambda{
	    P(1) as WebRequest => requestObj
	    bp=requestObj.bodyParams
	    id=bp.id.parseInt
	    
	    
	    result=null
	    if (bp.article != "" && bp.date != "") result = AddArticle(id,bp.article,bp.date,bp.count)
	    
	    if (result == null) result="Missing values!"
	    Sequence(
	    	@ <<BodyStart>>
	    	@ <<result>>
	    	@ <br>
		@ <a class="link" href="/storage?id=<<id>>"> Back </a>
	    	@ <<BodyEnd>>
	    ).mergeExpr
    	})


    # path=/list (GET)
    Root.Context("list","text/html")
    	.GET(Lambda{
	    P(1) as WebRequest => requestObj
            id=requestObj.urlParams.id.parseInt
            result = ListAll(id)
            
	    Sequence(
	    	@ <<BodyStart>>
	    	@ <<result>>
	    	@ <br>
		@ <a class="link" href="/storage?id=<<id>>"> Back </a>
	    	@ <<BodyEnd>>
	    ).mergeExpr            
         })
         .POST(Lambda{
	    P(1) as WebRequest => requestObj
            id=requestObj.bodyParams.id.parseInt
            filter=requestObj.bodyParams.filter
            result = ListAll(id,filter)

	    Sequence(
	    	@ <<BodyStart>>
	    	@ <<result>>
	    	@ <br>
		@ <a class="link" href="/storage?id=<<id>>"> Back </a>
	    	@ <<BodyEnd>>
	    ).mergeExpr
         })
            
         
	
    
    Root.Context("icon","image/jpg")
    	.GET(Lambda{
            P(1) as WebRequest => requestObj
            id=requestObj.urlParams.id

            file=ImageDir.file(id+".jpg")

            binaryData=file.readBinary
            binaryData
    	})
            
        
/Init




# Add article
# --
	P(1) as int => storageId
	P(2) as String => name
	P(3) as String => dateString
	P(4) as String => countString
	
	
	
	tryCatch(countString.parseInt) => countParse
	tryCatch(ParseDate(dateString)) => dateParse
	if (!countParse.ok)
		"Invalid count, must be number!"
	else
	if (!dateParse.ok || dateParse.result==null) {
		"Invalid date value!"
	} else {
		count=countParse.result
		date=dateParse.result
		
		Db2:Get(DbId,"Data",List) => data
		data.add(SymDict(storageId,name,date,count))
		Db2:Set(DbId,"Data",data)
		
		Sequence(
			@ "<<GetStorageName(storageId)>>"<br/>
			@ <br/>
			@ Name: <span class="data"><<name>></span><br/>
			@ Date: <span class="data"><<date.fmt>></span><br/>
			@ Count: <span class="data"><<count>></span>
		).mergeExpr
	}
/AddArticle
	



# List all
# --
	P(1) as int => storageId
	P(2) as String? => filter  # via POST to /list - form below
	
	Db2:Get(DbId,"Data",List) => data
	lines=Inner{
		data->d 
			assert(d.storageId==storageId)
			reject(filter != null && !d.name.toLower.contains(filter.toLower))
			out(Int(d.date.get,d))
		| _.sort->x
			d=x.data
			out("<tr><td>" + d.date + "</td><td class='data'>" + d.name + "</td><td>(" + d.count + ")</td></tr>")
	}

	# generate page	
	Sequence(
		@ <b><<GetStorageName(storageId)>></b><br/><br/>
		@ <form action="/list" method="POST">
		@ <input type="hidden" name="id" value="<<storageId>>"/>
		@ <input type="text" name="filter" style="width:5Em"/>
		@ <button type="submit" class="action">Filter</button>
		@ </form>
		@ <br/>
		@ <table>
		@ <<lines>>
		@ </table>
	).mergeExpr
/ListAll



# Helpers


# Open Body 
# --
    Sequence(
            @ <html>
            @ <head>
            @   <meta charset="utf-8"/>
            @   <link rel="stylesheet" href="/my.css">
            @ </head>
            @ <body>
            @ <a href="/"><span style="color:red; font-size:36pt">Start</span></a><br/><br/>
    )
//BodyStart


# Close Body 
# --
    Sequence(
        @ </body>
        @ </html>
    )
//BodyEnd


# Show all data from Request object
# --
    P(1) => req
    
    body=req.body
    if (body==null) {
        body="null"
    } else {
        # Binary value
        body=body.hex
        if (body.length > 50) body=body.sub(0,40) + "..."
    }
    Sequence(
        @ <h2>.headers</h2>
        @ <<ShowDict(req.headers)>>
        @ <h2>.method</h2>
        @ <<req.method>><br>
        @ <h2>.url</h2>
        @ <<req.url>><br/>
        @ <h2>.urlParams</h2>
        @ <<ShowDict(req.urlParams)>>
        @ <h2>.body</h2>
        @ <<body>><br/>
        @ <h2>.bodyParams</h2>
        @ <<ShowDict(req.bodyParams)>>
    ) -> line
        line.mergeExpr->s out(s)
//ShowRequest

# Show dictionary
# --
    P(1)=>dict
    dict.keys->key
        out(""+key + ": " + dict.get(key) + "<br/>")
//ShowDict


# Show logfile
# --
    LogFile.read
/show

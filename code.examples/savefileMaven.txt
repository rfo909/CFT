# License
<<< EOF
#
# CFT - an interactive programmable shell for automation 
# Copyright (C) 2020-2024 Roar Foshaug
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>
#
>>> EOF
/License


# Set group id as used by git for this project
# --
	Db2:Set(Sys.scriptId,"git-group-id",readLine("Enter group id"))
/SetGroupId



# Group id for git
# --
	Db2:Get(Sys.scriptId,"git-group-id",null) => gid
	if (gid==null) {
		readLine("Enter group id for project") => gid
		Db2:Set(Sys.scriptId,"git-group-id", gid)
	}
	gid
/GetGroupId
		
	


# Get all git submodule directories on form \x\y\ so that we can use .contains on path string
# --
	dict=Dict
	f=Dir.file(".gitmodules")
	if (f.exists) {
		f.read->line
			assert(line.contains("path ="))
			s=line.after("=").trim
			s="\" + s.replace("/","\") + "\"
			out(s)
	} else {
		List
	}
//GitSubmodules

		
# Path depth of file (helper)
# --
	P(1) as File => f
	f.path.chars->c
		assert(c==Sys.fileSeparator)
		out(1)
	| _.length
//PathDepth



# All pom files under current dir
# Sorted so that deepest path files come first
# --
	P(1,false)=>includeSubmodules

    Dir.allFiles("pom*.xml")->pom
		path=pom.path
		if (!includeSubmodules) {
			foundList = Inner{
				GitSubmodules->m
					if (path.contains(m)) out(1)
			}
			if (foundList.empty) out(pom)
		} else {
			out(pom)
		}
	| -> pom
		out(Int(PathDepth(pom), pom))
	| _.sort.reverse->x 
		out(x.data)
/Pom

# Get first line with a certain pattern
# --
    P(1) => pomFile
    P(2, readLine("Enter pattern")) => pattern
    pomFile.read->line
        if (line.contains(pattern)) {
            out(line)
            break
        }
//GetFirst


# Select Pom file
# --
    files=Pom
    files->f
        println(f.path)
    |
    Lib:SelectOptions(files, Lambda{P(1).path}, Lambda{P(1)})
//SelectFile

# Get build version for pom file
# --
    GetFirst(P(1),"<version>")
/BV

# Get groupId for pom file
# --
    GetFirst(P(1),"<groupId>")
/GI

# Get artifactId for pom file
# --
    GetFirst(P(1),"<artifactId>")
/AI


# Create summary of pom file detailing what artifact it creates, and dependencies, on simple line format
# --
	P(1, Pom.first) as File=>f
	XML:Parse(f.read).first => node

	out("file " + f.path)
	s=node.subNode("groupId").getContent 
		+ ":" + node.subNode("artifactId").getContent 
		+ ":" + if(node.subNode("version") != null, node.subNode("version").getContent, "UNKNOWN")
	out("create " + s)
	node.subNode("dependencies").subNodes("dependency")->dep
		s=dep.subNode("groupId").getContent 
			+ ":" + dep.subNode("artifactId").getContent
			+ ":" + if(dep.subNode("version") != null, dep.subNode("version").getContent, "UNKNOWN")
		out("dep " + s)

/CreateSummary


# Show artifact and version from all pom files
# --
	Pom->f
		XML:Parse(f.read).first => node
		report(f, node.subNode("groupId").getContent + ":" + node.subNode("artifactId").getContent + ":" + node.subNode("version").getContent, f.path)
/Versions
	

# Create pom summary as dictionary
# --
	P(1,Pom.first) as File => f
	dict=Dict
	dict.dep=List
	dict.file=f
	CreateSummary(f)->line
		if (line.startsWith("create ")) {
			dict.set("create",line.after(" "))
		} else if (line.startsWith("dep ")) {
			dict.dep.add(line.after(" "))
		}
	|
	dict
/CreateSummaryDict


# Update dependency version for all pom files
# NOTE: XML:PP does not preserve comments and specials like <?xml ...> header from original file!!!
#
# --
	P(1,Input("Enter <groupId>:<artifactId>:<version>").get) => s

	groupId=s.before(":")
	s=s.after(":")
	artifactId=s.before(":")
	version=s.after(":")

	Pom->f
		Inner {
			updated=false
			XML:Parse(f.read).first => obj
			obj.subNode("dependencies").subNodes("dependency")->dep
				assert(dep.subNode("groupId").getContent.trim==groupId)
				assert(dep.subNode("artifactId").getContent.trim==artifactId)
				assert(dep.subNode("version").getContent.trim != version)
				updated=true
				dep.subNode("version").setText(version)
			|
			if (updated) {
				println("*** Updating " + f.path)
				List(
					'<?xml version="1.0" encoding="UTF-8"?>'
				) + XML:PP(obj)
				#XML:PP(obj) => lines
				f.setWriteLF.create(lines)
			}
		}
/UpdateDependency
		

# Update all git modules
# --
	Git:UpdateSubmodules
/UpdateGitSubmodules



# File header
# --
	P(1) as File=>file
	P(2) as String=>s

	file.append("")
	file.append(s)
	file.append("-".times(s.length))
//FileHeader



# For all pom files under current directory, including submodules, create summaries of dependencies
# and mark local dependencies between pom files
# --
	P(1,false) => includeSubmodules
	P(2,Dir) => dir

	Lib:TmpFile("summaryAll","txt") => resultFile
	if(resultFile.exists) resultFile.delete

	FileHeader(resultFile,"Summarizing all pom*.xml found under " + dir.path + "  " + Date.fmt)
	resultFile.append("")
	resultFile.append("Dependencies:")
	resultFile.append("  '*' means created by local pom file")
	resultFile.append("  'E' means inconsistent versions between dependency and local pom file")
	resultFile.append("  'X' means starts with GetGroupId but not to with local pom")
	resultFile.append("")


	list=List
	Pom(includeSubmodules)->f
		list.add(CreateSummaryDict(f))
	|
	list->summary
		# for each dependency, search through the summaries, to see if 
		# any of them create that dependency
		FileHeader(resultFile,summary.create)
		resultFile.append(summary.file.path)

		summary.dep->dep
			prefix="   "
			if (dep.startsWith(GetGroupId)) prefix=" X "
			extra=""
			
			Inner{
				list->x
					reject(x==summary)
					if (x.create.beforeLast(":")==dep.beforeLast(":")) {
						# artifact match (independent of version)
						prefix=" * "
						if (x.create.afterLast(":") != dep.afterLast(":")) {
							# versions differ
							prefix=" E "
							extra="  --  should be " + x.create.afterLast(":")
						}
					}
			}
			resultFile.append(prefix + dep + extra)
	|
	resultFile.append("")


	# List all dependecies (not including submodules), sorted and unique, to reveal differing versions
	allDep=List
	Pom(false)->f
		CreateSummaryDict(f).dep->dep
			allDep.add(dep)
	|

	FileHeader(resultFile,"All dependencies from the POM files (not submodules)")
	allDep.sort.unique->dep
		resultFile.append("   " + dep)
	|
	resultFile.append("")

	Lib:e(resultFile)
/ShowSummaryAll



# test-compile all pom files (except git submodules)
# --
	P(1,false) => showErrors
	Pom->f
		Lib:Header(f.path)
		result = Lib:run(List("cmd","/c","mvn","-f", f.path, "clean","package","-U"), null, true)

		if(result.exitCode==0) println("   OK") else println("   ERROR")

		if (showErrors) {
			lines = result.stdout + result.stderr
			lines->line
				if (line.contains("[ERROR]")) Lib:ShowText(line)
		}

/CompileAll


# Run deploy on all pom files (except git submodules), to update repo
# --
	Pom->f
		Lib:Header(f.path)
		result = Lib:run(List("cmd","/c","mvn","-f", f.path, "deploy"), null, true) 

		if(result.exitCode==0) println("   OK")

		lines = result.stdout + result.stderr
		lines->line
			if (line.contains("[ERROR]")) Lib:ShowText(line)

/DeployAll


# Show pom files which have no java source files under the pom directory 
# --
	fsep=Sys.fileSeparator
	Pom->f
		count=Inner{
			f.dir.allFiles("*.java")->javaFile
				reject(javaFile.path.contains(fsep+"target"+fsep))
				out(1)
			| _.length
		}
		report(f, f.path, count)
/NoJava


# Create search structure for all jar files under current dir
# --
	P(1,Dir) => currentDir
	P(2,false) => includeInnerClasses

	println("Processing jar files")
	data=List

	currentDir.allFiles("*.jar") -> f
		println(f.path)
		data.add(Java:JarContent(f, includeInnerClasses))
	|

	loop
		println
		readLine("Search for class, blank to abort") => str
		break(str=="")
		Inner{
			data->jc  # JarContent Dict
				header=false
				{
					jc.classes->class
						if (class.contains(str)) {
							if (!header) {
								Lib:Header(jc.jarFile.path)
								header=true
							}
							println(class)
						}
				}
		}

/MissingClassesSearch


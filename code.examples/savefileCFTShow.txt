# License
<<< EOF
#
# CFT - an interactive programmable shell for automation 
# Copyright (C) 2020-2025 Roar Foshaug
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>
#
>>> EOF
/License


CodeStats:main->line out("^t".unEsc+line)
//Stats

<<<<< TEXT
.h CFT

    https://github.com/rfo909/CFT

	"ConfigTool"

    - Script language
    - Shell
	- GNU GPL 3.0 ("open source")
	- Java



.h Shell
    - ls / cd 
    - cat / more / tail
	- cp / mv / rm / mkdir
	- touch / edit
	- hex / hash / grep / which / showtree
	
	!         <- show history
	@         <- list shortcuts
	:         <- list colon commands
    ?         <- list functions in script
	@%        <- list symbols
		
	@S        <- search
	@FL       <- file locate
	@fp       <- file paths

    help
	<value> help



.h @P

	# Projects script

    EditConfig

    ch
	curr

    S
    FL




>>>>> TEXT
	.mergeExpr
//text

# Process line, return number of lines printed
# --
    P(1) => line
    P(2) => first
    
    if (line.startsWith(".h")) {
        if (!first) {
            readLine("Enter")=>x error(x != "","Aborting")
        }
        println(Curses:Clear)
        Inner {
            Letters7x5:T9x10(line.sub(2).trim)->line 
                str=line #.replace("#","O")
                println(Curses:TxtGreen + str + Curses:Reset)
			|
            println
        }
    } else {
        println(line)
        if (line.trim!="") Sys.sleep(line.trim.length*80+800)
    }
//ProcessLine


# Show text
# --
    P(1,List) => lines
    first=true
    lines->line 
        ProcessLine(line, first)
        first=false
    |
    "Done"
//Show



# Show text
# --
    Show(text)
/t




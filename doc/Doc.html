<html>
<head>

<style type="text/css">
	* {font-family: arial}
	pre {font-family:courier; margin-left:1Em; padding-left: 1Em; font-size: 16pt}
	h1 {padding-top:1Em; color: blue}
</style>
</head>
<body>

<h1 style="padding-left:0; margin-left:0; font-size:24pt; font-family:monospace; color:black">
CFT / ConfigTool
</h1>

<pre style="padding-left:0; margin-left:0">

Last updated: 2020-08-06 RFO
v1.1.4

</pre>

<h1>Introduction</h1>

<p>
  CFT is a programmers tool, in the form of a Java application that runs in a 
  terminal window. It has no graphical
  elements, which means it can run everywhere. From the start it has been developed
  as an interactive environment, with strong emphasis on automation. The syntax is compact, 
  in the interest of getting useful work out of even a single line of code.
</p>

<p>
  CFT is tested on Linux and Windows, and easily integrates with external commands
  on both, such as PowerShell, git, ssh. It should run everywhere that supports Java.
</p>

<p>
  Development has been going on since May 2018, and v1.0 towards end of June 2020
  marked a certain level of robustness and error
  handling, being mature enough for open source release on github. 
</p>
<p>
  It started out purely as an interactive
  tool, with emphasis on compact syntax, since all code was entered via the command line. After
  a while it evolved into editing the savefiles, or "script files". 
</p>

<p>
  Functionality has been driven partially by needs and partially by what's fun to implement.
</p>




<h1>What CFT is not</h1>
<p>
  CFT does not allow classes or objects apart from those predefined. That would
  increase complexity a lot, be harder to implement (scope rules, inheritance etc), 
  and is not what was needed.
</p>
<p>
  CFT is meant for automation tasks, such as moving files, searching and running
  external programs. It is a Domain Specific Language, not general purpose.
</p>
<p>
  Writing big functions is no problem. Letting scripts call each other is 
  also both supported and heavily used. However, it is not a language that
  supports any level of abstractions.
</p>
<p>
  <em>It is a do-this-then-that type of language.</em> 
</p>
<p>
  Also, for many purposes, we will call external programs. In this respect, CFT is a shell, in that it
  depends on external programs. Still, CFT is not a full shell. You will usually also need regular shells 
  for all kinds of interactive commands, as well as file managers etc.
</p>
<p>
  CFT doesn't support autocomplete, since its interactivity is line based. 
</p>


<h1>So what is it for?</h1>
<p>
  Commands like "ls" and "cd" exist, with globbing, as well as "more" and "edit" (which opens a file
  in an editor), and they are meant for moving around the directory tree. Actually changing 
  and moving files and directories is supposed to be scripted with code. 
</p>
<p>
  Everything in CFT is functions, and defining your own is super easy, and <em>this is the point of CFT</em>, 
  the automation aspect, and that automation should be a simple and interactive process.
</p>

<h2>Functions example</h2>

<p>
  CFT is object oriented, as opposed to traditional *ix shells such as bash, which process text.
</p>
<p>
  This means that the return value from some function always is an object that has other functions
  inside. Strings, integers and floats are all objects.
</p>
<p>
Example:
</p>
<pre>
$ Dir.files.length

# means: 
# - call global function Dir() with no parameters
# - returns Dir object for current directory
# - call .files() inside the Dir object 
# - returns list of File objects
# - call .length() function on the list object
# - returns an int
</pre>

<h3>No parantheses?</h3>
<p>
  When calling a function without parameters, the parantheses () are optional. 
</p>

<h2>Mission-critical operations</h2>

<p>
  Working on live systems, one must at all costs avoid issuing the wrong commands. 
  Creating functions, and preferrably adding code to validate input, to reject specific server
  names or domains, plus the .protect() mechanism for Dir and File objects, helps you avoid doing
  seriously bad things. 
</p>
<p>
  Functions will often ask you to enter data, and this means you need proper sanity checks
  before doing dangerous operations. Nothing ruins the day like killing the wrong database
  or VM. 
</p>



<h2>Non-critical tasks</h2>

<p> 
  Even mundane operations still have the potential for unwanted consequences, such as deleting
  the original log files at the remote server, instead of the copy you unzipped locally.
</p>
<p>
  The protect() mechanism is created for these scenarios.
</p>
<p>
  It lets us block Dir or File objects against destructive operations, and is inherited by all
  Dir and File objects derived from these. The aim is to protect us from mistyping in
  those "in a hurry" situations, where one may directly enter commands like this.
</p>
<pre>
  $ someDir.allFiles-&gt;f f.delete
</pre>



<h2>The boring stuff</h2>
<p>
  Apart from all kinds of security measures possible with functions, there is the obvious: they
  can be run over and over again.
</p>
<p>
  Here are some typical areas of boring tasks that CFT handles easily.
</p>

  <ul>
  <li> copying files</li>
  <li> searching source code and logs</li>
  <li> deploying jar files to test environments</li>
  <li> restart services</li>
  <li> identify log files between certain dates</li>
  <li> verify that a bunch of VM's can be pinged</li>
  <li> generate netplan config files</li>
  <li> remote management via ssh</li>
  <li> automate git and powershell and other things that require you to type too much</li>
</ul>





<h1>CFT as a shell</h1>

<h2>Navigating directories</h2>
<p>
  CFT started out as an interactive shell-like app. It runs in a terminal window, and offers a simple '$' prompt, where one enters commands.
</p>
<p>
  <i>As of v1.1.1 the prompt is now "live", being a macro defined in the CFT.props file. By default it displays
  the name of the current script before the '$' character. It can easily be changed to display current
  directory, time of day, and anything else you care write code for.</i>
</p>

<pre>
  $ ls
  $ cd subdir
  $ cd ..
  $ pwd
  $ ls ../someDir/*.txt
</pre>



<h2>Show content of file</h2>
<p>
  Now if we want to list content of file "TODO.txt", we can enter
</p>

<pre>
  $ cat TODO.txt
  $ more TODO.txt
  $ edit TODO.txt
</pre>






<h1>The help system</h1>
<p>
  To get information about what global functions are available, type "help" and press Enter. A list of global
  functions is displayed with a short description for each. To get help for functions available inside an
  object, put an object of that type on the stack followed by help.
</p>

<pre>
  $ help
  $ "" help
  $ Dir help
  $ 3 help
  $ 0.1 help
</pre>

<p>
The first produces a list of global functions, the second of functions inside string objects, and
the third displayes the functions inside Dir objects. The fourth lists functions available on
int, and the last for float values.
</p>









<h1>List basics</h1>
<p>
  Lists are created with the global List() function, which creates
  a list from all its parameters.
</p>
<pre>
  $ List(1,2,3,4)
</pre>

<p>
  Lists are also returned from many other functions, for example
  calling Dir.files() function produces a list of File objects inside that
  directory object.
</p>


<pre>
  $ Dir.files
</pre>

<p>
  Many functions are available on a List object. One frequently used is "nth", which
  gets a specific element, defaulting to 0 if no argument.
</p>
<pre>
  $ List("a","b","c").nth
  &lt;String&gt;
  a
</pre>

<p>
  For details of available functions, as always use the help system:
</p>
<pre>
  $ List help
</pre>









<h1>Files</h1>
  <pre>
  $ File("x.txt")
   &lt;obj: File&gt;
   x.txt   DOES-NOT-EXIST 
  </pre>

 <p>
  The File() function requires a name, and returns a File object. As seen
  above, the file needs not exist.
</p>
<p>
  File objects created with a simple file name (no path), are always located in
  the CFT home directory. This gives predictability for certain data files etc.
</p>
<p>
  To access or create files in other directories, enter an absolute or relative
  path in the parameter to File(), or use the file() function inside
  some Dir object:
</p>
<pre>
  $ SomeDirExpression.file("x.txt")
</pre>


<h2>Create file</h2>
<p>
To create a file with a single text line:
</p>

<pre>
  File("x.txt").create("one line")
</pre>

<p>
  If the file already exists, it is overwritten with the new content.
</p>
<p>
  Usually, we create files with more than one line, and this is done supplying a List
  instead of a single value, as parameter to the File.create() function.
</p>

<h2>Read file</h2>

<p>
  To read an existing text file:
</p>
<pre>
  File("x.txt").read
</pre>
<p>
  This returns a list of all lines in the file.
</p>

<h2>Append to file</h2>

<p>
  To append a single line to a file:
</p>
<pre>
  File("x.txt").append("another line")
</pre>
<p>
  To append multiple lines, append a list instead.
</p>

<h2>Page through a file</h2>

<p>
  To page through text file
</p>
<pre>
  more x.txt
</pre>

<h2>Show bytes of file</h2>
<p>
  To page through list of bytes (hex)
</p>
<pre>
  File("x.txt").hex
</pre>

<h2>Encoding</h2>
<p>
  Default encoding is "ISO_8859_1", but this can be changed, for example:
</p>
<pre>
  File("x.txt").encoding("UTF-8")
</pre>

<h2>Delete a file</h2>
<pre>
  File("x.txt").delete
</pre>



<h1>Directories</h1>
<pre>
  $ Dir
  &lt;obj: Dir&gt;
  ConfigTool/ d:5 f:20
</pre>

<p>
  Calling the Dir function with no parameters returns a Dir object for the current directory. The Dir
  object offers multiple member functions, one of which is <b>.files()</b>, which produces a list of files in 
  the directory. We can also call the Dir function with a path parameter.
</p>

<h2>Create a subdirectory</h2>
<pre>
  Dir.sub("someDir").create
</pre>
<h2>Parent directory</h2>
<p>
  To get the parent directory of a Dir object:
</p>
<pre>
  Dir.sub("..")
</pre>
<h2>Get files in a directory</h2>
<pre>
  Dir.files
</pre>
<h2>Create a file in a directory</h2>
<pre>
  Dir.file("x.txt").create("something")
</pre>
<h2>Get immediate directories in a directory</h2>
<pre>
  Dir.dirs
</pre>
<h2>Get all files recursively under a directory</h2>
<pre>
  Dir.allFiles
</pre>
<h2>Get all directories recursively under a directory:</h2>
<pre>
  Dir.allDirs
</pre>
<h2>Delete a sub-directory</h2>
<p>
  The sub-directory must be empty
</p>
<pre>
  Dir.sub("something").delete
</pre>





<h1>The shell() function</h1>
<p>
  The global shell() function starts a shell inside CFT. When you exit from it, you're back
  in CFT.
</p>
<pre>
  $ shell
  (starts bash or cmd or Powershell or something else)
  exit
  # Running /usr/bin/bash completed: 25529ms
  $
</pre>










<h1>Core types</h1>
<ul>
  <li>String</li>
  <li>int - (Java long)</li>
  <li>float - (Java double)</li>
  <li>boolean</li>
  <li>List</li>
</ul>
<p>
  All values in CFT are objects, which may contain functions. Strings can be written using double
  or single quotes. 
</p>

<h2>String literals</h2>
<p>
  Strings are written in single or double quotes, and can be summed with '+', which allows
  for all kinds of combinations.
</p>
<pre>
  $Â "'a'"
  &lt;String&gt;
  'a'

  $ '"' + "'a'" + '"'
  &lt;String&gt;
  "'a'"
</pre>
<p>
  Also, backslash is not used as escape character, which means backslash is just another character,
  simplifying those Windows paths. 
</p>





<h1>List iteration / filtering</h1>

<p>
  Lists are essential for all processing with CFT.
</p>
<p>
  Lists can be created manually using the global List() function. 
</p>

<pre>
  $ List(1,2,3)
  $ List("a","b","c")
</pre>

<p>
  A much used way for creating lists of strings, is to use the string function split(), which by default
  splits a string on spaces. This means the following produce the same result.
</p>

<pre>
  $ List("a","b","c")
  $ "a b c".split
</pre>




<h2>Iterating over list content</h2>
<p>
  The iterator in CFT takes the form of an arrow followed by a loop variable. For a loop construct
  to return output, we use the out() statement inside.
</p>

<pre>
  $ "1 2 3".split-&gt;x out("a"+x)
  &lt;List&gt;
   0: a1
   1: a2
   2: a3
</pre>

<p>
  The result is a list of strings, as displayed.
  </p>




<h2>Filtering with assert(), reject() and break() + out()</h2>
<p>
  Using the assert() statement, we may abort processing for elements that do not meet a condition. 
</p>
<pre>
  $ Dir.allFiles-&gt;f assert(f.name.endsWith(".java")) out(f)
</pre>
<p>
  The reject() statement is the inverse of assert(), and aborts processing for elements that meet
  a certain condition.
</p>
<pre>
  $ List(1,2,3,2,1)-&gt;x reject(x&gt;2) out(x)
  &lt;List&gt;
  1
  2
  2
  1
</pre>
<p>
  The break() statement terminates the loop if the condition is true.
</p>
<pre>
  List(1,2,3,2,1)-&gt;x break(x&gt;2) out(x)
  &lt;List&gt;
  1
  2
</pre>



<h2>The condOut() statement</h2>
<p>
  In addition to controlling loops with assert/reject and break, there is the condOut()
  statement, which takes a boolean condition as first parameter, and the value to 
  be sent out as second parameter. Can be useful some times.
</p>
<pre>
  $ List(1,2,3,2,1)-&gt;x condOut(x&lt;2,"(") out("b") condOut(x&lt;2,")") | _.concat
  &lt;String&gt;
  (b)bbb(b)
</pre>





<h2>List addition</h2>
<p>
  Two lists can be added together with "+".
</p>
<pre>
  List(1,2) + List(3)
  &lt;List&gt;
  1
  2
  3
</pre>





<h1>Creating functions</h1>



<h2>Naming lines of code</h2>
<p>
  When some code does what we want, we typically create a function from it. This is done by entering
</p>
<pre>
  ... (some code) ...
  /name
</pre>
<p>
  This assigns the name "name" to the last line, and we have now created a custom function.
</p>

<pre>
  $ Dir.allFiles-&gt; f assert(f.name.endsWith(".java")) out(f)
  $ /JavaFiles
</pre>



<h2>Calling a function</h2>
<p>
  To call the above function, just enter its name.
</p>
<pre>
  JavaFiles
</pre>

<h2>Listing custom functions</h2>
<p>
  Enter '?' and press Enter.
</p>

<pre>
  $ ?
  +-----------------------------------------------------
  | JavaFiles: Dir.allFiles-&gt;f assert(f.name.endsWith(".java")) out(f)
  +-----------------------------------------------------
  | .        : Dir.allFiles-&gt;f assert(f.name.endsWith(".java")) out(f)
  +-----------------------------------------------------
</pre>

<p>
  Here we see function 'JavaFiles' and its code. We also see the last entered code line, with
  a dot '.' in front of it. The last code line is the one that can be given a name, and further,
  the last code line can be repeated by entering a single dot and pressing enter.
</p>







<h1>Savefiles</h1>
<h2>Save</h2>
<p>
  To save all named functions, enter the special command below
</p>

<pre>
  $ :save Test
</pre>

<p>
  This creates a file under the CFT home directory,
  called savefileTest.txt. 
</p>

<h2>Load</h2>

<pre>
  $ :load Test
</pre>


<h2>Create new empty script</h2>
<p>
  To create a new script from scratch, there is the colon command:
</p>
<pre>
  $ :new
</pre>
<p>


<h2>The @e shortcut</h2>
<p>
  A common shortcut is @e, which opens current savefile in an editor:
</p>
<pre>
  $ @e
</pre>
<p>
  Shortcuts can be redefined in the CFT.props file.
</p>


<h2>CFT.props - codeDirs</h2>
<p>
  The CFT.props file contains the following line by default
</p>
<pre>
codeDirs = . ; code.examples ; code.lib
</pre>
<p>
  The codeDirs field defines a search order when loading scripts. 
  The first directory is <b>always</b> used when you type ":save".
</p>
<p>
  The code.examples contains some example code for various use, while code.lib contains
  library code, used by most other scripts.
</p>
<p>
  This means you are free to save a script using the name "Lib", and it will be written to
  the code.work directory. Doing this means it will hide the version in the code.lib directory.
  Which may be perfectly fine, as long as it is what you intended.
</p>





<h1>Protecting files and directories</h1>
<p>
  To save typing, one often create functions that just return some directory, or 
  some files.  The JavaFiles example above illustrates this.
</p>
<p>
  The protect mechanism in CFT lets us attach a protect state to any Dir and File object,
  which guarantees that:
</p>
<ol>
  <li>all files and directories derived from it are also protected</li>
  <li>blocks destructive modifications</li>
</ol>
<h2>Example</h2>
<p>
  Adding .protect to each file that the JavaFiles function generates, ensures that all
  files returned from this function are blocked against accidental delete and modifications.
</p>
<pre>
  $ Dir.allFiles-&gt; f assert(f.name.endsWith(".java")) out(f.protect)
  $ /JavaFiles
</pre>
<p>
  Demonstration:
</p>
<pre>
  $ JavaFiles.nth.append("")   # Trying to append empty line to first file
  ERROR: [input:16] INVALID-OP append : /home/roar/Prosjekter/Java/CFT/src/rf/configtool/main/SourceException.java (PROTECTED: -) (java.lang.Exception)
</pre>
<p>
  The .protect() function can also take a description string, which if present, is displayed in this error.
</p>


<h2>No guarantee</h2>
<p>
  Calling .protect on a Dir object, before using it to locate files, will propagate the protected
  state to all those files. However, creating a new Dir object for the same path, without calling 
  .protect() on it, and then accessing content via this, does not protect anything.
</p>
<p>
  Note also that .protect can not detect for example using the path of a protected File object in
  an external program, or even to create a new File object (which will not be protected). Example:
</p>
<pre>
  File(protectedFile.path)
</pre>

<h2>Laziness is our friend</h2>
<p>
  Usually we will reuse an existing function over creating a new one that does the same.
</p>
<p>
  It may be good design to create functions that return top directories, and protect those
  where we don't want to introduce changes, with secondary functions for locating sub-content, 
  depending on the first function to produce the start point. 
</p>














<h1>CFT as a functional programming language</h1>



<h2>Code only</h2>
<p>
  A major point of CFT is that when we define names using "/name", these names are functions, which
  mean they point to code. When entering code, it is immediately executed, leaving us with a result. When we are happy with the outcome, we may assign a name to the function.</p>
<p>
 The point is that it is the function code that is named, not the result.
</p>

<pre>
  $ "1 2 3".split
  &lt;List&gt;
   0: 1
   1: 2
   2: 3
  $ /data
</pre>

<p>
  Entering the "/data" command
  assigns a name to the last code line, not the data it returned. Every reference to the
  custom function "data" will now run the code over again, and produce (the same) result.
</p>
<p>
  Entering '?' to list your defined functions, you see this clearly.
</p>

<pre>
  $ ?
  +-----------------------------------------------------
  | data: "1 2 3".split
  +-----------------------------------------------------
  | .   : "1 2 3".split
  +-----------------------------------------------------
</pre>




<h2>Local variables</h2>
<p>
  The inside of a function may use local variables for simplifying expressions etc. Variable
  assignment is "stack based", in that it is the current value from the stack that is assigned
  to the local variable.  
</p>

<pre>
  $ 3 =a 2 =b a+b
  &lt;int&gt;
  5 
</pre>





<h2>Stack vs expressions</h2>

<p>
  Even though CFT uses a data stack, expressions are not stack-based.
</p>
<p>
  This is because  writing postfix expressions is too bothersome (ex. "3 2 +"), so CFT 
  only understands expressions using regular infix notation ("3+2"). Respecting normal cardinality rules,
  we have that 2+3*5 becomes 17.
</p>



<h2>Nested loops</h2>
<p>
  Loops are implemented using the "for each" functionality of "-&gt; var". Loops may well be nested.
</p>

<pre>
  $ List(1,2,3)-&gt;x List(1,2,3)-&gt;y  out(x*y)
  &lt;List&gt;
   0: 1
   1: 2
   2: 3
   3: 2
   4: 4
   5: 6
   6: 3
   7: 6
   8: 9
</pre>

<p>
  In this case, the body of each loop is all code following the "-&gt; var"
  construct. But this can be changed using the "pipe" symbol, which "closes" all loops.
</p>



<h2>Loop spaces - "pipes"</h2>
<p>
  The body of any loop is the rest of the code, or until a "pipe" symbol
  is found. The pipe symbol ("|") more accurately breaks the code into a sequence of
  <em>loop spaces</em>, which means acting as an end-point for 
  running loops.
</p>
<p>
  The way a "pipe" works, is to wait for all current loops to terminate, then take the
  return value from that loop space and putting it onto the stack for the next loop
  space to work with (or do something else). Example:
</p>
<pre>
  $ Dir.files-&gt;f out(f.length) | =sizes sizes.sum
</pre>
<p>
  This single line of code first contains a loop, which outputs a list of integers for
  the sizes of all files in the current directory. Then the "pipe" symbol terminates that
  loop space, and creates a new one, where we pick the result from the previous loop
  space off the stack and assigns it to a local variable. We then apply the sum() function to it.
</p>
<p>
  To save us some typing, the special expression "_" (underscore) pops the topmost value off
  the stack.
</p>
<pre>
  $ Dir.files-&gt;f out(f.length) | _.sum
</pre>

<p>
  As we see from the above code, a loop spaces don't <em>need</em> containing loops. The 
  following is perfectly legal, although a little silly.
</p>
<pre>
  $ 2+3 | | | | =x x | =y y | _ |
</pre>
<p>
  Yes, it returns 5.
</p>







<h2>Result value from a loop space</h2>
<p>
  All bodies of code in CFT consist of one or more <em>loop spaces</em>. The result value
  from any such body is the return value from the last loop space.
</p>

<h3>If the loop space contains looping ...</h3>
<p>
  If a loop space contains loop statements, the result value is a list of data generated
  via calls to out() or report() statements. If no actual iteraions take place, or
  filtering with assert(), reject() or break() means no data is generated via out() or report(), 
  then the result is an empty list.
</p>

<h3>Otherwise ...</h3>
<p>
  A loop space that doesn't contain loop statements, has as its return value the topmost
  element on the stack after all code has executed. If there is no value on the stack,
  the return value is <em>null</em>.
</p>






<h2>Function parameters</h2>
<p>
  Custom functions can also take parameters. This is done using the P() expression, which
  identifies the parameter by position. Note that <em>parameter position is 1-based</em>.  
</p>
<pre>
  $ P(1)=a P(2)=b a+b   # fails!
</pre>
<p>
  If you enter the above code interactively, it will fail, complaining that you can not add
  "null + null". This is because there is no call yet, and so there are no parameter values. This is 
  fixed by letting the P() expression take a second parameters, which is a default value expression.
</p>
<p>
  The default value parameter to P() is important for three reasons.
</p>
<ol>
  <li>Allows the function code to execute while being developed interactively</li> 
  <li>May act as documentation in the source</li>
  <li>
    Provides an elegant way of making functions interactive and non-interactive at the same time, 
    as the default expression is evaluated only when parameter is not given (or is null), 
    and may then ask the user to input the value.
</li>
</ol>




<h3>Simple example</h3>
<p>
  Here we make an improved version of the JavaFiles function, that takes a directory parameter, and if none given, uses the current directory ("Dir").
</p>
<pre>
  $ P(1,Dir) =dir dir.allFiles-&gt;f assert(f.name.endsWith(".java")) out(f)
     :
     : (code result)
     :
  $ /JavaFiles
</pre>

<p>
  Typing this code interactively means it gets executed directly, with no actuall call
  parameters. This means P(1) is null, and so the default value ("Dir") is used, which means
  the code runs on current directory.
</p>
<p>
  After defining the function, we may call it without parameters, or supply null for
  a given parameter, which again means the 
  default expression is used, and the code again executes on current directory.
</p>
<p>
  But now we can let this function run on a custom Dir object, regardless of the current
  directory.
</p>
<pre>
  $ Dir("/home/user/project1")
  $ /DirProject1

  $ JavaFiles(DirProject1)
</pre>



<h3>Asking for missing value</h3>
<p>
  The default expression of P() can also be used to ask for a value when the parameters
  is missing.
</p>
<pre>
  P(1,Input("Enter value").get) =value ...
</pre>




<h1>Conditional execution</h1>
<p>
  Conditional execution in CFT takes two basic forms.
</p>
<h2>List filtering</h2>
<p>
  The assert(), reject() and break() statements inside loops decide if the rest of the loop body is to 
  be executed or not, and provide the data filtering mechanism in CFT.
</p>

<h2>if() expression</h2>
<p>
  The if() statement takes three parameters, the condition, the if-expression, and the 
  else-expression. Depending on the condition only one of the two following expressions
  are resolved. 
</p>
<p>
  In this example we call SomeFunction, then use an if() expression to replace return value 'null' 
  with integer 0 (zero).
</p>

<pre>
  SomeFunction(...) =a
  if(a==null, 0, a) =a  # provides a default value if a is null
</pre>

<h2>when() expression</h2>
<p>
  The when() expression is like an if() expression minus the else-part. 
</p>
<pre>
  if (bool, expr)
</pre>
<p>
  If the boolean expression resolves to true, then the 'expr' is resolved, and this becomes the return
  value. Otherwise, the 'expr' is not resolved, and the return value is null.
</p>
<p>
  The when() expression is good for handling multiple-choice ladders ("switch" in Java).
</p>
<pre>
  when (mode==1, SomeFunction(...))
  when (mode==2, SomeOtherFunction(...))
  when (mode==3, ... )
</pre>

<h2>error() expression</h2>
<p>
  The error() expression is another that contains a conditional part, and if true, throws
  an exception with the string part, terminating current execution.
</p>
<pre>
  $ error(1+1==2,"oops")
</pre>





<h1>Block expressions</h1>
<p>
  Block expressions are sequences of code
  inside curly braces, and are frequently used with if() and when(). 
</p>
<pre>
  false =ok
  when (someCondition, {
    println("hello there")
    true =ok
  })
</pre>




<h2>Block expressions are real expressions</h2>
<p>
  Though mostly used with when() and if(), block expressions are general expressions, just
  like a function call, or some variable lookup.
</p>
<pre>
  {2+3}.bin
  &lt;String&gt;
  00000101
</pre>


<h2>Pitfalls</h2>
<p>
  Block expressions occur literally inside other code, and have their variable scope
  extend out into the calling environment, but they are not just code blocks, as in Java. 
  Instead they are a but function-like. This means:
</p>
<ul>
  <li>
    One can not pass data to or from block expressions via the stack, as they operate their
    own stack internally
  </li>
  <li>
    Loop control does not extend from inside a block expressions to the surrounding code, partially
    because block expressions can have their own loops. This means that
    for example calling break(true) has no effect on the caller.
  </li>
</ul>
<p>
  Example:
</p>
<pre>
  "a b c".split-&gt;x
  when(x=="b", {break(true)})  # does not break loop
</pre>
<p>
  The call to break() inside a block expression does not affect the loop running outside
  the block expression. 
</p>
<p>
  With break() taking a boolean value, the above example is a bit artificial, as the solution 
  here is to write:
</p>
<pre>
  "a b c".split-&gt;x
  break(x=="b")
</pre>




<h2>Full functionality</h2>
<p>
  Block expressions can contain looping and the code can be partitioned into a
  number of loop spaces (with the "pipe" symbol). Example:
</p>
<pre>
  List(1,2,3)=a {a-&gt;x assert(x%2==1) out(x) | _.sum} 
  &lt;int&gt;
  4
</pre>





<h1>Running external programs</h1>



<h2>Summary</h2>
<p>
  The functions for running external programs are part of the Dir object, implicitly defining
  working directory for the program.
</p>

<pre>
  $ Dir.run ( list|...)
  $ Dir.runCapture ( list | ...)
  $ Dir.runDetach ( list|...)
  $ Dir.runProcess ( stdinFile, stdoutFile, stdErrFile, list|... )
  $ Dir.runProcessWait ( stdinFile, stdoutFile, stdErrFile, list|... )
</pre>

<p>
  The parameters written as "list|..." means either a List object, or a list of
  String values, separated by comma.
</p>




<h2>Dir.run()</h2>
<p>
  This command is used for running external programs in the foreground. What this means is that if
  the program requires user input, we can give it, and the CFT code will not continue until
  the external process has terminated.
</p>
<pre>
  $ Dir.run("cmd","/c","git","pull","origin","master")
</pre>
<p>
  Many Windows programs require the "cmd","/c" in front of the actual program.
  For proper operating systems (Linux) you naturally skip the two first elements of the command list.
</p>
<p>
  Often it is easier to use String.split in this case, as Dir.run() accept a single List value
  instead of a list of values.
</p>
<pre>
  Dir.run("cmd /c git pull origin master".split)
</pre>



<h2>Dir.runCapture()</h2>
<p>
  This works the same as Dir.run(), but returns a List of strings representing stdout from the
  external program, to be processed further.
</p>

<pre>
  Dir.run("which","leafpad") =lines lines.length&gt;0 && lines.nth.contains("leafpad")
  /HasLeafpad
</pre>



<h2>Dir.runDetach()</h2>
<p>
  Use to run external program in the background. The CFT code continues running after forking
  off the background process. Nice for editors etc.
</p>
<pre>
  $ Dir.runDetach("leafpad", Sys.savefile.path)
</pre>

<p>
  This example runs the (linux) leapad editor in the background, with the path of the current savefile as 
  argument.
</p>




<h2>Dir.runProcess() / .runProcessWait()</h2>
<p>
  Dir.runProcess() is similar to Dir.runDetach(), and Dir.runProcessWait() is similar to
  Dir.run(), but for cases where we need to provide non-interactive input, 
  and inspect the output, as this uses files for stdin, stdout and stderr.
</p>
<p>
  At this level of complexity, one-line functions get a bit less readable, so the example below
  is spread out across multiple lines, and depends on editing the script file directly.
</p>
<p>
  (note: may be less readable on .md format - open Doc.html instead)
</p>
<pre>
  ## --- create temp-file
  P(1)=name 
    Dir("/tmp").file(name + "." + currentTimeMillis)
  /TmpFile

  ## --- Call ssh to list remote processes with ps -efal
  P(1,Input("Enter ssh-target on format user@host").get)=target
    # 
    # Create temp files
    #
    TmpFile("in") =stdin
    TmpFile("out") =stdout
    TmpFile("err") =stderr
    #
    # stdin contains the command(s) we want to run remotely
    #
    stdin.create("ps -efal")
    #
    # Call ssh (requires passwordless login)
    #
    Dir.runProcessWait(stdin, stdout, stderr, "ssh", target)
    #
    # get list of output from the "ps" command
    #
    stdout.read =result
    #
    # delete temp-files 
    #
    stdin.delete
    stdout.delete
    when(stderr.exists, stderr.delete)
    #
    # return value
    #
    result
  /ListRemoteFiles
</pre>

<h3>ssh without password</h3>
<p>
  To set up ssh login without password, create and distribute an ssh key. 
</p>
<p>
  The script "SSH" under code.examples contains code for doing this.
</p>
<pre>
  $ :load SSH
  $ Readme
</pre>





<h1>Editing script files</h1>


<h2>Using editor for entering code</h2>

<p>
  As was illustrated above, in the case of Dir.runDetach(), we can create a function that opens
  the current savefile in an editor. This of course requires a current savefile, which is created
  by colon command save. The Sys.savefile() function returns a File object for the savefile,
  or null if no savefile exists.
</p>

<p>
  Since this is functionality is used very frequently, there exists a global shortcut that does this.
</p>
<pre>
  $ @e
</pre>






<h2>Auto reload</h2>
<p>
  After modifying a script in an editor, and saving it, CFT automatically reloads it the next
  time you run something.
</p>


<h2>No auto save!!</h2>
<p>
  Note that when modifying a script from within CFT, by defining or redefining functions, there
  is <em>no auto save</em>. This is to allow experimentation without making changes permanent, 
  but requires that you remember to save manually when done. 
</p>
<p>
  If you have never saved the script, you must enter a name:
</p>
<pre>
  $ :save SomeName
</pre>
<p>
  Having saved the script before, you need only enter the following:
</p>
<pre>
  $ :save
</pre>


<h3>Losing changes</h3>
<p>
  Doing changes to a script inside CFT, but forgetting to save, then opening the savefile
  in an editor, and saving, causes CFT to automatically reload the savefile, losing the initial
  changes. 
</p>
<p>
  After doing interactive changes inside CFT, always save. Also either refresh file in open
  editor, or close editor and open new.
</p>






<h2>Multi-line functions</h2>
<p>
  Editing the savefile lets us write more complex functions as we can break function
  code across multiple lines, using indentation and comments. The same rules apply as for 
  single lines, regarding how the "pipe" symbol sections the code into multiple
  loop spaces.
</p>




<h2>Comments</h2>
<p>
  The hash character '#' indicates that the rest of the line is a comment.
</p>

<p>
  Note that ALL TEXT following one function assigment ("/name") is included as the 
  code body of the next function. 
</p>





<h2>First line of a function ...</h2>
<p>
  The interactive command '?' is used to see the defined functions. For functions entered
  interactively there is only one line, and that line is shown. For multiline functions, 
  the first line is displayed. 
</p>
<p>
  Letting the first line of a multi-line function be a comment is a great way of 
  producing meaningful content for the interactive '?' command.
</p>
<p>
  Alternatively, putting all parameter grabs on a single first line, serves as great
  documentation of function interface when seen with the '?' command.
</p>





<h2>Debug</h2>
<p>
  When creating complex code, we may need to display debug output. This is done with the global
  debug() function, or you can use the println() function.
</p>

<pre>
  $ debug("data")
  %DEBUG% data
</pre>
<p>
  You can of course also just call println(...)
</p>







<h1>Interactive use</h1>

<h2>Change current directory: cd</h2>
<p>
  The "cd" command should function mostly as expected. CFT has no autocomplete feature, since
  it only reads lines, not key-presses.
</p>
<p>
  CFT handles globbing with '*' in the last part of the path, so you can enter:
</p>
<pre>
  $ cd Proj*
  $ cd ../OtherProj*  # will fail if more than one match
</pre>
<p>
  The "cd" command also has a "funtion mode", where you can enter 
</p>
<pre>
  $ cd (expr)
</pre>
<p>
  The expression must resolve into a Dir object.
</p>


<h3>Change drive letter in Windows</h3>
<p>
The following is used to switch drive letter in Windows.
</p>
<pre>
  $ cd d:\
</pre>

<h3>Paths with space</h3>
<p>
  Also note, that paths with space in them need to be put into
  quotes.
</p>
<pre>
  $ cd "c:\Program Files\blah\blah"
</pre>


<h2>List files: ls</h2>
<p>
  The "ls" command comes in three variants:
</p>
<ul>
  <li> "ls" - lists directories and files</li>
  <li> "lsd" - lists directories only</li>
  <li> "lsf" - lists files only</li>
</ul>

<p>
  As with "cd", it handles globbing with '*' in the last part of the path:
</p>
<pre>
  $ ls *.txt
  $ ls ../OtherProject/*.xml
</pre>
<p>
  Also as with "cd", the "ls" command has a "function mode", where it takes an
  expression inside ()'s.
</p>
<pre>
  $ ls (expr)
</pre>
<p>
  The expr should resolve into a Dir object.
</p>



<h2>Display text file: cat, more, edit</h2>
<p>
  The "cat" command lists the content of a file, while "more" pages through the file, and
  "edit" opens an editor with the file. All these also understand globbing in the same way
  as "cd" and "ls" 
</p>
<pre>
  $ cat README*
  $ more README*
  $ edit README*
  $ cat ../OtherProject/build*.xml   # will fail if more than one match
</pre>
<p>
  As with "ls" and "cd", these also handle "function mode", where we pass an expression
  inside ()'s. Example:
</p>
<pre>
  $ edit (Sys.savefile)
</pre>



<h3>Editing a previous file again</h3>
<p>
  Each time "edit" is used to display a file in an editor, a history log is maintained. To
  display this log, and select a file from it, just type enter with nothing following. This
  only works in interactive mode.
</p>
<pre>
  $ edit
</pre>

<h3>cat, more, edit - implementation</h3>
<p>
  These three commands (statements) are defined via macros in the CFT.props file, which for
  "edit" and "more" calls functions inside the Lib script (under code.lib).
</p>
<o>
  This means that their functionality are not complete defined within the CFT java code, and
  that their functionality can be modified without recompiling the code.
</p>




<h2>Print working directory: pwd</h2>
<p>
  The command "pwd" is also implemented as an expression, and returns the current directory. This
  is the same as the "Dir" expression.
</p>
<pre>
  $ pwd
</pre>



<h2>Using cd, ls, cat, more and edit inside (function) code</h2>
<p>
  Quick answer: <b>this should be avoided.</b>
</p>
<p>
  These statements, unless called in "function mode", with ()'s, WILL consume all tokens up to the
  end of the function, or the next PIPE. They will mess up your code, and fail. For use on the
  interactive command line only.
</p>
<p>
  In script code, there generally is no point in navigating to a current directory. The
  "current directory" is really a concept for interactive use. Once you get to a 
  directory you need to write code for:
</p>
<pre>
  $ pwd
  $ :syn
  $ /MyDir
</pre>
<p>
  The :syn command synthesizes code from the value returned from pwd, and then we assign it
  to a function. From then on, using MyDir to access sub-directories or files, gets the
  same results independent of the current directory. 
</p>
<p>
  To start an editor or page through a file from code, please use the following:
</p>
<pre>
  $ call "Lib:e" (file)  # open editor
  $ call "Lib:m" (file)  # page through file with more
</pre>
<p>
  This is what the "edit" and "more" commands uses internally anyway.
</p>
<p>
  See CFT.props for the cat, more and edit macros for details.
</p>





<h2>Get data from user: Input() and readLine()</h2>
<p>
  To stop and ask the user to enter something, we got two options. The Input() function
  produces an Input object which maintains a
  session state, remembering earlier values, and suggesting the last value entered as default,
  with the ability to show and select earlier values. 
</p>
<p>
  You need to call the ".get()" function on the Input object to actually ask the user to enter
  data.
</p>
<p>
  The readLine() function just pauses and reads a line. Both Input() and readLine() take a
  prompt parameter. For Input objects, the session state remembering previous inputs, is
  tied to the prompt string. 
</p>
<pre>
  $ Input("Enter search text").get =text
  $ readLine("Enter name") =name
</pre>




<h1>Searching files / report()</h1>
<p>
  To search files, we usually use the Grep object. It takes a list of alternatives to look for,
  and can optionally be instructed with patterns to reject. It has a .file(File) function that
  runs the search on a file, and returns a list of lines that meet the requirements.
</p>

<p>
  But the lines returned from "Grep.file()" are not
  just strings, they are extended strings, of a type called "FileLine", which contains
  two additional additional functions, ".file()" to get the
  file object and ".lineNumber()" which returns the line number in that file.
</p>

<p>
  The File.read() function also produces a list of FileLine, rather than regular string
  values.
</p>




<h2>report()</h2>
<p>
  We already know that iterative loops can generate output using out(), but there is a second way,
  which is the report() statement. It can take one or more parameters, and results in a list of strings that
  are formatted into columns, for readability.
</p>
<p>
  The formatted text is added to the same list of output as data via out(), but only after the 
  loop space has completed. This means that the formatted output from report() is data (strings),
  just like values from out().
</p>


<h2>Multi-line example</h2>
<p>
  Below we will show a multi-line example function, which we create editing the savefile,
  that asks the user for a search text, then searches
  some directory for all source files (java), and look for the pattern in each. The result is presented
  in readable format, using report()
</p>

<pre>
  Dir("/home/user/project1")
  /ProjectDir

  Input("Enter search term").get =st
  Grep(st) =grep
  ProjectDir.allFiles-&gt;f
    assert(f.name.endsWith(".java"))
    grep.file(f)-&gt;line
      report(line.file.name, line.lineNumber, line)
  /Search
</pre>

<p>
  After adding the text to the script file using an editor, save it, then run Search in the 
  CFT terminal window.
</p>
<pre>
  $ Search
  Enter search term
  class
  &lt;List&gt;
   0: ProgramLine.java       | 11  | public class ProgramLine extends LexicalElement {
   1: StmtDebug.java         | 9   | public class StmtDebug extends Stmt {
   2: ExprIf.java            | 9   | public class ExprIf extends LexicalElement {
   3: LexicalElement.java    | 5   | public class LexicalElement {
        :
        :
</pre>





<h2>Grep - complex example</h2>
<pre>
  # Match lines containing "a" or "b", and that do not contain "c" or "d"
  Grep.match("a","b").reject("c","d")  

  # Match lines containing "a" AND "b"
  Grep.match("a").match("b")

  # Regular expressions - matching lines with 8 digits in sequence
  Grep.matchRegex("[0-9]{8}")
</pre>





<h2>Working with huge logs - counting hits</h2>
<p>
  The Grep instances are by default set up with a limit of the 1000 first matches. Passing
  that limit produces an error. The limit can be changed as follows:
</p>
<pre>
  $ Grep("...").limitFirst(100)
  $ Grep("...").limitLast(100)
</pre>


<h3>Counting hits</h3>
<p>
  When working with big files, one can also decide to initially do a count of hits,
  to narrow down the search terms before doing an actual search. 
</p>
<p>
  The following example shows a function for searching through a set of java files and
  counting the hits in each, summing these up, using Grep.fileCount() function instead
  of Grep.file(), which produces result lines.
</p>
<p>
  Counting hits is not subject to the limits above, as those exist in order to 
  avoid uncontrolled memory use.
</p>
<pre>
  Input("Enter search term").get =st
  Grep(st) =grep
  ProjectDir.allFiles-&gt;f
    assert(f.name.endsWith(".java"))
    grep.fileCount(f) =count
    out(count)
  | _.sum
  /SearchCount
</pre>


<h3>Limiting search to a few files</h3>
<p>
  When working with huge data sets, we can count the number of hits in each file. This
  could be presented as a sum, as above, or as a sorted list, displaying the number of hits
  per file.
</p>
<pre>
  Input("Enter search term").get =st
  Grep(st) =grep
  ProjectDir.allFiles-&gt;f
    assert(f.name.endsWith(".java"))
    grep.fileCount(f) =count
    out(Int(count,f))        # &lt;--- see section on "Generalized sorting"
  | _.sort-&gt;x
    report(x.data.name, x)
  /ShowHitCount
</pre>
<p>
  The next step is then to extend the regular search function, with an input for (part of)
  the file name(s) to search:
</p>
<pre>
  Input("Enter search term").get =st
  Grep(st) =grep
  Input("(Part of) file name").get =fn
  ProjectDir.allFiles-&gt;f
    assert(f.name.endsWith(".java"))
    assert(f.name.contains(fn))    # &lt;--- new
    grep.file(f)-&gt;line
      report(line.file.name, line.lineNumber, line)
  /Search
</pre>







<h1>Searching log files</h1>

<h2>Lib.LogFiles.DateSort</h2>
<p>
  Lines written to log files usually start with date and time. Further, actions that we want to
  trace may span several log files, for example when messages are sent between different services,
  each with its own log. To clearly trace such activity, we may search the individual log files for some text,
  and then sort all lines found on the date/time at the start of each line. 
</p>
<p>
  The Lib.LogFiles.DateSort function/object has been created for this purpose.
</p>

<pre>
  Input("Enter search term").get =st
  Lib.LogFiles.DateSort =dateSort
  Grep(st)=grep
  ProjectDir.allFiles-&gt;f
    assert(FileQualified(f))
    grep.file(f)-&gt;line 
      out(line)
  |
  =lines
  dateSort.asc(lines)-&gt;line
    report(line.file.name, line.lineNumber, line)
  /SearchLog
</pre>


<h3>DateSort.search()</h3>
<p>
  As of v1.1.3 DateSort has been extended with an advanced option for searching HUGE log files
  by date/time interval. It uses random access of start and end to identify if the file contains log lines
  within the range, and then binary search to locate where to start reading. There is also the option
  of supplying a Grep object, to filter lines within that time interval.
</p>
<pre>
  Lib.LogFiles.DateSort.search(file, fromTimeMillis, toTimeMillis, Grep?)
</pre>


<h2>Lib.LogFiles.FileReader(file)</h2>
<p>
  Processing big files, you can't use File.read(), as you will run out of memory.
</p>
<pre>
  Lib.LogFiles.FileReader(somefile) =reader
  loop
    reader.read=line
    break(line==null)
    ....
</pre>







<h1>Generalized sorting</h1>
<p>
  The List object has a function sort(), which does one of two things: 
</p>
<ol>
  <li>if the list contains only numbers (int or float or a mix), sorts them by number value</li>
  <li>... otherwise, sort as strings</li>
</ol>
<p>
  The result is a new list. To sort in reverse order, we just apply the function ".reverse()" 
  on the finished list.
</p>
<p>
  The trick to sorting is to <em>make all types of objects to be sorted into a number or a string</em>.
</p>
<p>
  This is done by three wrapper functions called "Int()", "Float()" and "Str()". They create objects that
  are subclasses of the regular int, float and
  string types, but also contain a "data" member that can be extracted after sorting, via the ".data()"
  function.
</p>

<h2>Example: file size</h2>
<p>
  Let's sort the files in the current directory so that the biggest files are listed first.
</p>
<pre>
  $ Dir.files-&gt;f out(Int(f.length,f)) | _.sort.reverse-&gt;x out(x.data)
</pre>

<p>
  For each file, we output an Int wrapper object, with value set to file length, and data
  pointing to the file. The resulting list is sorted, reversed, then iterated to output
  the data values, which are the original File object. 
</p>

<p>
  Could also sort on time, as File.lastModified is another int value, with CFT int values
  corresponding to long in Java.
</p>

<h2>Example: file name</h2>
<p>
  To sort on file names, we use the Str() wrapper function / object.
</p>
<pre>
  $ Dir.files-&gt;f out(Str(f.name,f)) | _.sort-&gt; out(x.data)
</pre>



<h1>Dictionary objects / Dict()</h1>
<p>
  When working with multiple projects, or sources of log files, we want to quickly flip
  between directories, file types and perhaps other settings. This is done using dictionary
  objects. 
</p>
<p>
  Dictionary objects are key-value stored, like Map in Java.
</p>
<p>
  Maintaining these types structures is best done when editing the script file with an editor.
</p>
<pre>
  Dict
    .set("dir",Dir("/home/user/project1"))
    .set("types","java txt".split)
  /Project1

  Dict
    .set("dir",Dir("/home/user/project2"))
    .set("types","js css html".split)
  /Project2

  Project1
  /CurrProject
</pre>

<p>
  Now we can build code that searches files and performs other operations on CurrProject. 
</p>
<p>
  Switching between projects is done by redefining the CurrProject function. 
<pre>
  $ Project2
  $ /CurrProject!
</pre>

<p>
  To get a named value from a Dict object, use the get(name) function.
</p>

<pre>
  $ Dict.set("a",23).get("a")
  &lt;int&gt;
  23
</pre>




<h1>Date and time processing</h1>

<h2>Milliseconds</h2>
<p>
  If we want to produce a list of files modified within the last 30 minutes, we can do this
  easily, using the global function currentTimeMillis, and the File.lastModified function.
</p>
<pre>
  Dir.files-&gt;f assert(currentTimeMillis-f.lastModified&gt;30*60*1000) out(f)
  /FilesModifiedLast30Minutes
</pre>

<h2>The Date object</h2>
<p>
  The Date() function can be invoked without parameters, producing a Date object that represents
  current date and time, or it can be called with an int value, which is milliseconds, such as 
  that returned from File.lastModified. Functions exist to decide if a date is before or after 
  another date, as well as for accessing individual properties, such as year, day of month, and so
  on.
</p>

<p>
  To list all files that were changed between two date/times now becomes easy
</p>

<pre>
  P(1,Date)=fromDate
  P(2,Date)=toDate
    Dir.files-&gt;f
      Date(f.lastModified) =fileDate
      assert(fileDate.after(fromDate) && fileDate.before(toDate))
      out(f)
  /FilesBetweenDates
</pre>



<h2>The Date.Duration object</h2>
<p>
  The Date object in turn contains a function Duration() which creates a Date.Duration object. This
  is both output from Date.diff, which calculates the amount of time between two dates, and used 
  as input to the Date.add and Date.sub functions, which are used to calculate other dates. 
</p>

<p>
  Example: calculating the date (and time) 300 days ago
</p>
<pre>
  $ Date.Duration.days(300) =x Date.sub(x)
</pre>





<h1>Session persistent data / ValDef / Val</h1>
<p>
  When working interactively with large sets of data, we have the option of saving those
  data into a session persistent data store. Two global functions let us define
  a named value, and access it.
</p>
<pre>
  $ ValDef("a",12)
  $ Val("a")
  &lt;int&gt;
  12
</pre>

<p>
  Being tied to the session, these data are lost when quitting CFT.
</p>







<h1>Synthesis</h1>

<h2>The problem</h2>

<p>
  If we use "cd" and "ls" to move
  to a directory, and want to create a function that works on files or subdirectories under
  that location, we have to take care.
</p>

<p>
  The issue is that we can not just say
</p>
<pre>
  Dir.allFiles-&gt;f ...
</pre>
<p>
  ... because the Dir() function returns the current directory, which may change. 
</p>


<h2>Creating code from values</h2>
<p>
  This is where the <i>syntesis</i> functionality comes in. The most often used variant takes
  the form of two "colon commands". 
</p>
<ol>
  <li>The :syn command syntesizes code from the last result.</li>
  <li>The :NN  (where NN is an integer) syntesizes the indicated element of the last result list. If 
  last result is not a list, an error is reported.</li>
</ol>


<h2>Example using :syn</h2>

<pre>
  $ cd ..
    # /home/roar
    &lt;obj: Dir&gt;
    roar/ d:61 f:33 
  $ cd project1
    # /home/roar/project1
    &lt;obj: Dir&gt;
    project1/ d:0 f:0 
  $ :syn
  synthesize ok
  +-----------------------------------------------------
  | .  : Dir("/home/roar/project1")
  +-----------------------------------------------------
  Assign to name by /xxx as usual

  $ /DirProject1
</pre>

<p>
  When we use "cd" to change to a directory, it returns a Dir object. The shell remembers the last
  result value, and the ":syn" attempts to create code representing that value in as direct a way as 
  possible. If this succeeds, it inserts the generated code line tino the "code history", as the 
  last command, which means it can now be assigned a name, for example "DirProject"
</p>

<p>
  Calling function "DirProject" will now always generate a Dir object pointing to the same
  directory, and is no longer dependening on current directory.
</p>

<h2>Example using :NN</h2>

<p>
  To synthesize a single element when the last result was a list, use :NN, as follows
</p>

<pre>
  $ ls
  &lt;List&gt;
   0: runtime/              | d:2 | f:12
   1: CallScriptFunc.java   | 1k  | 1398  |             | 2020-02-28 22:38:09
   2: CodeHistory.java      | 10k | 10980 | 2d_22:23:24 | 2020-06-07 12:57:49
   3: CommandProcessor.java | 0k  | 365   |             | 2020-02-28 22:38:09

  $ :2
  synthesize ok
  +-----------------------------------------------------
  | .  : File("/home/roar/Prosjekter/Java/ConfigTool/src/rf/configtool/main/CodeHistory.java")
  +-----------------------------------------------------
  Assign to name by /xxx as usual  
</pre>

<p>
  If the last value was not a list, the ":NN" command will fail with an error.
</p>



<h1>Repeat last program line</h1>
<p>
  The last program line entered (not colon commands or function name assignment) can be
  repeated by entering "." (dot), then possibly be followed by additional code.
</p>

<p>
  As the synthesize functions create a new code line, they then insert it into the history as
  the last command, which means it can be assigned a name by "/name", but also that it can
  be immediately run using the dot command, and extended on the fly, for example like this.
</p>
<pre>
  $ ls
  &lt;List&gt;
   0: runtime/              | d:2 | f:12
   1: CallScriptFunc.java   | 1k  | 1398  |             | 2020-02-28 22:38:09
   2: CodeHistory.java      | 10k | 10980 | 2d_22:23:24 | 2020-06-07 12:57:49
   3: CommandProcessor.java | 0k  | 365   |             | 2020-02-28 22:38:09

  $ :2
  synthesize ok
  +-----------------------------------------------------
  | .  : File("/home/roar/Prosjekter/Java/ConfigTool/src/rf/configtool/main/CodeHistory.java")
  +-----------------------------------------------------
  Assign to name by /xxx as usual  

  $ ..more
</pre>
<p>
  Here the first dot is the File("...") code line that was synthesized, then ".more" calls
  the more() function on the File object.
</p>





<h1>Output format / Cfg</h1>
<p>
  Output to screen is regulated via a Cfg object. It is a session object, that contains default
  settings for number of lines and line width of the current window / terminal. It's default
  mode of operation is to disable wrapping, which means long lines are cut, ending with a simple '+'
  to indicate this.
</p>
<p>
  To change the current size of the terminal window, we may use global function Cfg() to obtain
  the Cfg object, and methods to set or view the properties.
</p>



<h2>The @term shortcut</h2>
<p>
  After the introduction of short cuts, the easiest way to set the terminal window width and
  height, is to enter
</p>
<pre>
  $ @term
</pre>

<p>
  This works on Linux (using stty command) and on Windows (powershell). 
</p>



<h2>Line wrapping</h2>
<p>
  By default, ouput line wrapping is off, which means that lines longer than the Cfg.w gets truncated
  with a '+' to indicate there is more. It can be switched on/off via the Cfg object, but there is also a
  colon command ":wrap" which toggles wrapping on or off.
</p>








<h1>Templating</h1>
<p>
  CFT has multiple mechanisms that can be used to produce configuration files, as well
  as automated generation of code, from shell scripts to any higher level language,
  autogenerated email text, etc.
</p>



<h2>Merging text with Dict</h2>
<p>
  To merge values into a template, we use a dictionary object (Dict) combined with the
  merge() function of strings. This replaces occurrences of names in the dictionary
  with their values (as strings).
</p>
<pre>
  $ Dict.set("name","Julius")
  $ /data
  $ "Dear name".merge(data)
  &lt;String&gt;
  Dear Julius 
</pre>

<p>
  The merge is based on a direct match. Often we like to mark our merge codes. The Dict
  object has a function, ".mergeCodes()", which returns a new Dict object, where all names of fields
  are rewritten into ${name}. Changing the template correspondingly, this eliminates the risk of 
  accidentally matching text not meant as merge codes.
</p>
<pre>
  $ Dict.set("name","Julius").mergeCodes
  $ /data
  $ "Dear ${name}".merge(data)
  &lt;String&gt;
  Dear Julius 
</pre>



<h2>Using individual template files</h2>
<p>
  The simplest way to create template text, is to enter it into a text file, which CFT
  then reads and processes. The File.read() function returns a list of lines from the
  file, which we then iterate over and apply the merge data.
</p>
<pre>
  File("myTemplate.txt")
  /templateFile

  P(1,Dict)=data
  templateFile.read-&gt;line
    out(line.merge(data))
  /generate
</pre>



<h2>Script file "here" documents</h2>
<p>
  The second easiest way of creating lines of text for processing with merge codes, apart from
  editing a separate file, is to use a special feature of the script files, called
  "here" documents. The syntax is picked up when reading the savefile, and the lines
  of text are converted into code on the fly, becoming a List object.
</p>
<pre>
  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Identifier
  This is
  some text
  &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Identifier
  /myTemplate
</pre>
 <p>
  Calling the myTemplate function from the interactive shell, produces the following result
</p>
<pre>
  $ myTemplate
  &lt;List&gt;
  0: This is
  1: some text
</pre>
<p>
  There needs to be at least three of the '&lt;' or '&gt;' followed by space and an identifier.
</p>

<h3>A more complex example</h3>
<pre>
  P(1,"a")=a
  P(2,"b")=b
  Dict
    .set("a",a)
    .set("b",b)
    .mergeCodes
  =data
  &lt;&lt;&lt; SomeMarker
  Value of a: ${a}
  Value of b: ${b}
  &gt;&gt;&gt; SomeMarker
  -&gt;line 
    out(line.merge(data))
  /myMergedTemplate
</pre>





<h2>Using DataFile</h2>
<p>
  Another mechanism for templating, particularly if the text blocks are big, is the 
  DataFile function and object, which processes
  a single text file which can contain numerous individual templates. 
</p>
<p>
  The different templates are separated by a user defined selector string, and given names, 
  by which they are accessed from code.
</p>
<p>
  Example data file 'data.txt'
</p>
<pre>
  ### A

  This is
  template A
  
  ### B
  
  This is 
  template B
</pre>
<p>
  The code to use this file consists of creating the DataFile object, passing the separator
  string as a parameter, then accessing the individual templates.
</p>
<pre>
  $ DataFile(File("data.txt"),"###")
  $Â /df

  $ df.get("A")
  &lt;List&gt;
  This is
  template A
</pre>

<h3>Include blank lines</h3>
<p>
  The function DataFile.get() returns only non-blank lines. To get all lines, use function getAll().
</p>

<h3>Filter away comments</h3>
<p>
  Also, DataFile has support for comments in the template text, which can be automatically
  removed. They are defined by another prefix string as follows:
</p>
<pre>
  $ DataFile(someFile,"###").comment("//")
  $ /df
</pre>
<p>
  Now all lines starting with "//" are automatically stripped from any output.
</p>





<h2>PDict()</h2>
<p>
  With many parameters to be merged into the template text, the special expression PDict() saves
  us some writing. It takes a comma-separated list of value names, which are mapped to 
  parameter values by position, creating a Dict object. 
</p>
<p>
  For missing parameters, the value null is stored in the Dict.
</p>
<p>
  The String.merge() function logic replaces value null for a merge field with empty string.
</p>
<pre>
  PDict("a","b").mergeCodes =data
  &lt;&lt;&lt; SomeMarker
  Value of a: ${a}
  Value of b: ${b}
  &gt;&gt;&gt; SomeMarker
  -&gt;line 
    out(line.merge(data))
  /myMergedTemplate
</pre>
<p>
  If missing parameters is a problem, use the Dict.hasNullValue() function, which returns true
  if one or more values of the Dict is null.
</p>
<pre>
  PDict("a","b").mergeCodes =data
  error(data.hasNullValue,"Expected parameters a,b")
</pre>  







<h1>Use as a calculator</h1>


<h2>Expressions and "variables"</h2>
<p>
  Having a running instance of CFT on the desktop means access to a capable calculator.
</p>
<pre>
  $ 24*60*60
  &lt;int&gt;
  86400
  /x

  x*365
  &lt;int&gt;
  31536000
</pre>
<p>
  As noted before, the symbol "x" does not refer to the value 86400, but to the code that 
  generates the value.
</p>



<h2>Lib.Math</h2>
<p>
  The global function Lib() creates a Lib object, which in turn contains functions that
  create other objects, such as the Math object, which contains trigonometric functions.
</p>



<h2>Lib.Convert</h2>
<p>
  The Lib.Convert function returns another object, which contains code for lots of common
  conversions. Use the help system to show all options.
</p>
<pre>
  $ Lib.Convert help
</pre>



<h2>Lib.Plot</h2>
<p>
  The Lib.Plot function returns an object with functions for creating a primitive plot, for
  visualizing data. Again, use the help system to examine options.
</p>
<p>
  Note that Lib.Plot is a quick-and-dirty implementation. For better graphs, some external
  package should be invoked.
</p>
<pre>
  File("/tmp/" + currentTimeMillis+".txt")
  /tmpFile

  
  tmpFile =f
  Lib.Data.each(0,720)-&gt;i
    f.append(""+Lib.Math.sin(i) + "," + Lib.Math.cos(i))
  |
  Lib.Plot.typeTimeline.readCSVFile(f).plot(File("out.png"))
  f.delete
  /DemoPlot
</pre>
<p>
  The above code generates an example plot as a png file in the current directory.
</p>











<h1>Various topics</h1>
<p>
  In no particular order
</p>



<h2>Command line args</h2>
<p>
  If CFT is invoked with command line arguments, the first is the name of the script,
  that is, a savefile minus the "savefile" prefix and ".txt" ending.
</p>
<p>
 Then follows zero
  or more command lines, on string format. For values containing space or otherwise 
  have meaning to the shell, use quotes. Example:
</p>
<pre>
  ./cft Projects Curr
</pre>
<p>
  This loads script Projects, then calls the Curr function inside.
</p>






<h2>Calling functions in external scripts</h2>
<p>
  Sometimes we want to call a useful function in another script file. This is
  implemented with the "call" expression below.
</p>
<pre>
  call "Script:Function" (....)
</pre>
<p>
  Parameters are given as a list of values inside ()'s and may be omitted if no parameters.
</p>




<h2>Protecting directories and files</h2>
<p>
  In order to avoid accidental delete or modifications, both Dir and File have
  a function .protect() which takes an optional description string,  and 
  which attaches a protection status to that object.
</p>
<p>
  Any Dir and File objects created from such an object, inherit the protection status.
</p>
<pre>
  Dir("src").protect("Source")
  /dirSrc
</pre>

<p>
  Invalid operations result in an error, where the operation is described, along with the
  protection code (String).
</p>

<p>
  All source directories when searching should be protected, as well as log directories, if originals
  matter.
</p>


<h3>A protected directory does not allow</h3>

<ul>
<li>create</li>
<li>delete</li>
<li>copy file into dir - includes blocking File.uncompress when target dir is protected</li>
</ul>


<h3>A protected file does not allow</h3>
<ul>
  <li>delete</li>
  <li>create</li>
  <li>append</li>
  <li>copyFrom (target)</li>
  <li>copyTo</li>
  <li>move (source or target)</li>
</ul>






<h2>Working with pasted text lines from stdin</h2>
<p>
  If you've got some text in the copy-paste buffer that you want to work with, the 
  readLines() global functions can be used. It takes one parameter, which is an end-marker, which must 
  occur alone on a line, to mark the end.
</p>
<p>
  The readLines() function returns a list of strings, which you can turn into code and save under
  some function name, using synthesis.
</p>
<pre>
  readLines("XXX")
  (paste or enter text, then enter end-marker manually)
  XXX
  &lgt;list&gt;
  0: ...
  1: ...

  :syn
  /someName
  
  ...
</pre>






<h2>Differing between Windows and Linux</h2>
<p>
  Calling function Sys.isWindows() is used to differ between the two in code. It does this
  by checking if File.separator is a backslash.
</p>
<pre>
  Sys.isWindows
  &lt;boolean&gt;
  false
</pre>





<h2>Session state</h2>

<p>
  The session state is where previous values to Input() are stored, as well as values
  stored with ValDef(). When invoking some function in another script, that code runs in
  a separate environment ("ObjGlobal"), so as to avoid cross-contamination.
</p>
<p>
  Further, the separate environments for all external scripts invoked, are cached, so that
  each call to a function in the same script, is run within the same environment.
</p>
<p>
  This lets individual scripts have persistent session state, that is remembered between
  calls, which means Input() remembers what you typed in last time, etc.
</p>





<h2>Predicate calls</h2>
<p>
  Example: to decide if a string is an integer, without
  resorting to either creating a built-in predicate function like .isInt, or even
  using regular expression matching, there is the <em>predicate call</em> functionality,
  where one calls a function in a special way, resulting in a boolean value that tells
  if the call was ok or not.
</p>
<p>
  All dotted calls are made into predicate calls, by adding a '?' questionmark between the dot 
  and the function name. 
<pre>
  "sdf".?parseInt
  &lt;boolean&gt;
  false

  "123".?parseInt
  &lt;boolean&gt;
  true
</pre>





<h2>List.push()</h2>
<p>
  The push() function of the List object pushes a number of value from the list onto the stack
  to be assigned in "logical" order, and allows us to supply a default value if list too short.
</p>
<pre>
  $ List("x","y").split.push(3,"*") =a =b =c a+":"+b+":"+c
  &lt;String&gt;
  x:y:*
</pre>




<h2>Dict set strings</h2>
<p>
  Reading name-value assignments from a property file or similar, is best done via the .setStr()
  function on the Dict object. It strips whitespace and accepts both colon and '='.
</p>
<pre>
  Dict.setStr("a : b")
  /d
  d.get("a")
  &lt;String&gt;
  b
</pre>
<p>
  To process a property file, assuming commented lines start with '#', we can do 
  this:
</p>
<pre>
  P(1) =propFile
    Dict =d
    propFile.read-&gt;line
      reject(line.trim.startsWith("#"))
      assert(line.contains(":") || line.contains("="))
      d.setStr(line)
    |
    d
  /GetProps
</pre>





<h2>Dict fields as functions</h2>
<p>
  For readability, values with names that are valid identifiers, and don't collide with regular 
  member functions, can be referenced via dotted notation, for increased readability.
</p>
<pre>
  Dict.set("a","b")
  /d
  d.a
  &lt;String&gt;
  b
</pre>  




<h2>Dict.get with default value</h2>
<p>
  The Dict.get() method takes an optional default-value which is returned if no value
  associated with the name, but in that case the default value is <em>also stored</em> in the
  dictionary. 
</p>
<p>
  Usually this makes sense only for session objects.
</p>
<pre>
  ValDef("data",Dict)
  Val("data").get("a",3)
  &lt;int&gt;
  3

  Val("data").keys
  &lt;List&gt;
  0: a
</pre>




<h2>List.nth() negative indexes</h2>
<p>
  Using negative indexes to List.nth() counts from the end of the list. Using value -1 returns the
  last element, -2 the second last, and so on.
</p>
<pre>
  List(1,2,3,4).nth(-1)
  &lt;int&gt;
  
</pre>




<h2>Function parameters as List or Dict</h2>

<p>
  In addition to grabbing one parameter at a time, using P(pos), we can also process the
  parameter values as a list and as a dictionary.
</p>

<p>
  The function parameter expression P() when used with no parameters, returns a list of
  the parameter values as passed to the function.
</p>

<p>
  The PDict() expression takes a sequence of names to be mapped to parameters by position,
  resulting in a Dict object. Missing values lead to the special value null being stored
  in the dictionary.
</p>





<h2>The general loop statement</h2>
<p>
  In addition to looping over lists, there is a general loop construct. It identifies no
  loop variable, and loops forever, until break() is called. It also obeys assert()
  and reject() as with list iteration. 
</p>
<pre>
  0=a loop break(a&gt;3) out(a) a+1 =a
  &lt;List&gt;
  0
  1
  2
  3
</pre>
<p>
  If you forget to increment the variable a, or forget or create an invalid break(), then
  the loop may never terminate, and CFT has to be killed with ^C
</p>




<h2>Storing CFT data structures to file - syn() and eval()</h2>
<p>
  Session persistent data are stored and retrieved with ValDef() and Val(), but are obviously
  lost when the session ends.
<p>
  A more persistent solution is to store a data structure to file. This is done using
  the synthesis functionality, which is made available as a global function as well as the
  "colon command" used before. This means we can write huge lists and sets of files and
  directory objects to file, and restore it later, without going through possibly time
  consuming computations.
</p>
<p>
  To restore the structure, we use the global eval() function.

<pre>

  P(1)=file
  P(2,"data") =data
    file.create(syn(data))
  /saveData

  P(1)=file
  eval(file.read.nth)
  /restoreData
</pre>
<p>
  This can be used to save arbitrarily big structures, as long as they are synthesizable.
</p>




<h2>String .esc() and .unEsc()</h2>
<p>
  As was mentioned initially, CFT doesn't use backslash as an escape character. 
  However, we still require a way of converting "difficult" strings to code,
  via synthesis. For this purpose, the two functions String.esc() and String.unEsc() was
  created.
</p>
<p>
  One rarely needs to call these manually, but they are worth mentioning, as sometimes synthesis
  of a string may result in code such as this:
</p>
<pre>
  "^q^aa^a^q".unEsc
</pre>



<h3>Escape codes</h3>
<p>
  For an escaped string, the escape character is the ^ symbol.
</p>
<ul>
  <li>"Double quotes" ^q</li>
  <li>'Single quotes' / Apostrophe ^a</li>
  <li>Newline ^n</li>
  <li>Carriage Return ^r</li>
  <li>Tab ^t</li>
  <li>The ^ symbol ^^</li>
</ul>
<p>
  To gives a way of creating strings with newlines inside.
</p>
<pre>
  "this^nis^na test".unEsc

  &lt;String&gt;
  this
  is
  a test 
</pre>



<h2>Automating interactive functions / Sys.stdin()</h2>
<p>
  Functions may query the user with Input("prompt").get and readLine("prompt"). If we want
  to automate such functions, we use function Sys.stdin() to buffer up any number of 
  input lines. 
</p>
<pre>
  Sys.stdin("read-this") Input("Enter data").get
  &lt;String&gt;
  read-this
</pre>
<p>
  Note that both Input.get() and readLine() detect if there is buffered input, and
  if so, do not display the prompt or other info. Particularly useful for Input.get(),
  since buffering the empty string "" with Sys.stdin() means repeating the last value.
</p>




<h2>Running colon commands from script code</h2>
<p>
  Using the Sys.stdin() statement without being followed by Input.get() or readLine(), is just 
  another way of entering commands. This means colon commands are available from CFT code.
</p>
<pre>
  stdin("2+3")
  &lt;int&gt;
  5
</pre>
<p>
  This can be exploited to let a script modify itself, by redefining
  functions, although that will be troublesome if those functions read input. A better
  use is that of running colon commands, particularly loading scripts. This is used
  frequently with shortcuts.
</p>
<pre>
  stdin(":load SomeScript","?")
</pre>






<h2>Simple line editing</h2>
<p>
  When using CFT mainly in interactive mode, a primitive line editor can be used to modify
  the code of an existing function, by optionally cutting off text following a pattern, as well
  as optionally adding text. 
</p>
<p>
  The syntax is as follows
</p>
<pre>
  $ !x!       # inserts code from function x as text, then executes it
  $ !x! txt   # inserts code from function x, followed by " txt", then executes it
  $ !x:p!     # inserts code from function x up to but not including pattern 'p'
  $ !x:p! txt
</pre>

<h3>Develop complex code in steps</h3>
<pre>
  $ Dir.files
  $ /x
  $ !x!-&gt;f out(f)
  $ /x!
  $ !x:out!assert(f.name.endsWith(".txt")) out(f)
  $ /x!
</pre>

<p>
  Note: this only applies to single-line functions.
</p>




<h2>Macros</h2>
<p>
  In addition to block expressions that are executed immediately, there is the option of creating
  "independent" block expressions, which are not executed immediately, but instead return
  an object of type Macro.
</p>
<p>
  A macro is like a regular function, except it is also a value, which means it can be stored
  in Dict objects, lists and sent as parameters, etc.
</p>
<p>
  A macro is written in the same way as a block expression, just that the body starts with 
  a single asterisk (*), indicating
  that the code can run anywhere, as it will always run in an isolated context, like functions, not
  seeing any state of the caller, which block expressions naturally do. 
</p>
<p>
  To call a Macro, invoke its .call() function, with parameters as needed, which are
  picked up inside the code in the same way as in functions.
</p>

<h3>Simple example</h3>
<p>
  Simple example, using a macro to save typing.
</p>
<pre>
  {* P(1)=name Dict.set("name",name)} =m
  List(
    m.call("x"), m.call("y")
  )
</pre>
<p>
  See savefileLib.txt for examples of macros used to implement generic
  menu system, as applied to select editor for Linux.
</p>





<h2>CFT.props - mCat, mEdit and mMore macros</h2>
<p>
  The configuration fields mCat, mEdit and mMore ("m" for macro) define macros
  that are called for interactive commands cat/edit/more. This means it is possible
  to redefine what edit means. Currently, mEdit calls either "Lib:e" if there is a
  file, otherwise "Lib:e2" which presents a history of documents edited. The
  mMore macro calls "Lib:m", while the mCat macro just calls .read on file parameter.
</p>





<h2>CFT.props - shortcuts</h2>
<p>
  The CFT.props text is self explanatory.
</p>
<pre>
# Shortcuts
#
# The shortcuts are lines of code. If that code results in a macro, it is invoked with
# no parameters. Since we don't need parameters, there is really no need for macros
# here. The return value from a shortcut becomes the "last value", available
# via Sys.lastResult, as well as used by :syn etc
#
# Note that shortcuts only work when the prefix is at the start of the interactive
# input line. 
# ---
shortcutPrefix = @

shortcut:r = Sys.stdin(":load Release","?")
shortcut:p = Sys.stdin(":load Projects","?")

# List available shortcuts when typing '@' only
# ---
shortcut: = File("CFT.props").read-gt;line assert(line.contains("shortcut:")) out(line)
</pre>
<p>
  This means that typing @r loads the Release script, then executes the '?' command, which
  lists its content.
</p>





<h1>Various example code</h1>

<h2>Windows PowerShell</h2>
<p>
  The following code is an effective way of using PowerShell from CFT, saving lots of typing.
</p>
<pre>
  P(1)=host P(2)=cmd ## Run remote PowerShell script-block 
    List("powershell","invoke-command","-computername",host,"-scriptblock","{" + cmd + "}") =fullCmd
    Dir.run(fullCmd)
  /PSRun

  # List services via PowerShell (interactive)
    Input("Host").get =host
    Input("Service name (including wildcards)").get =service
    "get-service -name " + service =cmd  # no splitting
    PSRun(host, cmd)
  /PSGetServ

</pre>


<h2>Windows CMD</h2>
<p>
  Running commands using CMD in windows, mostly requires the "/c" flag.
</p>
<pre>
  Dir("...")
  /DirProject

  # Add, commit and push with git
    DirProject.run("cmd","/c","git","add",".")
    Input("Commit message").get =msg
    DirProject.run("cmd","/c","git","commit","-m",msg)
    DirProject.run("cmd","/c","git","push","origin","master")
  /GitPush
</pre>


<h2>Linux get user name</h2>
<pre>
  Dir.runCapture("whoami").nth
  /GetUser
</pre>



<h1>Reference: Colon commands</h1>
<p>
  Colon commands are best described by entering a single colon at the CFT prompt.
</p>

<pre>
$ :

Colon commands
--------------
:save [ident]?           - save script
:load [ident]?           - load script
:new                     - create new empty script
:sw [ident]?             - switch between loaded scripts
:delete ident [, ident]* - delete function(s)
:copy ident ident        - copy function
:wrap                    - line wrap on/off
:debug                   - enter or leave debug mode
:syn                     - synthesize last result
:&lt;int&gt;                   - synthesize a row from last result (must be list)
:quit                    - terminate CFT

</pre>
<p>
  Confusing colon commands with shortcuts? You're not alone.
</p>
<p>
  Colon commands exist outside the language, and are fixed (written in Java), while shortcuts run CFT program
  code, and are defined in the CFT.props file. So far all good.
</p>
<p>
  The "problem" is that CFT code (and so shortcuts) can run colon commands via "abusing" the Sys.stdin() command.
</p>





<h1>Reference: Synthesizable types</h1>
<ul>
  <li>boolean</li>
  <li>int</li>
  <li>float</li>
  <li>string</li>
  <li>null</li>
  <li>List</li>
  <li>Dir</li>
  <li>File</li>
  <li>FileLine</li>
  <li>Date</li>
  <li>Date.Duration</li>
  <li>Int</li>
  <li>Float</li>
  <li>Str</li>
  <li>Dict</li>
  <li>Glob</li>
  <li>Regex</li>
</ul>






<h1>Fun and strange stuff</h1>



<h2>Why Input("label").get?</h2>
<p>
  Why can't the Input() function just ask the user for input? Why the .get()?
</p>
<p>
  This is because it was envisioned more functions on the Input object, such as 
  programming it to reset its remembered values, or get values from other sources.
</p>
<p>
  This never came to fruition, and with Input() being a pretty old function, Input("xxx") remains an object, with a single .get() function inside.
</p>
<p>
  At least it leaves us with the option of adding clever stuff later.
</p>

<h2>Block expressions are strange</h2>
<p>
  The block expressions do not resemble code blocks in Java, because in reality they are automatically
  executing macros, with scope extending out to the calling environment. Macros and block expressions were
  an afterthought, something created because it was possible. There was no real need, and in the first versions
  of the doc, there were some really odd examples of what these could be used for.
</p>
<p>
  The good thing about being separate contexts is that you can do loops and pipes and stuff. The bad thing
  is that you can not break loops in the caller. This is okay, as assert() and reject() with boolean 
  expressions are really old constructs since v0.0.1 if there were such a thing.
</p>
<p>
  The only real need for block expressions initially, was that of conditionally assigning values to variables
  in a more elegant way than the if-expression.
</p>
<pre>
  if (addOne, value+1, value) =value
</pre>

<h2>Function name AFTER code?</h2>
<pre>
  Dir.files
  /showFiles
</pre>
<p>
  This stems back to the time of entering code line by line. Having to decide the name of a function before
  seeing how much functionality you got crammed into one line, made little sense. Instead you write some code
  that does something useful, then decides what to call it.
</p>
<p>
  Also there is the issue of not assigning a name until you have a code line that <em>works</em>. 
</p>
<p>
  This might at some point be changed, at least for script files, as it still feels backward, but this 
  is why.
</p>
<p>
  The syntax with the slash and an identifier was inspired by PostScript.
</p>


<h2>Stack-based assignment?</h2>
<p>
  Why let assignment be the opposite of what everybody is used to?
</p>
<pre>
  4 =value
</pre>
<p>
  Primarily because it was a bit easier to implement. The syntax of CFT is made so that parsing it only
  requires a lookahead of one token. 
</p>
<p>
  The actual changes required to support normal assignment turned out not to be too hard, only 
  extending the lookahead by one. However, the script code base has prohibited the change.
</p>
<p>
  An attempt was made to allow both, but this failed. To do this, we would have to use a different
  assignment token for each form, say "=" and ":=", which would just be confusing.</p>
<p>
  Besides, the postfix assignment has grown on me, for the same reason as why function name follows AFTER
  the function code: one types code, and at some point decide that for readability, it's time
  to assign a local variable, which is then used on the next lines. Almost like punctuation when
  writing prose.
</p>
<p>
  Deciding the variable name beforehand restricts how you write code. I see that frequently
  when programming java. One starts declaring a variable followed by an expression, which turns
  out more complex than you thought, and you end up going back to change the variable name, making the
  expression simpler, by breaking it into parts. 
</p>
<p>
  Also note that there are no global variables (*) in CFT, only local helpers inside functions/macros, so
  all variable assignments come about in this way.
</p>
<p>
   (*) Session values are of course global variables, but they
  are defined and accessed using very different syntax, to emphasize how they are 
  not meant as "helpers" in expressions. 
</p>



<h2>Using Sys.stdin to run colon commands etc</h2>
<p>
  That functionality an example of an "unexpected feature", as the Sys.stdin() was created to automate functions that used
  Input and readLine(). There was a moment of confusion when discovering what happened to input lines not consumed
  by those interactive functions.
</p>
<p>
   Fun, right? :-)
</p>




</body></html>
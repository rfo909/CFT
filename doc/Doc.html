<html>
<head>

<style type="text/css">
	* {font-family: arial}
	pre {font-family:courier; margin-left:1Em; padding-left: 1Em; font-size: 16pt}
	h1 {padding-top:1Em; color: blue}
</style>
</head>
<body>

<h1 style="padding-left:0; margin-left:0; font-size:24pt; font-family:monospace; color:black">
CFT / ConfigTool
</h1>

<pre style="padding-left:0; margin-left:0">

Last updated: 2021-09-29 RFO
v2.7.3


</pre>

<h1>Introduction</h1>

<p>
  <i>CFT is an interactive programmable environment for automation.</i>
</p>
<p>
  Automation is done by creating functions, which call each other, as well
  as a set of global functions, and member functions inside objects. All values
  are objects, with functions inside.
</p>
<p>
  A rich set of predefined objects exists, along with global functions to
  create them. An example is the global "Dir" function, which returns a 
  "Dir" object, with functions inside, such as .files, which returns list
  of files in the directory. Both the list and the files are objects.
</p>
<ul>
  <li>directory objects</li>
  <li>file objects</li>
  <li>lists</li>
  <li>dictionaries</li>
  <li>strings</li>
  <li>...</li>
</ul>
<p>
  CFT is tested on Linux and Windows, and easily integrates with external programs
  on both, such as PowerShell, git, ssh. It should run anywhere that supports Java.
</p>

<p>
  Development has been going on since May 2018, and on github since July 2020.
</p>



<h1>Platform</h1>
<p>
  CFT is written in Java. It has been tested on both Linux
  and Windows.
</p>




<h1>Functionality</h1>
<p>
  The CFT programming language is a glue between library functions and object functions, user input, and 
  running external programs.
</p>
<p>
  It is command line based, and can be programmed interactively, creating one-line functions, but 
  mostly we use editors for creating function code.
<p>
  The language is object oriented, with all values being objects. Here we call a
  function "bin()" inside an integer object. 
</p>
<pre>
  $ 1.bin
  &lt;String&gt;
  00000001
</pre>
<p>
  Parantheses are optional when no parameters.
</p>

<h2>Another example</h2>
<pre>
  $ Dir.files.length
  &lt;int&gt;
  12
</pre>
<ol>
  <li>The "Dir" global function returns the current directory as a Dir-object</li>
  <li>We call the "files" function in the directory object, it returns a list object</li>
  <li>We call the "length" function in the list object, it returns an int object</li>
</ol>

<h1>Getting help</h1>

<h2>Show all global functions</h2>
<pre>
  $ help
</pre>


<h1>Show functions inside value objects</h1>
<p>
  To show all functions inside an object, create an instance of that object followed by the word help. 
  Specifically, the help statement takes the value on top of the stack and lists it's available
  functions.
</p>
<pre>
  $ 1 help               # integer
  $ 3.14 help            # float
  $ "xxx" help           # string
  $ List help
  $ Dict help
  $ Dir help
  $ File("x.txt") help   # the file needs not exist
</pre>





<h1>Create functions</h1>
<p>
  Everything you type in at the prompt is considered code, and executed.
</p>
<p>
  Then, if you want, you can assign a name to the last line of code, and now you have a function.
</p>
<pre>
  $ Dir.files.length
  &lt;int&gt;
  12
  $ /filesInDir
</pre>
<p>
  The code line that gives us the number of files in the current directory is now named "filesInDir", and can
  be run again as follows:
</p>
<pre>
  $ filesInDir
  &lt;int&gt;
  12
</pre>
<h1>Show your functions</h1>
<p>
  List functions in current script
</p>
<pre>
  $ ?
</pre>
<p>
  To show the code of a function:
</p>
<pre>
  $ ? name
</pre>
<p>
  If the name doesn't match one function, it is used as a prefix to list a subset
  of all functions.
</p>










<h1>Save and load</h1>
<p>
  Functions are saved into script files, via "colon" commands, which are system commands outside
  the CFT language.
</p>
<pre>
  $ :save myscript
  $ :load otherscript
</pre>




<h1>Edit script file - shortcuts</h1>
<p>
  Instead of entering code via the command line, the script file can easily be opened in
  an editor. To do this, the current script must be saved, then enter the following:
</p>
<pre>
  $ @e
</pre>
<p>
  This opens the script in an editor. On linux you will be asked which editor you prefer.
  This is remembered within the session. To use a different editor, type @ee instead.
</p>
<p>
  After changing a script in the editor, and saving, CFT automatically detects the change, and
  reloads the script the next time you press ENTER.
</p>
<p>
  To list all shortcuts
</p>
<pre>
  $ @
</pre>
<p>
  The shortcut character can be changed in the CFT.props configuration file.
</p>


<h1>Shortcuts vs colon commands</h1>
<p>
  Shortcuts are ways of running code, while colon commands are system commands.
</p>
<p>
  View all colon commands:
</p>
<pre>
  $ :
</pre>

<p>
  View all shortcuts:
</p>
<pre>
  $ @
</pre>
<p>
  Shortcuts are defined in the CFT.props file.
</p>






<h1>CFT as a shell</h1>
<p>
  CFT contains a number of "shell like commands", with different syntax from the regular function calls.
</p>
<ul>
<li>ls</li>
<li>cd</li>
<li>cat</li>
<li>more</li>
<li>edit</li>
</ul>

<p>
	The syntax for these commands correspond to how they are used in Linux/Unix, with support for
 	globbing ("*.txt" etc). They are meant for easy navigation around the directory trees, and for
	inspecting files, with "cat", "more" and "edit".
</p>
<pre>
  $ pwd
  $ cd ..
  $ ls *.txt
</pre>

<p>
  The "ls" command comes in two additional versions:
</p>
<pre>
  $ lsf   # lists files
  $ lsd   # lists directories
</pre>


<h2>Paths with space</h2>
<p>
	To access directories of files with space in them, we use quotes, single or double.
</p>
<pre>
	cd "c:\program files"
</pre>


<h2>Windows backslash</h2>
<p>
	Note that backslash is NOT an escape character in CFT, so no need to escape it.
</p>
<pre>
	Dir("c:\program files\")
	/ProgramFilesDir
</pre>
<p>
	This of course goes interactively as well:
</p>
<pre>
	$ cd d:\logs
</pre>


<h2>Combine with CFT functions</h2>
<p>
	In addition to the above syntax, such as "cd /someDir/xyz" etc, these commands
	also support using output from any CFT function. Say we have some functions:
</p>
<pre>
	Dir("/SomePath/logs")
	/LogDir

	Dir("/SomewhereElse/xyz").file("data.txt")
	/DataFile
</pre>
<p>
	... then we can do this:
</p>
<pre>
	$ cd (LogDir)
	$ edit (DataFile)
</pre>



<h2>Destructive commands</h2>
<p>
  CFT <i>does not</i> include direct "shell-like" destructive commands ("rm", "cp", "mv", "mkdir" etc).
</p>
<p>
	This is by choice.
</p>
<p>
	Such functionality is of course available in CFT, but only as functions inside Dir and File objects.
</p>
<p>
	Alternatively one can use "bang commands" or the shell function.
</p>






<h1>The "protect" mechanism</h1>
<p>
  Performing changes, such as copying, deleting and creating files, is supposed to be scripted
  with code, so no "command line" style functionality exists for this. Alternatively one can use
  the "shell" command, or "bang" commands, which are sent to the shell.
</p>
<p>
  CFT has all the functionality needed to perform these operations, but the syntax becomes "program code" instead
  of just "cp" and "rm". Example of deleting all files in a directory.
</p>
<pre>
  $ &lt;DirExpression&gt;.file("xxx.txt").delete
</pre>
<p>
  The point here is that the "DirExpression" as well as functionality to provide sets of files
  and similar, are CFT code, and CFT has a special provision to avoid deleting or modifying the wrong 
  files or directories: <i>the "protect" mechanism</i>.
</p>
<p>
  Usually, when working with multiple files and directories, we will create functions that return
  Dir objects and File objects. The "protect" mechanism allows us to do the following:
</p>
<pre>
  $ Dir("/someNFSDir/logs").protect
  $ /LogDir
</pre>
<p>
  What this does is set an internal flag in the Dir object that the function creates, that prevents
  operations like deleting or modifying the directory.
</p>
<p>
  As we call LogDir.files, each File object created, also get the <em>protect</em> flag set. 
</p>
<pre>
  $ LogDir.file("log01.txt").delete
  ERROR: [input:18] INVALID-OP delete : /someNfsDir/logs/log01.txt (PROTECTED: -) (java.lang.Exception)
</pre>

<p>
	This both protect our script code from doing bad things, but also interactively. Say we
	also have another directory defined as a function:
</p>
<pre>
	Dir("/tmp/myTmp")
	/TmpDir
</pre>
<p>
	Testing the code, we may decide to delete the files in TmpDir.
</p>
<pre>
	TmpDir.files->f f.delete
</pre>
<p>
  	But what if, in a hurry, we entered LogDir instead of TmpDir. That's where the protect saves us.
</p>
<p>
	Had "rm" been implemented as shell-style command in CFT, we would instead have done the following:
</p>
<pre>
	$ cd (LogDir)
	$ rm *
	# Oh no!!
</pre>
<p>
	The "cp", "mv" and "rm" commands with globbing ("*") are not only powerful, but
	their usage pattern excludes CFT from knowing when trying to delete something
	that should not be deleted, etc.
</p>
	

<h1>Bang commands</h1>
<p>
  CFT supports a special syntax, where by starting a command line with "!", the following can
  directly run external commands, such as
</p>
<pre>
  $ !ps
  $ !git status
  $ !rm xxx.txt
  $ !top
</pre>

<p>
  For details of the default bang command parser:
</p>
<pre>
  $ BangParser:Readme
</pre>



<h1>The "shell" command</h1>
<p>
  One can also run the global "shell" command, perform changes, and then return via "exit":
</p>
<pre>
  $ shell
  roar@pc01$ rm xxx.txt
  roar@pc01$ exit
    # Running bash completed
  $
</pre>







<h1>Show content of file</h1>
<p>
  Now if we want to list content of file "TODO.txt", we can enter
</p>

<pre>
  $ cat TODO.txt
  $ more TODO.txt
</pre>

<h2>Open a file in editor</h2>
<pre>
  $ edit TODO.txt
</pre>






<h1>List basics</h1>
<p>
  Lists are return value from many functions, such as getting the files in a directory. 
</p>
<p>
  Lists can also be created 
  with the global List() function, which takes any number of parameters, and creates a List object
  from those values.
</p>
<pre>
  $ List                 # empty list
  $ List(1,2,3,4)
  $ Dir.files
  $ "abcdef".chars
  $ "one two three".split
  $ "one:two:three".split(":")
</pre>

<p>
  Many functions are available on a List object. One frequently used is "nth", which
  gets a specific element, defaulting to 0 if no argument.
</p>
<pre>
  $ List("a","b","c").nth
  &lt;String&gt;
  a
</pre>

<p>
  For details of available functions, use the help system:
</p>
<pre>
  $ List help
</pre>





<h1>Introduction to loops</h1>

<p>
  Loops in CFT are mostly concerned with iterating over lists. Let's create a list:
</p>

<pre>
  $ Dir.allFiles(Glob("*.java"))
</pre>
<p>
  This line of code generates a list of all java files under the current directory or sub-directories.
  When we are satisfied with the result of the code line, we give it a name.
</p>

<pre>
  $ /JavaFiles
</pre>

<p>
  We then iterate over the list of files returned, and count the number of lines in each, then
  sum it all up, creating the "linecount" function.
</p>
<pre>
  $ JavaFiles-&gt;f out(f.read.length) | _.sum
  &lt;int&gt;
  18946
  /linecount
</pre>


<p>
  The "arrow" followed by an identifier is the "for each" construct, with the identifier becoming
  the "loop variable".  The out() statement is used to generate output from the loop.
</p>
<p>
  The "pipe" character terminates the loop, and delivers the result from the loop (list of int) to the next part,
  where the "_" (underscore) symbol picks it off the stack, then calls the sum() function on it,
  returning a single int value.
</p>
<p>
  <b>Note:</b> loop variables are not regular variables, and can not be reassigned.
</p>




<h2>Filtering</h2>
<p>
  Filtering list data is essential in CFT. Here is a simple example:
</p>
<pre>
  $ List(1,2,3,4,3,2,1)->x assert(x>2) out(x)
  &lt;List&gt;
  3
  4
  3
</pre>
<p>
  The assert() works like "if condition not satisfied, continue with next value"
</p>







<h1>Local variables</h1>
<p>
  Function code may use local variables for simplifying expressions.
</p>

<pre>
  $ a=3 b=2 a+b
  &lt;int&gt;
  5 
</pre>

<p>
  Can also use "stack based" notation, where the assignment picks the current value
  off the stack and stores it into a variable:
</p>
<pre>
  3=&gt;a 2=&gt;b a+b
  5
</pre>

<p>
  Example:
</p>
<pre>
  List("java","txt")
  /types

  Dir.allFiles-&gt;f type=f.name.afterLast(".") assert(types.contains(type)) out(f)
  /textfiles
</pre>
<p>
  This function lists all files of type .java and .txt
</p>





<h1>Files</h1>
  <pre>
  $ File("x.txt")
   &lt;obj: File&gt;
   x.txt   DOES-NOT-EXIST 
  </pre>

 <p>
  The File() function requires a name, and returns a File object. As seen
  above, the file needs not exist.
</p>
<p>
  File objects created with a simple file name (no path), are always located in
  the CFT home directory. This gives predictability for certain data files etc.
</p>
<p>
  To access or create files in other directories, enter an absolute or relative
  path in the parameter to File(), or use the file() function inside
  some Dir object:
</p>
<pre>
  $ Dir.sub("src").file("x.txt")
</pre>




<h2>Page through a file</h2>

<p>
  To page through text file
</p>
<pre>
  more x.txt
</pre>



<h2>Show bytes of file</h2>
<p>
  To page through hex listing of file
</p>
<pre>
  File("x.txt").hex
</pre>



<h2>Encoding</h2>
<p>
  Default encoding is "ISO_8859_1", but this can be changed, for example:
</p>
<pre>
  File("x.txt").encoding("UTF-8")
</pre>



<h2>end-of-line</h2>
<p>
  For windows, the default line terminator is CRLF, and for Linux it is LF. This can be
  overridden as follows:
</p>
<pre>
  someFile.setWriteCRLF
  someFile.setWriteLF
</pre>
<p>
  To ensure a text file has all lines end with for example LF, we can do the following:
</p>
<pre>
  f=File("x.txt") lines=f.read f.setWriteLF.create(lines)
</pre>



<h1>Directories</h1>
<pre>
  $ Dir
  &lt;obj: Dir&gt;
  ConfigTool/ d:5 f:20
</pre>

<p>
  Calling the Dir function with no parameters returns a Dir object for the current directory.
</p>
<p>
   The Dir
  object offers multiple member functions, one of which is <b>.files()</b>, which produces a list of files in 
  the directory. Another is <b>.allFiles()</b> which return files from all subdirectories as well.
</p>


<h2>Create a subdirectory</h2>
<pre>
  Dir.sub("someDir").create
</pre>


<h2>Parent directory</h2>
<p>
  To get the parent directory of a Dir object:
</p>
<pre>
  Dir.sub("..")
</pre>

<h2>Get files in a directory</h2>
<pre>
  Dir.files
</pre>

<h2>Create a file in a directory</h2>
<pre>
  Dir.file("x.txt").create("something")
</pre>

<h2>Get immediate directories in a directory</h2>
<pre>
  Dir.dirs
</pre>
<h2>Get all files recursively under a directory</h2>
<pre>
  Dir.allFiles
</pre>
<h2>Get all directories recursively under a directory:</h2>
<pre>
  Dir.allDirs
</pre>
<h2>Delete a sub-directory</h2>
<p>
  The sub-directory must be empty
</p>
<pre>
  Dir.sub("something").delete
</pre>

<h2>Set current directory</h2>
<p>
  Apart from navigating interactively, to set current directory via code:
</p>
<pre>
  Dir.setAsCurrentDir
</pre>


<h2>Newest file in directory</h2>
<pre>
  Dir.newestFile
  Dir.newestFile(Glob("*.log"))
</pre>



<h1>The shell() function</h1>
<p>
  The global shell() function starts a shell inside CFT. When you exit from it, you're back
  in CFT.
</p>
<pre>
  $ shell
  (starts bash or cmd or Powershell or something else)
  exit
  # Running /usr/bin/bash completed: 25529ms
  $
</pre>
<p>
  The shell function is configured in the CFT.props file which must exist in the CFT 
  home directory.
</p>
<pre>
  shell = bash
  winShell = powershell
</pre>











<h1>Core types</h1>
<ul>
  <li>String</li>
  <li>int - (Java long)</li>
  <li>float - (Java double)</li>
  <li>boolean</li>
  <li>List</li>
  <li>Dict</li>
  <li>Binary</li>
  <li>Lambda</li>
</ul>
<p>
  All values in CFT are objects, which may contain functions. Strings can be written using double
  or single quotes. 
</p>

<h2>String literals</h2>
<p>
  Strings are written in <em>single or double quotes</em>, and can be concatenated with '+', which allows
  for all kinds of combinations.
</p>
<pre>
  $ "double quotes"
  $ 'single quotes'

  $Â "'a'"
  'a'

  $ '"' + "'a'" + '"'
  "'a'"
</pre>
<p>
  Also, backslash is not used as escape character, which means backslash is just another character,
  simplifying those Windows paths.
</p>


<h2>Dictionaries</h2>
<p>
  Dictionaries are maps that store any value identified by names (strings). 
</p>
<pre>
  $ x=Dict x.set("a",1) x.get("a")
  1
</pre>

<h3>Properties as functions</h3>
<p>
  For readability, values with names that are valid identifiers, and don't conflict with regular 
  member functions of Dict, can be referenced via dotted notation
</p>
<pre>
  $ Dict.set("a","b")
  $ /d
  $ d.a
  b
</pre>  

<h3>SymDict</h3>
<p>
  A special global expression, SymDict is used to create a dictionary from a list of
  symbols, which must be present as local variables, or parameterless functions. This
  saves some typing. Example code:
</p>
<pre>
  # Without SymDict()
  a=1
  b=2
  dict=Dict.set("a",a).set("b",b)

  # With SymDict
  a=1
  b=2
  dict=SymDict(a,b)
</pre>
<p>
Testing interactively all needs to be on the same line:
</p>
<pre>
	$ a=1 b=2 SymDict(a,b)
</pre>


<h2>Binary type</h2>
<p><i>v2.5.5</i></p>
<p>
  Used in connection with encryption etc. Can be created from strings.
</p>
<pre>
   "password".getBytes("UTF-8")
   &lt;Binary&gt;
   0x..
</pre>
<p>
	Check the Lib.Util object, which contains functions that create objects Encrypt and Decrypt.
</p>


<h1>List processing</h1>

<p>
  Lists are essential for all processing with CFT.
</p>
<p>
  Lists can be created manually using the global List() function. 
</p>

<pre>
  $ List(1,2,3)
  $ List("a","b","c")
</pre>

<p>
  A much used way for creating lists of strings, is to use the string function split(), which by default
  splits a string on spaces. This means the following produce the same result.
</p>

<pre>
  $ List("a","b","c")
  $ "a b c".split
</pre>




<h2>Iterating over list content</h2>
<p>
  The iterator in CFT takes the form of an arrow followed by a loop variable. For a loop construct
  to return output, we use the out() statement inside.
</p>

<pre>
  $ "1 2 3".split-&gt;x out("a"+x)
  &lt;List&gt;
   0: a1
   1: a2
   2: a3
</pre>

<p>
  The result is a list of strings, as displayed.
</p>




<h2>Filtering with assert(), reject() and break() + out()</h2>
<p>
  Using the assert() statement, we may abort processing for elements that do not meet a condition. 
</p>
<pre>
  $ Dir.allFiles-&gt;f assert(f.name.endsWith(".java")) out(f)
</pre>
<p>
  The reject() statement is the inverse of assert(), and aborts processing for elements that meet
  a certain condition.
</p>
<pre>
  $ List(1,2,3,2,1)-&gt;x reject(x&gt;2) out(x)
  &lt;List&gt;
  1
  2
  2
  1
</pre>
<p>
  The break() statement terminates ALL LOOPS if the condition is true.
</p>
<pre>
  List(1,2,3,2,1)-&gt;x break(x&gt;2) out(x)
  &lt;List&gt;
  1
  2
</pre>



<h2>The condOut() statement</h2>
<p>
  In addition to controlling loops with assert/reject and break, there is the condOut()
  statement, which takes a boolean condition as first parameter, and the value to 
  be sent out as second parameter. Can be useful some times.
</p>
<pre>
  $ List(1,2,3,2,1)-&gt;x condOut(x&lt;2,"(") out("b") condOut(x&lt;2,")") | _.concat
  &lt;String&gt;
  (b)bbb(b)
</pre>



<h2>Produce columns</h2>
<p>
  Using report() instead of out() lets us produce as output a list of strings,
  where multiple parameters to report() is formatted into columns. Example:
</p>
<pre>
  Dir.files-&gt;f report(f.name, f.length)
</pre>




<h2>List addition</h2>
<p>
  Two lists can be added together with "+".
</p>
<pre>
  List(1,2) + List(3)
  &lt;List&gt;
  1
  2
  3
</pre>

<p>
  Also, elements can be added to a list with "+" as long as the list comes first.
</p>
<pre>
  List(1,2)+3
  &lt;List&gt;
  1
  2
  3
</pre>




<h2>List subtraction</h2>
<p>
  Using "-", we can remove one or more elements from a list.
</p>

<h3>Removing a single value from a list</h3>
<pre>
  List(1,2,3,2,1)-2
  &lt;List&gt;
  1
  3
  1
</pre>

<h3>Removing multiple values from a list</h3>
<pre>
  List(1,2,3,2,1)-List(2,3)
  &lt;List&gt;
  1
  1
</pre>






<h1>Sorting</h1>
<p>
  The List object has a single .sort() member function, which does the following:
</p>
<ul>
  <li>if all values are int, sort ascending on int value</li>
  <li>if all values are float, sort ascending on float value</li>
  <li>otherwise sort ascending on "string representation" of all values</li>
</ul>
<p>
  Now, to sort other types of values, we use a "trick", which consists of wrapping each
  value inside a special wrapper object, masking the original values as either int, float
  or STring, then sort, and finally extract the actual value from the wrappers.
</p>
<p>
  To sort a list of files on their size, biggest first, we do the following:
</p>
<pre>
  Dir.files-&gt;f 
    out(Int(f.lastModified,f))
  | _.sort.reverse-&gt;x
    out(x.data)
</pre>
<p>
  The first loop wraps each File object inside an Int object, which is created by
  supplying two values to global function Int: the value to sort on, and the object itself.
</p>
<p>
  Then the resulting list is "piped" to code that picks it off the stack, sorts and
  reverses it, before iterating over the result, and for each object (now the Int objects),
  outputs the original File object, available via the .data() function.
</p>

<h2>Int(), Str() and Float()</h2>
<p>
  Similarly there is a global Str() function for sorting on strings, and Float() for 
  sorting on floats. Together with Int() function, these produce Str, Float and Int objects,
  which are actually subclasses of the regular "String", "float" and "int" value types, with
  the additional function .data() to retrieve the original value.
</p>


<h2>Converting between int and float</h2>
<p>
  Both the "int" and "float" type contain two functions for converting to int and float:
</p>
<pre>
  2.f     becomes float 2.0
  2.i     remains int   2

  3.14.f  remains float 3.14
  3.14.i  becomes int   3
</pre>







<h1>Savefiles - "scripts"</h1>
<h2>Save</h2>
<p>
  To save all named functions, enter the special command below
</p>

<pre>
  $ :save Test
</pre>

<p>
  This creates a file under the CFT home directory,
  called savefileTest.txt. 
</p>

<h2>Load</h2>

<pre>
  $ :load Test
</pre>


<h2>Create new empty script</h2>
<p>
  To create a new script from scratch, there is the colon command:
</p>
<pre>
  $ :new
</pre>
<p>


<h2>The @e shortcut</h2>
<p>
  A common shortcut is @e, which opens current savefile in an editor:
</p>
<pre>
  $ @e
</pre>
<p>
  Shortcuts can be redefined in the CFT.props file.
</p>


<h2>CFT.props - codeDirs</h2>
<p>
  The CFT.props file contains the following line by default
</p>
<pre>
codeDirs = . ; code.examples ; code.lib
</pre>
<p>
  The codeDirs field defines a search order when loading scripts (followed by current dir)
</p>
<p>
  The code.examples contains some example code for various use, while code.lib contains
  library code, used by most other scripts.
</p>
<p>
  Each script remembers where it was loaded from, so when saving it, it is written back
  to that location.
</p>






<h1>Comments</h1>
<p>
  The hash character '#' indicates that the rest of the line is a comment.
</p>










<h1>Calling functions in other scripts</h1>
<p>
  Sometimes we want to call a useful function in another script file. This is
  implemented with with the following syntax:
</p>
<pre>
  Script:Function (...)

  Example: 
    Lib:Header("This is a test")
</pre>
<p>
  Parameters are given as a list of values inside ()'s, which may be omitted if no parameters.
</p>





<h1>Examining external scripts</h1>
<p>
  The '?' interactive command has an extended syntax that allows you to list functions inside
  another script, as well as listing the code of particular function.
</p>
<pre>
  $ ?Lib:                  # lists functions inside Lib
  $ ?Lib:m                 # displays code of function 'm'
</pre>






<h1>Helper / local functions</h1>
<p>
  In many cases, one needs to create helper functions, which should not be visible as part
  of the script interface, as seen from other scripts. This is done by defining the function
  as follows:
</p>
<pre>
  $ 23
  $ //SomeConstant
</pre>
<p>
  The '?' command now omits local functions, for a cleaner summary of the main functions
  of a script. To see all functions, type '??' and press Enter. The local functions are
  prefixed by a single '/' slash. 
</p>
<p>
  When inspecting
  script from outside via the "?ScriptName:" functionality, the local functions are
  also not displayed. 
</p>
<p>
  However, inspecting functions from the outside, or with the script as current, by 
  including a (partial) name, the
  private functions are included, again prefixed by '/', to indicate their status.
</p>
<pre>
# Examples
$ ?X
$ ?SomeScript:X
</pre>
<p>
  There is nothing blocking calls to local functions from the outside, it is purely
  a means of filtering what to show, for clarity.
</p>





<h1>Displaying all known scripts</h1>
<p>
  The function Lib:Scripts displays all available scripts, sorted by the directories given
  in the CFT.props file.
</p>
<p>
  The shortcut @scr calls this function.
</p>










<h1>Nested loops</h1>
<p>
  Loops are implemented using the "for each" functionality of "-&gt; var". Loops may well be nested.
</p>

<pre>
  $ List(1,2,3)-&gt;x List(1,2,3)-&gt;y  out(x*y)
  &lt;List&gt;
   0: 1
   1: 2
   2: 3
   3: 2
   4: 4
   5: 6
   6: 3
   7: 6
   8: 9
</pre>

<p>
  In this case, the body of each loop is all code following the "-&gt; var"
  construct. But this can be changed using the "pipe" symbol, which "closes" all loops.
</p>



<h1>Code spaces - "pipes"</h1>
<p>
<i>Code spaces have also been called Loop spaces in earlier versions of the doc.</i>
</p>

<p>
  The body of any loop is the rest of the code of the function, or until a "pipe" symbol
  is found. The pipe symbol ("|") more accurately partitions code into a sequence of
  <em>code spaces</em>. It marks termination of all current loops.
</p>
<p>
  The way a "pipe" works, is to wait for any current loops to terminate, then take the
  return value from that code space and putting it onto the stack for the next loop
  space to work with (or do something else). Example:
</p>
<pre>
  $ Dir.files-&gt;f out(f.length) | =&gt;sizes sizes.sum
</pre>
<p>
  This single line of code first contains a loop, which outputs a list of integers for
  the sizes of all files in the current directory. Then the "pipe" symbol terminates that
  code space, and creates a new one, where we pick the result from the previous loop
  space off the stack and assigns it to a local variable. We then apply the sum() function to it.
</p>
<p>
  To save us some typing, the special expression "_" (underscore) pops the topmost value off
  the stack.
</p>
<pre>
  $ Dir.files-&gt;f out(f.length) | _.sum
</pre>

<p>
  As we see from the above code, a code spaces don't <em>need</em> containing loops. The 
  following is perfectly legal, although a little silly.
</p>
<pre>
  $ 2+3 | | | | =&gt;x x | =&gt;y y | _ _ _ |
</pre>
<p>
  Yes, it returns 5.
</p>




<h2>Result value from a code space</h2>
<p>
  All function bodies in CFT consist of one or more <em>code spaces</em>. The result value
  from any such body is the return value from the last code space.
</p>

<h3>Code space result value</h3>
<p>
  If a code space contains loop statements, the result value is a list of data generated
  via calls to out() or report() statements. If no actual iterations take place, or
  filtering with assert(), reject() or break() means no data is generated via out() or report(), 
  then the result list is empty.
</p>

<h3>Otherwise ...</h3>
<p>
  A code space that doesn't contain loop statements, has as its result value the topmost
  element on the stack after all code has executed. If there is no value on the stack,
  the return value is <em>null</em>.
</p>



<h2>Code blocks: an alternative to code spaces</h2>
<p>
	Code spaces are a top-level construct in functions. They can not (easily) be nested,
	and can become confusing when function code grows. An alternative is to use
	code blocks. These are described later, under the header <em>Block expressions</em>, and
	consist of three types: local, Inner and Lambda. 
</p>
<p>
	To replace code spaces, we normally use the "Inner" type of blocks. Example, summing
	the sizes of the files in current directory:
</p>
<pre>
	Inner{ Dir.files-&gt;f out(f.length) }.sum
</pre>
<p>
	Here we see that the Inner block really is an expression, with a return value,
	which is the list of individual file sizes. We then call the sum() function
	on that list.
</p>
<pre>
	numLines={Dir.files-&gt;f out(f.read.length)}
	numFiles=Dir.files.length
	avg=numLines/numFiles
	println("Average number of lines per file: " + avg)
</pre>
	









<h1>Function parameters</h1>
<p>
  Custom functions can also take parameters. This is done using the P() expression, which
  identifies the parameter by position. Note that <em>parameter position is 1-based</em>.  
</p>
<pre>
  $ P(1)=&gt;a P(2)=&gt;b a+b
</pre>
<p>
  This is a valid function, but entering it interactively fails, because it is immediately
  parsed and executed, and there are no parameters. To overcome this, the P() expressions
  take a second parameter, which is a default value.
</p>
<p>
  The default value parameter to P() is important for several reasons.
</p>
<ol>
  <li>Allows the function code to execute while being developed interactively</li> 
  <li>Allows for default values when function is called without parameters, or when called with null-values</li>
  <li>May act as documentation in the source</li>
  <li>
    Provides an elegant way of making functions interactive and non-interactive at the same time, 
    as the default expression is evaluated only when parameter is not given (or is null), 
    and may then ask the user to input the value.
</li>
</ol>
<p>
  Above example again, now with default values for parameters:
</p>
<pre>
  $ P(1,1)=&gt;a P(2,2)=&gt;b a+b
  &lt;int&gt;
  3
  $ /f
  $ f(5,10)
  &lt;int&gt;
  15
</pre>





<h1>User input</h1>
<p>
  CFT contains the following for asking the user to enter input:
</p>
<pre>
  value = Input("Enter value").get
  value = readLine("Enter value")
</pre>
<p>
  The difference is that Input remembers unique input values, and lets the user
  press enter to use the last (current) value, or may enter colon to select between previous
  (history) values. It also has functions to manipulate the history and the "current" value.
</p>
<p>
  The readLine() is much simpler, and allows for empty input, as Enter
  doesn't mean "last value" as it does for Input.
</p>

<p>
  The optional default value parameter to the P() expression for grabbing parameters to
  functions, can be used to produce functions that ask for missing values.
</p>
<pre>
  P(1,Input("Enter value").get) =&gt;value ...
</pre>









<h1>Block expressions</h1>
<p>
  The traditional blocks inside curly braces are present in CFT as well.
</p>


<h2>Local blocks</h2>
<p>
  Local blocks are just for grouping code that runs in the same context as the code around it. Technically
  they are considered expressions.
</p>
<pre>
  if (a&gt;b) {
    ...
  }
</pre>

<p>
  Local blocks can contain loops, but can not be split into multiple code spaces using the PIPE ("|")
  symbol. Since they execute in the same run-context as the code around them, any calls to out() or report()
  add to the result list of the environment.
</p>



<h2>Lambdas</h2>
<p>
  A Lambda is an object (a value) that contains code, so it can be called, with parameters. The code
  inside runs detached from the caller, and behaves exactly like a function.
</p>
<pre>
  Lambda{P(1)+P(2)}
  /MyLambda

  $ MyLambda.call(1,2)
</pre>
<p>
  Can be used to create local functions inside regular functions, but mostly used to create
  closures and/or Dict objects.
</p>



<h2>Inner blocks</h2>
<p>
  An inner block is a cross between local blocks and the Lambda. An Inner block is executed
  immediately, and has access to the local variables inside the function, but maintain a separate
  context for loops and loop output. Technically, inner blocks are expressions, just as with local
  blocks. 
</p>
<p>
  In other words: Inner blocks define their own code space.
</p>
<pre>
  Inner {
    someList->x out(x+1)
  } =&gt;resultList 
  ...
</pre>
<p>
  Inner blocks are a way of running loops isolated from the environment. Remember that loops by 
  default extend to the end of the function, or until hitting a "pipe". The third thing that 
  terminates loops are hitting the end of the current block.
</p>




<h2>Block expressions summary</h2>
<p>
  Local (plain) blocks for non-PIPE-separated blocks of code, typically used with "if". Running in
  the same code space as outside the block, means it can call break() and out() as well as
  assert() and reject() and affect the (innermost) loop of those outside the block. 
</p>
<p>
  Inner blocks for isolated processing loops inside other code. This means calling break() and
  out() and assert() and reject() have no effect on loops outside the block. 
</p>
<p>
  Lambdas are "functions" as values.
</p>



<h2>Examples: Local vs Inner</h2>
<pre>

List("aaa","bbb")-&gt;line
  # Using a local block to limit scope of loop, so that we
  # can follow it by code that runs after the inner loop
  # has completed. Results in list of characters: aaaXbbbX
  {
    line.chars-&gt;c out(c)
  } 
  out("X")
/t


List("aaa","bbb")-&gt;line
  # The Inner block below works in a separate context, so the calls
  # to out() don't affect the resulting output list of the function.
  # The Inner block returns a list, but it isn't used in this example.
  # So function returns list with XX only.
  Inner {
    line.chars-&gt;c out(c)
  } 
  out("X")
/t
</pre>






<h2>Local variables scope</h2>
<p>
  Local variables inside functions (and lambdas) all share the same scope. This
  means that there are no sub-scopes inside local or inner blocks inside a 
  function body. 
</p>
<pre>
  $ {x=3} x
    3
</pre>








<h1>List filtering with Lambda</h1>
<p>
  Instead of using processing loops, filtering lists can also be done
  using .filter() function.
</p>
<pre>
"12345".chars
.filter(Lambda{P(1).parseInt})
.sum
/t
</pre>



<h2>Removing items</h2>
<p>
  To remove items, the Lambda should return null.
</p>
<pre>
"12345".chars.filter (Lambda{ P(1).parseInt=&gt;x if(x&gt;=3,x,null) })
</pre>
<p>
  This returns a list of 3,4,5
</p>




<h1>Conditionals - if expression</h1>
<p>
  Conditional execution of code is done in two ways in CFT, with the first being how we
  control processing loops with assert, reject and break.
</p>
<p>
  Then there is the if-exression. It takes two forms, but is always considered an expression, not a statement. The
  difference is that expressions always return a value, which statements need not.
</p>
<h3>Inline form</h3>
<pre>
  if (condition, expr1, expr2)
  if (condition, expr1)
</pre>
<p>
  The first selects between the two expressions, based on the condition, evaluating and returning 
  expr1 if condition is true, otherwise expr2. The second conditionally evaluates expr1, or if 
  the condition is false, returns null.
</p>

<h3>Traditional form</h3>
<pre>
  if (condition) stmt1 else stmt2
  if (condition) stmt1
</pre>

<h3>Example 1</h3>
<p>
  Inline form. Check if some value is null, and if it is, provide a default value
</p>
<pre>
  if (value != null, value, "defaultValue") =&gt;value
</pre>

<h3>Example 2</h3>
<p>
  Using traditional form to call statement "break".
</p>
<pre>
  i=1
  loop
    out(i)
    if (i&gt;=10) break else i=i+1
</pre>

<h3>Expressions are statements ...</h3>
<p>
  Note that all expressions are also statements, which means the first example can be
  written on traditional form:
</p>
<pre>
  if (value != null) value else "defaultValue" => value
</pre>

<h3>Blocks are expressions ...</h3>
<p>
  Also note, that (local) blocks are expressions, which can contain statements, so we can even do:
</p>
<pre>
  i=1
  loop
    out(i)
    if (i&gt;=10,{break},i=i+1)
</pre>



<h2>if-ladders</h2>
<p>
  The implementation in CFT supports chaining multiple if after each other.
</p>
<pre>
  if (cond) {
    ...
  } else if (condB) {
    ...
  } else if (condC) {
    ...
  }
</pre>
<p>
  Decoding some value x into a numeric code, we can enter the following
</p>
<pre>
  code = if (x=="a") 1 else if (x=="b") 2 else if (x=="c") 3 else 4
</pre>






<h1>Lazy evaluation</h1>
<h4>Lazy if</h4>
<p>
  The if-expression uses lazy evaluation, which means that only the selected
  value expression (if any) gets evaluated. This is the same as every other
  language.
</p>
<h4>Lazy AND, OR - &amp;&amp; ||</h4>
<p>
  Boolean expressions with logical AND and OR, are lazy, again as in
  every other language. 
</p>
<h4>Lazy P(N,defaultExpr)</h4>
<p>
  The P() expression to access function parameters only evaluates the default
  expression if parameter N is null.
</p>





<h1>The error() function</h1>
<p>
  The error() expression is another that contains a conditional part, and if true, throws
  an exception with the string part, terminating current execution. Alternatively it can
  be used without the condition, which means it always throws an exception.
</p>
<pre>
  error(1+1 != 2,"this should not happen")

  if (1+1 != 2) {
    error("oops again")
  }
</pre>



<h1>Output to screen</h1>
<pre>
  println("a")
  printDebug("b")
</pre>
<p>
  The printDebug() includes location in the source, and appends the log lines to
  a "system messages" list, which is displayed after processing has completed.
</p>



<h1>Protecting files and directories</h1>
<p>
  To save typing, one often create functions that just return some directory, or 
  some files.  The JavaFiles example above illustrates this.
</p>
<p>
  The protect mechanism in CFT lets us attach a protect state to any Dir and File object,
  which guarantees that:
</p>
<ol>
  <li>all files and directories derived from it are also protected</li>
  <li>blocks destructive modifications</li>
</ol>


<h2>Example</h2>
<p>
  Adding .protect to each file that the JavaFiles function generates, ensures that all
  files returned from this function are blocked against accidental delete and modifications.
</p>
<pre>
  $ Dir.allFiles-&gt; f assert(f.name.endsWith(".java")) out(f.protect)
  $ /JavaFiles
</pre>
<p>
  Demonstration:
</p>
<pre>
  $ JavaFiles.nth.append("")   # Trying to append empty line to first file
  ERROR: [input:16] INVALID-OP append : /home/roar/.../xyz.java (PROTECTED: -) (java.lang.Exception)
</pre>
<p>
  The .protect() function can also take a description string, which if present, is displayed in this error.
</p>

<h2>A protected directory does not allow</h2>

<ul>
<li>create</li>
<li>delete</li>
<li>copy file into dir - includes blocking File.uncompress when target dir is protected</li>
</ul>


<h2>A protected file does not allow</h2>
<ul>
  <li>delete</li>
  <li>create</li>
  <li>append</li>
  <li>copyFrom (target)</li>
  <li>copyTo</li>
  <li>move (source or target)</li>
</ul>





<h2>No guarantee</h2>
<p>
  Calling .protect on a Dir object, before using it to locate files, will propagate the protected
  state to all those files. However, creating a new Dir object for the same path, without calling 
  .protect() on it, and then accessing content via this, does not protect anything.
</p>
<p>
  Note also that .protect can not detect for example using the path of a protected File object in
  an external program, or even to create a new File object (which will not be protected). Example:
</p>
<pre>
  File(protectedFile.path)
</pre>



<h2>Unprotect</h2>
<p>
  If there is an expression that returns some protected directory or some protected files, and we
  are explicitly sure we want to modify it, we can use the .unprotect() function. It removes the
  protect flag, but fails with an error if there is no such flag there when called.
</p>







<h1>Running external programs</h1>



<h2>Summary</h2>
<p>
  The functions for running external programs are part of the Dir object, implicitly defining
  working directory for the program.
</p>

<pre>
  $ Dir.run ( list|...)
  $ Dir.runCapture ( list | ...)
  $ Dir.runDetach ( list|...)
  $ Dir.runProcess ( stdinFile, stdoutFile, stdErrFile, list|... )
</pre>

<p>
  The parameters written as "list|..." means either a List object, or a list of
  String values, separated by comma.
</p>




<h2>Dir.run()</h2>
<p>
  This command is used for running external programs in the foreground. What this means is that if
  the program requires user input, we can give it, and the CFT code will not continue until
  the external process has terminated.
</p>
<pre>
  $ Dir.run("cmd","/c","git","pull","origin","master")
</pre>
<p>
  Many Windows programs require the "cmd","/c" in front of the actual program.
  For proper operating systems (Linux) you naturally skip the two first elements of the command list.
</p>



<h2>Dir.runCapture()</h2>
<p>
  This works the same as Dir.run(), but returns a List of strings representing stdout from the
  external program, to be processed further. Not suited for interactive use.
</p>

<pre>
  Dir.runCapture("which","leafpad") =&gt;lines lines.length&gt;0 && lines.nth.contains("leafpad")
  /HasLeafpad
</pre>



<h2>Dir.runDetach()</h2>
<p>
  Use to run external program in the background. The CFT code continues running after forking
  off the background process. Nice for editors etc.
</p>
<pre>
  $ Dir.runDetach("leafpad", Sys.savefile.path)
</pre>

<p>
  This example runs the leapad editor in the background, with the path of the current savefile as 
  argument.
</p>


<h2>Dir.runProcess</h2>
<p>
  Runs external program, reading input lines from text file, and deliver stdout and stderr to 
  files. Returns an ExtProcess object, which is used to monitor, terminate or wait for the
  external process to finish.
</p>
<p>
  The complexities of creating and removing temporary files, is encapsuled in the library
  function <b>Lib:runProcess</b>, which in turn is called from the simpler <b>Lib:run</b> function, which
  also handles waiting for the external process to finish, before returning. 
</p>
<p>
  Both of the Lib functions take the same four parameters, but often only the first is used, as the
  rest have useful defaults.
</p>
<p>
  <i>Lib:run</i> is the notation for calling a function in another script.
</p>


<h2>Lib:runProcess utility function</h2>
<p>
  This is a CFT function in the Lib script, which hides the complexities of 
  calling Dir.runProcess (above). 
</p>
<pre>
  Lib:runProcess(List("ls","-l)) =&gt; result
</pre>
<p>
  The result object is a Dict with various system info, representing the running
  process. It has two closures of interest.
</p>
<p>
  A <i>closure</i> is a callable object, which
  runs code "inside" a dictionary, via a <i>lambda</i>. Closures and lambdas are invoked
  via their .call(...) function.
</p>
<pre>
  result.isCompleted.call     # returns boolean
  result.wait.call            # waits for process to finish, then returns another Dict
</pre>
<p>
  The result.wait closure, when called, returns a Dict with the following content:
</p>
<ul>
  <li>cmd - the command (list)</li>
  <li>stdin - the stdin lines (list)</li>
  <li>stdout - stdout lines (list)</li>
  <li>stderr - stderr lines (list)</li>
  <li>exitCode - int</li>
</ul>
<p>
  To show the Lib:runProcess function code
</p>
<pre>
  $ ?Lib:runProcess
</pre>
<p>
  Warning: it's a bit complex
</p>




<h2>Lib:run utility function</h2>
<pre>
  Lib:run (List("ls","-l")) =&gt; result
</pre>
<p>
  The implementation of Lib:run consists of calling Lib:runProcess and then
  calling the wait closure, as seen above, returning the result from that call.
</p>
<p>
  To show the Lib:run function code
</p>
<pre>
  $ ?Lib:run
</pre>


<h2>Work directory issues</h2>
<p>
  For external programs that depend on running from a specific directly, either navigate to current directory
  interactively, or just let your code call the .setAsCurrentDir() function on some Dir object before
  calling Lib:run. 
</p>
<pre>
  Dir("/home/user/xyz").setAsCurrentDir
  Lib:run(...) =&gt; result
</pre>




<h2>Doing ssh</h2>
<p>
  If you need to run SSH commands on remote targets, use the SSH library script, which
  contains two major functions: run() and sudo(), These call Lib:run then filter the output
  to stdout using a marker to eliminate the welcome text when logging in etc.
</p>

<p><b>Side note: ssh without password</b></p>
<p>
  To set up ssh login without password, create and distribute an ssh key, then
  copy it to the target host, as follows (in Linux shell).
</p>
<pre>
  $ ssh-keygen -t rsa
  $ ssh-copy-id user@host
</pre>






<h1>Synthesis</h1>

<h2>The problem</h2>

<p>
  If we use "cd" and "ls" to move
  to a directory, and want to create a function that works on files or subdirectories under
  that location, we have to take care.
</p>

<p>
  The issue is that we can not just say
</p>
<pre>
  Dir.allFiles-&gt;f ...
</pre>
<p>
  ... because the Dir() function returns the current directory, which may change. 
</p>


<h2>Creating code from values</h2>
<p>
  This is where the <i>syntesis</i> functionality comes in. The most often used variant takes
  the form of two "colon commands". 
</p>
<ol>
  <li>The :syn command syntesizes code from the last result.</li>
  <li>The :NN  (where NN is an integer) syntesizes the indicated element of the last result list. If 
  last result is not a list, an error is reported.</li>
</ol>


<h2>Example using :syn</h2>

<pre>
  $ cd ..
    # /home/roar
    &lt;obj: Dir&gt;
    roar/ d:61 f:33 
  $ cd project1
    # /home/roar/project1
    &lt;obj: Dir&gt;
    project1/ d:0 f:0 
  $ :syn
  synthesize ok
  +-----------------------------------------------------
  | .  : Dir("/home/roar/project1")
  +-----------------------------------------------------
  Assign to name by /xxx as usual

  $ /DirProject1
</pre>

<p>
  When we use "cd" to change to a directory, it returns a Dir object. The shell remembers the last
  result value, and the ":syn" attempts to create code representing that value in as direct a way as 
  possible. If this succeeds, it inserts the generated code line tino the "code history", as the 
  last command, which means it can now be assigned a name, for example "DirProject"
</p>

<p>
  Calling function "DirProject" will now always generate a Dir object pointing to the same
  directory, and is no longer dependening on current directory.
</p>

<h2>Example using :NN</h2>

<p>
  To synthesize a single element when the last result was a list, use :NN, as follows
</p>

<pre>
  $ ls
  &lt;List&gt;
   0: runtime/              | d:2 | f:12
   1: CallScriptFunc.java   | 1k  | 1398  |             | 2020-02-28 22:38:09
   2: CodeHistory.java      | 10k | 10980 | 2d_22:23:24 | 2020-06-07 12:57:49
   3: CommandProcessor.java | 0k  | 365   |             | 2020-02-28 22:38:09

  $ :2
  synthesize ok
  +-----------------------------------------------------
  | .  : File("/home/roar/Prosjekter/Java/ConfigTool/src/rf/configtool/main/CodeHistory.java")
  +-----------------------------------------------------
  Assign to name by /xxx as usual  
</pre>

<p>
  If the last value was not a list, the ":NN" command will fail with an error.
</p>





<h1>Output format / Cfg</h1>
<p>
  Output to screen is regulated via a Cfg object. It is a session object, that contains default
  settings for number of lines and line width of the current window / terminal. It's default
  mode of operation is to disable wrapping, which means long lines are cut, ending with a simple '+'
  to indicate this.
</p>
<p>
  To change the current size of the terminal window, we may use global function Cfg() to obtain
  the Cfg object, and methods to set or view the properties.
</p>



<h2>The @term shortcut</h2>
<p>
  After the introduction of short cuts, the easiest way to set the terminal window width and
  height, is to enter
</p>
<pre>
  $ @term
</pre>

<p>
  This works on Linux (using stty command) and on Windows (powershell). 
</p>



<h2>Line wrapping</h2>
<p>
  By default, ouput line wrapping is off, which means that lines longer than the Cfg.w gets truncated
  with a '+' to indicate there is more. It can be switched on/off via the Cfg object, but there is also a
  colon command ":wrap" which toggles wrapping on or off.
</p>








<h1>Templating</h1>

<p>
  Templating is the task of merging data into text, or alternatively of selecting
  blocks of text to form a custom result. 
</p>
<p>
  This is useful for producing configuration files, generating code, and similar.
</p>



<h2>Merging text with Dict</h2>

<p>
  To merge values into a template, we use a dictionary object (Dict) combined with the
  merge() function of strings. This replaces occurrences of names in the dictionary
  with their values (as strings).
</p>
<pre>
  $ Dict.set("name","Julius")
  $ /data
  $ "Dear name".merge(data)
  &lt;String&gt;
  Dear Julius 
</pre>

<h2>Dict.mergeCodes()</h2>

<p>
  The merge is based on a direct match. Often we like to mark our merge codes. The Dict
  object has a function, ".mergeCodes()", which returns a new Dict object, where all names of fields
  are rewritten into ${name}. Changing the template correspondingly, this eliminates the risk of 
  accidentally matching text not meant as merge codes.
</p>
<pre>
  $ Dict.set("name","Julius").mergeCodes
  $ /data
  $ "Dear ${name}".merge(data)
  &lt;String&gt;
  Dear Julius 
</pre>

<h3>Custom merge codes</h3>
<p>
  The Dict.mergeCodes() also take an optional two parameters, which are the pre and post
  strings for creating the merge codes. Note that either none or both of these must be
  given.
</p>
<pre>
  $ Dict.set("name","Julius").mergeCodes("[","]")
  $ /data
  $ "Dear [name]".merge(data)
  &lt;String&gt;
  Dear Julius 
</pre>


<h2>PDict()</h2>
<p>
  With many parameters to be merged into the template text, the special expression PDict() saves
  us some typing. Instead of having to do this:
</p>
<pre>
  P(1) => name
  P(2) => ip
  Dict
    .set("name",name)
    .set("ip",ip)
    .mergeCodes =&gt; data
</pre>
<p>
  ... we can instead just say:
</p>
<pre>
  PDict("name","ip").mergeCodes =&gt; data
</pre>
<p>
  The PDict function takes a list of names, and map them to the function parameters
  in sequence. Missing values result in "null", which in turn (when calling String.merge),
  get replaced with empty strings. 
</p>
<p>
  If missing values are a problem:
</p>
<pre>
  PDict("name","ip").mergeCodes =&gt; data
  error(data.hasNullValue,"Missing parameters!")
</pre>



<h2>Example using raw strings and Sequence()</h2>
<p>
  <b>Raw strings</b> are a special notation for strings, that is as follows:
</p>
<pre>
  a = @ this is a "raw string" ...
</pre>
<p>
  The raw string starts following the "@ " prefix, and continues to the end of the line.
</p>
<p>
  <b>Sequence()</b> and <b>CondSequence()</b> are built-in expressions that are similar to 
  List, in that they create list objects, but with a relaxed syntax, which means commas
  between values are optional. 
</p>
<p>
  The CondSequence() is conditional, which means if the first parameter is false, it generates
  an empty list. Since lists can be concatenated with "+", we can do this:
</p>
<pre>
  PDict("replSetName","clusterRole").mergeCodes=&gt;data
  isConfNode = (P(2)=="configsvr")
  
  Sequence(
    @  :
    @  :
    @Â replication:
    @   replSetName: '${replSetName}'
    @
  ) + CondSequence(isConf,
    @ 
    @ # NOTE: config replica set node
    @
  ) + CondSequence(!isConf,
    @
    @ # NOTE: data shard replica set node
    @
  )+Sequence(
    @ sharding:
    @   clusterRole: '${clusterRole}'
  )
  ->line out(line.merge(data))
  /CreateMongodCfg
</pre>


<h1>Processing text</h1>
<p>
  Here are different ways of working with text in CFT.
</p>
<ul>
  <li>Reading separate text files</li>
  <li>"here" documents in script files</li>
  <li>DataFile</li>
  <li>Sequence() and raw strings</li>
</ul>




<h2>Reading text files</h2>
<p>
  Any text file can be read and processed line by line as follows.
</p>
<pre>
  Dir.file("x.txt").read->line ...
</pre>



<h2>Script file "here" documents</h2>
<p>
  This is a special feature of script files, where a sequence of lines between two
  marker lines, are translated to a List expression on the fly, as the script file is loaded.
</p>
<pre>
  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Identifier
  This is
  some text
  &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Identifier
  /myTemplate
</pre>
 <p>
  Calling the myTemplate function from the interactive shell, produces the following result
</p>
<pre>
  $ myTemplate
  &lt;List&gt;
  0: This is
  1: some text
</pre>
<p>
  The markers need at least 3x of the '&lt;' or '&gt;' followed by space and a matching identifier.
</p>



<h2>DataFile</h2>
<p>
  The DataFile global function reads a special text file with individual sections identified
  by a user selectable selector string, and names.
</p>
<p>
  Example data file 'data.txt'
</p>
<pre>
  ### A

  This is
  template A
  
  ### B
  
  This is 
  template B
</pre>
<p>
  The code to use this file consists of creating the DataFile object, passing the separator
  string as a parameter, then accessing the individual templates.
</p>
<pre>
  $ DataFile(File("data.txt"),"###")
  $Â /df

  $ df.get("A")
  &lt;List&gt;
  This is
  template A
</pre>

<h3>Include blank lines</h3>
<p>
  The function DataFile.get() returns only non-blank lines. To get all lines, use function getAll().
</p>

<h3>Filter away comments</h3>
<p>
  Also, DataFile has support for comments in the template text, which can be automatically
  removed. They are defined by another prefix string as follows:
</p>
<pre>
  $ DataFile(someFile,"###").comment("//")
  $ /df
</pre>
<p>
  Now all lines starting with "//" are automatically stripped from any output.
</p>




<h2>Sequence() and raw strings</h2>
<p>
  <i>v1.7.0</i>
</p>
<p>
  Raw strings start with '@' and consist of the rest of the line.
  In addition, two expressions have been added, called Sequence() and CondSequence(). These
  generate List elements, but with a relaxed syntax, making commas between values optional, 
  for max readability when creating a template.
</p>
<pre>
  Sequence(
    @ header
  )+CondSequence(&lt;condition&gt;
    @ optional-part 
  )+Sequence(
    @ footer
  )
</pre>
<p>
  What happens here is that the Sequence() and CondSequence() expressions result in List
  objects, which are then concatenated via the "+" operator. 
</p>
<p>
  The "@" type "raw" strings can be used in regular code as well. The behaviour is as follows:
</p>
<ul>
  <li>When "@" is followed by single space, that single space is removed from the string</li>
  <li>When "@" is followed by another "@", all characters following that sequence becomes the string</li>
  <li>When "@" is followed by anything else, all of the rest of the line becomes the string</li>
 </ul>
 <p>
  The advantage of this notation over that of "here"-documents, is that it allows proper
  indentation, for greatly improved readability in script code, and that it's easy to
  add conditional blocks, while the "here"-document means we can paste original text
  directly into the script code.
</p>







<h1>Processing JSON</h1>
<p>
  The "JSON" script handles parsing JSON into a Dict/List structure, and
  conversely, takes a Dict/List structure to JSON format again.
</p>
<p>
  Worth noting that the JSON library is a CFT script, not built-in functionality.
  The parser is written in CFT, using the Lib.Text.Lexer to tokenize the input,
  and a plain recursive-descent parser as functions inside the JSON script.
</p>
<p>
  Parse example:
</p>
<pre>
  $ JSON:Parse("{a:1,b:[2,3,4]}") 
    Dict: a b
  $ /x

  $ x.b
    0: 2
    1: 3
    2: 4
</pre>
<p>
  Generate JSON example
</p>
<pre>
  $Â Dict.set("a",1).set("b",2).set("c","xyz".chars)
    Dict: a b c
  $ /y
  $ JSON:PP(y)
     0: {
     1:   "a": 1,
     2:   "b": 2,
     3:   "c": [
     4:     "x",
     5:     "y",
     6:     "z"
     7:   ]
     8: }
  $ JSON:Export(y)
    { "a": 1, "b": 2, "c": [ "x", "y", "z" ] }
</pre>
<p>
  As of version 2.3.6 dictionaries keep track of the order values are stored, which ensures
  that the order of fields added to dictionary, is the order of fields when generating JSON.
</p>
<p>
  Vice versa, the order of fields inside objects in a JSON string, when parsed, becomes the order of
  fields in the corresponding dictionaries.
</p>



<h1>Processing XML</h1>
<p>
  The "XML" script handles parsing and pretty-printing XML. It uses only List and Dict
  objects, and has not (per v2.5.3) probably not found its final form. 
</p>




<h1>Use as a calculator</h1>

<h2>Expressions and "variables"</h2>
<p>
  Having a running instance of CFT on the desktop means access to a capable calculator.
</p>
<pre>
  $ 24*60*60
  &lt;int&gt;
  86400
  /x

  x*365
  &lt;int&gt;
  31536000
</pre>
<p>
  As noted before, the symbol "x" does not refer to the value 86400, but to the code that 
  generates the value.
</p>



<h2>Lib.Math</h2>
<p>
  The global function Lib() creates a Lib object, which in turn contains functions that
  create other objects, such as the Math object, which contains trigonometric functions.
</p>
<p>
  <i>v2.7.2</i> Added DD function, which contains Vec(x,y) for creating 2D vectors,
  and doing 2D vector math.
</p>


<h2>Lib.Convert</h2>
<p>
  The Lib.Convert function returns another object, which contains code for lots of common
  conversions. Use the help system to show all options.
</p>
<pre>
  $ Lib.Convert help
</pre>



<h2>Lib.Plot</h2>
<p>
  The Lib.Plot function returns an object with functions for creating a primitive plot, for
  visualizing data. Again, use the help system to examine options.
</p>
<p>
  Note that Lib.Plot is a quick-and-dirty implementation. For better graphs, some external
  package should be invoked.
</p>
<pre>
  File("/tmp/" + currentTimeMillis+".txt")
  /tmpFile

  
  f = tmpFile
  Lib.Data.each(0,720)-&gt;i
    f.append(""+Lib.Math.sin(i) + "," + Lib.Math.cos(i))
  |
  Lib.Plot.typeTimeline.readCSVFile(f).plot(File("out.png"))
  f.delete
  /DemoPlot
</pre>
<p>
  The above code generates an example plot as a png file in the current directory.
</p>










<h1>Command line args</h1>
<p>
  If CFT is invoked with command line arguments, the first is the name of the script,
  that is, a savefile minus the "savefile" prefix and ".txt" ending.
</p>
<p>
 Then follows zero
  or more command lines, on string format. For values containing space or otherwise 
  have meaning to the shell, use quotes. Example:
</p>
<pre>
  ./cft Projects Curr
</pre>
<p>
  This loads script Projects, then calls the Curr function inside.
</p>
<pre>
  ./cft
  ./cft scriptName [commandLines]*
  ./cft -version
  ./cft -help
  ./cft -d scriptDir [scriptName [commandLines]*]?
</pre>






<h1>Environment variables</h1>
<p><i>v2.6.1</i></p>
<p>
  Available via Sys.environment() function.
</p>




<h1>Debugging</h1>
<p>
  In addition to the printDebug("something") statement, there is also implemented a simple
  "lint" function, which operates on current script, checking that all functions parse ok.
</p>
<pre>
  Sys.lint
</pre>





<h1>Working with pasted text lines from stdin</h1>
<p>
  If you've got some text in the copy-paste buffer that you want to work with, the 
  readLines() global functions can be used. It takes one parameter, which is an end-marker, which must 
  occur alone on a line, to mark the end.
</p>
<p>
  The readLines() function returns a list of strings, which you can turn into code and save under
  some function name, using synthesis.
</p>
<pre>
  readLines("XXX")
  (paste or enter text, then enter end-marker manually)
  XXX
  &lt;list&gt;
  0: ...
  1: ...

  :syn
  /someName
  
  ...
</pre>






<h1>Differing between Windows and Linux</h1>
<p>
  Calling function Sys.isWindows() is used to differ between the two in code. It does this
  by checking if (Java) File.separator is a backslash.
</p>
<pre>
  $ Sys.isWindows
  &lt;boolean&gt;
  false
</pre>








<h1>Predicate calls</h1>
<p>
  Example: to decide if a string is an integer, without
  resorting to either creating a built-in predicate function like .isInt, or even
  using regular expression matching, there is the <em>predicate call</em> functionality,
  where one calls a function in a special way, resulting in a boolean value that tells
  if the call was ok or not.
</p>
<p>
  All dotted calls are made into predicate calls, by adding a '?' questionmark between the dot 
  and the function name. 
<pre>
  "sdf".?parseInt
  &lt;boolean&gt;
  false

  "123".?parseInt
  &lt;boolean&gt;
  true
</pre>




<h1>The onLoad function</h1>
<p>
  In order for scripts to run code as the script is loaded, we can define a function
  called onLoad, which is called every time the script file is loaded or reloaded.
</p>





<h1>Error handling</h1>
<p>
  Exception handling in CFT is split into two parts, reflecting two types of
  situations:
</p>
<ol>
  <li>CFT logical or data errors, called <b>soft errors</b></li>
  <li>General errors, stemming from underlying Java code, network situations etc, called <b>hard errors</b></li>
</ol>
</p>
<h2>Soft errors</h2>
<p>
  Soft errors are created by calling the error() function. 
</p>
<p>
  They can be specifically
  caught with tryCatchSoft(), which returns a Dict containing either:
</p>
<pre>
  ok: true
  result: ANY

  or

  ok: false
  msg: string
</pre>
<p>
  Hard errors propagate right through tryCatchSoft().
</p>

<h2>Hard errors</h2>
<p>
  Hard errors are all kind of error situations arising from the Java code running CFT.
</p>
<p> 
  The tryCatch() expression catches both hard and soft errors, and returns a Dict containing
</p>
<pre>
  ok: true
  result: ANY

  or 

  ok: false
  msg: string
  stack: List of string
</pre>
<p>
  An example of a hard error is trying to access a variable or function that doesn't
  exist.
</p>






<h1>Get type of value</h1>
<p>
  The global function getType() takes one parameter, and returns 
  the type name of that value, as a string
</p>
<pre>
  $Â getType(3)
  &lt;String&gt;
  int
  $ getType(Dict)
  &lt;String&gt;
  Dict
</pre>





<h1>Dict set with strings</h1>
<p>
  Reading name-value assignments from a property file or similar, is best done via the .setStr()
  function on the Dict object. It strips whitespace and accepts both colon and '='.
</p>
<pre>
  Dict.setStr("a : b")
  /d
  d.get("a")
  &lt;String&gt;
  b
</pre>
<p>
  To process a property file, assuming commented lines start with '#', we can do 
  this:
</p>
<pre>
  P(1) =&gt;propFile
    Dict =&gt;d
    propFile.read-&gt;line
      reject(line.trim.startsWith("#"))
      assert(line.contains(":") || line.contains("="))
      d.setStr(line)
    |
    d
  /GetProps
</pre>





<h1>Dict.get with default value</h1>
<p>
  The Dict.get() method takes an optional default-value which is returned if no value
  associated with the name, but in that case the default value is <em>also stored</em> in the
  dictionary. 
</p>

<pre>
  data=Dict
  data.get("a",3)  # returns 3
  data.keys        # returns list with "a"
  data.get("a",5)  # returns 3 as it was set above
</pre>




<h1>List.nth() negative indexes</h1>
<p>
  Using negative indexes to List.nth() counts from the end of the list. Using value -1 returns the
  last element, -2 the second last, and so on.
</p>
<pre>
  List(1,2,3,4).nth(-1)
  &lt;int&gt;
  
</pre>




<h1>Function parameters as List or Dict</h1>

<p>
  In addition to grabbing one parameter at a time, using P(pos), we can also process the
  parameter values as a list and as a dictionary.
</p>

<p>
  The function parameter expression P() when used with no parameters, returns a list of
  the parameter values as passed to the function.
</p>

<p>
  The PDict() expression takes a sequence of names to be mapped to parameters by position,
  resulting in a Dict object. Missing values lead to the special value null being stored
  in the dictionary.
</p>





<h1>The general loop statement</h1>
<p>
  In addition to looping over lists, there is a general loop construct. It identifies no
  loop variable, and loops forever, until break() is called. It also obeys assert()
  and reject() as with list iteration. 
</p>
<pre>
  a=0 loop break(a&gt;3) out(a) a=a+1
  &lt;List&gt;
  0
  1
  2
  3
</pre>
<p>
  If you forget to increment the variable a, or forget or create an invalid break(), then
  the loop may never terminate, and CFT has to be killed with ^C
</p>




<h1>Storing CFT data structures to file - syn() and eval()</h1>

<p>
  A  persistent solution for storing data is to store a data structure to file. This is done using
  the synthesis functionality, which is made available as a global function as well as the
  "colon command" used before. This means we can write huge lists and sets of files and
  directory objects to file, and restore it later, without going through possibly time
  consuming computations.
</p>
<p>
  To restore the structure, we use the global eval() function.

<pre>

  P(1)=&gt;file
  P(2,"data") =&gt;data
    file.create(syn(data))
  /saveData

  P(1)=&gt;file
  eval(file.read.nth)
  /restoreData
</pre>
<p>
  This can be used to save arbitrarily big structures, as long as they are synthesizable.
</p>






<h1>The CFT database</h1>
<p><i>v1.9.6</i></p>
<p>
  CFT implements its own primitive database, as found in Lib.Db.Db2, and which is usually
  interfaced via the Db2 script.
</p>
<pre>
  Db2:Set("myCollection", "field", "test")
</pre>
<p>
  The Db2 persists data to file, and handles all values that can be synthesized to code.
</p>
<p>
  Also there is a Db2Obj script, which saves data objects identified by UUID's, which are
  made by calling the Lib.Db.UUID function.
</p>

<h3>Lib.Db.Db2 vs Db2 script?</h3>
<p>
  The Db2 script uses the Lib.Db.Db2 object. The difference is that an object is implemented
  in Java, while the script is code that runs in the interpreter.
</p>





<h1>Objects vs Scripts</h1>
<p>
  As for the case of two Db2 entites above, with a script and an object of the same name,
  this is also the situation for "Lib", where the (global) funciton Lib produces a Lib object, 
  while there also exists a Lib script.
</p>
<p>
  The Lib object, like all CFT objects, has its functions implemented in Java, while the
  Lib script is a text file with functions written in the CFT programming language, which are
  interpreted by Java when called.
</p>
<p>
  Getting information about functions inside objects and scripts differ as follows:
</p>
<pre>
  $ Lib help    # display functions inside object "Lib"
  $ ?Lib:       # display functions inside script
</pre>
<p>
  Calling functions inside objects and libraries differ as well.
</p>
<pre>
  $ Lib.Text               # call function Text inside object
  $Â Lib:Header("Hello")    # call function Header in script
</pre>




<h1>onLoad functions</h1>
<p><i>v2.1.7</i></p>
<p>
  Calling a function onLoad results in it being called every time the script is loaded
  and (automatically) reloaded in GNT. Nice for clearing defaults, when new session.
</p>
<p>
  Each individual session is identified by a session UUID, which may be stored in the
  database, so the onLoad can detect this and reset state in the database.
</p>
<p>
  Below is an onLoad function from the Projects script, which remembers current project
  via the database, but resets it when new session.
<pre>
# Reset selected projects if new session
  if (Db2:Get("Projects","session") != Sys.sessionUUID) {
    Db2:Set("Projects","Project",null)
    Db2:Set("Projects","session", Sys.sessionUUID)
  }
/onLoad
</pre>





<h1>Multitasking in CFT</h1>
<p><b>v1.9.8</b></p>
<p>
  CFT offers the ability to run multiple processes of CFT code, via the SpawnProcess() expression.
</p>
<p>
  It takes two parameters, a context dictionary and an expression. The named values from the 
  context dictionary become local variables when the expression is executed, which takes
  place in a separate process.
</p>
<p>
  The code runs in a virtualized environment. Output is buffered inside the Process object, and
  if the code requires input, it will block, until we supply input lines via the Process
  object.
</p>

<h2>Key concepts</h2>
<p>
  CFT objects (as implemented in Java) are generally not thread-safe, but it turns out that they don't
  need to be, as a running CFT thread has no global state. There are no global variables, only in-function
  local variables.
</p>
<p>
  The only way a CFT thread can maintain persistent (global) state, is using external storage,
  usually via synthesis and eval, such as implemented by the Db2 internal database. What this means
  is of course that data written to Db2 is converted to code. Reading the data back from the database
  means running (eval) that code, and get a newly created data structure. 
</p>
<p>
  Logically, this corresponds to <em>message passing</em>, in that the writer (sender) and reader (receiver)
  of data are loosely coupled, and that any receivers will always create local copies of the data.
</p>
<p>
  Race conditions is still possible with regards to external elements such
  as the file system, FTP servers, other databases, etc.
</p>

<h3>Intended use</h3>
<p>
  It should be added that the intended use of spawning processes in CFT is for parallelizing 
  multiple possibly time consuming jobs, each operating invididually, then collecting the
  results. Typical examples are mass updating tens of virtual machines, as well as getting
  various stats from sets of hosts.
</p>




<h2>The Process</h2>
<p>
  The Process object represents a separately running thread, executing some CFT expression, in a
  separate environment. Its standard I/O is virtualized by the Process object.
</p>
<p>
  Listing Process functions:
</p>
<pre>
  $ SpawnProcess(Dict,1) help

  # close() - close stdin for process
  # data() - returns the (original) context dictionary
  # exitValue() - returns exit value or null if still running
  # isAlive() - true if process running
  # isDone() - true if process completed running
  # output() - get buffered output lines
  # sendLine(line) - send input line to process
  # wait() - wait for process to terminate - returns self
</pre>


<h2>Example: pinging a list of hosts</h2>
<p>
  The following example show how we can perform system monitoring efficiently using
  SpawnProcess.
</p>
<p>
  This example is about pinging a set of servers, to see which are up. We start by creating
  a function for this, and testing it manually.
</p>


<h3>Create and test regular ping function</h3>
<p>
  It is okay to print out a lot of stuff, as all of that will be collected when 
  calling function inside a Process. We will log that to the database if 
  function returns false. 
</p>
<pre>
# Ping host, return boolean (true if ok)
# --
  P(1)=&gt;host
  println("Pinging host " + host)
  Lib:run(List("ping","-c","1",host), List, true) => res
  if (res.exitCode==0) {
    true
  } else {
    println("FAILED with exitCode=" + res.exitCode)
    Inner {
      res.stdout-&gt;line println(line) |
      res.stderr-&gt;line println("#ERR# " + line) |
    }
    false
  }
/ping
</pre>
<p>
  After testing the function, we go on to create the function that manages the processes.
</p>

<h3>Management function, with logging via Db2Obj database script</h3>
<p>
  We now create a function Hosts, which returns a list of the hosts to check, and then
  the function CheckPing, which iterates over these. 
</p>
<pre>
"s01.s s02.s s03.s s04.s s05.s s06.s s07.s".split
/Hosts

# Delete previous ping stats from database, then run ping on all
# hosts in parallel, collecting results and store in database.
# --
  COLLECTION="stats"  ## Database collection name
  
  # Clear out results from earlier runs, if any
  # --
  Db2Obj:DeleteObjects(COLLECTION, Lambda{P(1).value.op=="ping"})
  
  # Iterate over hosts
  # --
  Hosts-&gt;host
    # Start individual processes, each calling the ping function with a host
    # --
    data=Dict.set("host",host)
    proc=SpawnProcess(data,ping(host))
    out(proc)
  | _-&gt;proc
    # Wait for each process in turn, and collect results
    # --
    proc.wait
    dbObj=Dict
      .set("op","ping")
      .set("host", proc.data.host)  # the data dict from SpawnProcess
      .set("ok",proc.exitValue)
    if (proc.exitValue==false) {
      # failed
      dbObj.set("output", proc.output)
    }
    # Log everything to database
    # --
    Db2Obj:AddObject(COLLECTION, dbObj)
/CheckPing
</pre>
<p>
  The CheckPing function iterates over the hosts, and for each calls SpawnProcess, with the
  host stored in the context data Dict object. This generates a Process object, which is
  is sent on with the out() statement.
</p>
<p> 
  After the PIPE we now are working with a list of Process objects, which we iterate over,
  and for each, first wait for it finish, then pick values from it, building a dbObj Dict
  with relevant information. THe field "op"="ping" is what is used to identify these
  data, for the initial call to DbObj:DeleteObjects() where we delete any previous stats,
  from earlier runs.
</p>

<h3>Checking results (in database)</h3>
<p>
  After this has run, we look at the data in the "stats" collection:
</p>
<pre>
$ Db2Obj:ShowFields("stats",List("host","ok"))
  &lt;List&gt;
   0: 2020-11-05 22:48:44 | s01.s | true
   1: 2020-11-05 22:48:44 | s02.s | true
   2: 2020-11-05 22:48:44 | s03.s | true
   3: 2020-11-05 22:48:47 | s04.s | false
   4: 2020-11-05 22:48:47 | s05.s | true
   5: 2020-11-05 22:48:47 | s06.s | true
   6: 2020-11-05 22:48:47 | s07.s | false
</pre>
<p>
  Here we list fields "host" and "ok" from the objects. We see that hosts "s04.s" and "s07.s" 
  failed. We now check the output log for "s04.s".
</p>
<pre>
$ Db2Obj:FindObjects("stats",Lambda{P(1).value.host=="s04.s"}).first.value.output
  &lt;List&gt;
   0: Pinging host s04.s
   1: FAILED with exitCode=1
   2: PING s04.s (10.0.11.41) 56(84) bytes of data.
   3: From 10.0.0.84 (10.0.0.84) icmp_seq=1 Destination Host Unreachable
   4: 
   5: --- s04.s ping statistics ---
   6: 1 packets transmitted, 0 received, +1 errors, 100% packet loss, time 0ms
   7: 
</pre>

<h2>Advantages</h2>
<p>
  The run time of this code should be that of the host that takes the longest
  time to ping (or fail to ping). 
</p>
<p>
  Collecting stdout from the Process means that the code that does the work (like 
  our ping() function) can just print progress and status data via println(), which makes 
  the code easy to test separately.
</p>
<p>
  Processes also offer full protection from exceptions of all kinds, as they
  are caught and listed in full inside the Process.
</p>


<h2>Flow control</h2>
<p>
  In some cases, the number of processes can be huge, and we may need to limit the
  number of active processes. This is done via a function in the Util script, that
  returns an <i>object</i> which we use as follows. The names "Lxxx" are used to
  help indicate that they contain lambdas (though strictly they are closures).
</p>
<pre>
  # -- Create monitor, decide max parallel processes
  mon=Util:ProcessMonitor   
  limit=4

  someData-&gt;data
    # About to spawn new process using data

    mon.Lwait.call (limit)
    proc=SpawnProcess(SymDict(data), ...)
    mon.Ladd.call(proc)
  |
  # Wait for all processes to complete
  mon.Lwait.call

  # Inspect result from the processes
  mon.list-&gt;process
     ...
  |
</pre>
<p>
  The mon.Lwait lambda waits until number of running processes comes below the limit,
  before returning. 
</p>
<p>
  See separate sections on closures and objects.
</p>





<h1>Calling Java</h1>
<p><i>v2.7.0</i></p>
<p>
  CFT lets us interface Java code via the Lib.Java object. It contains functions
  for identifying classes. We then look up a constructor and call it, getting a
  JavaObject in return. We can also look up methods from the class object, and call
  them with parameters. 
</p>
<p>
  Currently, for this to work, the Java code must exist in the classpath.
</p>
<p>
  Example (also available in script Tests01 as function Test17):
</p>
<pre>
Lib.Java.forName("java.lang.String") =&gt; String
String.getConstructor(String).call(Lib.Java.String("test")) =&gt; obj
String.getConstructor(String).call(Lib.Java.String("123")) =&gt; obj2
Lib.Java.Object(obj2) =&gt; paramObj
String.getMethod("concat",String).call(obj,paramObj).value
/t17
</pre>
<p>
  This function looks up the String class, then creates two instances via
  the constructor that takes a String parameter. CFT strings values are converted to Java values
  via the Lib.Java.String() function. 
</p>
<p>
  Then we wrap obj2, which is a CFT value (of type JavaObject), as a Java value, 
  via Lib.Java.Object(), and locate the concat() method of the String class.
</p>
<p>
  It is invoked on
  obj, with obj2 as parameter. The method call returns a JavaValue object,
  which has a function value() that returns a CFT value, in this case the 
  concatenated string "test123".
</p>




<h1>String .esc() and .unEsc()</h1>
<p>
  As was mentioned initially, CFT doesn't use backslash as an escape character. 
  However, we still require a way of converting "difficult" strings to code,
  via synthesis. For this purpose, the two functions String.esc() and String.unEsc() was
  created.
</p>
<p>
  One rarely needs to call these manually, but they are worth mentioning, as sometimes synthesis
  of a string may result in code such as this:
</p>
<pre>
  "^q^aa^a^q".unEsc
</pre>



<h2>Escape codes</h2>
<p>
  For an escaped string, the escape character is the ^ symbol.
</p>
<ul>
  <li>"Double quotes" ^q</li>
  <li>'Single quotes' / Apostrophe ^a</li>
  <li>Newline ^n</li>
  <li>Carriage Return ^r</li>
  <li>Tab ^t</li>
  <li>The ^ symbol ^^</li>
</ul>
<p>
  This gives a way of creating strings with newlines inside.
</p>
<pre>
  "this^nis^na test".unEsc

  &lt;String&gt;
  this
  is
  a test 
</pre>


<h3>Note: CRLF / LF with text files ...</h3>
<p>
  Note that when creating a text file using global function File(...) or via Dir.file(...), 
  the default end-of-line mark is used (CRLF for windows, LF for Linux). To overrule this,
  the File object has two functions:
</p>
<pre>
  someFile.setWriteCRLF
  someFile.setWriteLF
</pre>


<h1>Automating interactive functions / Sys.stdin()</h1>
<p>
  Functions may query the user with Input("prompt").get and readLine("prompt"). If we want
  to automate such functions, we use function Sys.stdin() to buffer up any number of 
  input lines. 
</p>
<pre>
  Sys.stdin("read-this") Input("Enter data").get
  &lt;String&gt;
  read-this
</pre>
<p>
  Note that both Input.get() and readLine() detect if there is buffered input, and
  if so, do not display the prompt or other info. Particularly useful for Input.get(),
  since buffering the empty string "" with Sys.stdin() means repeating the last value.
</p>




<h2>Running colon commands from script code</h2>
<p>
  Using the Sys.stdin() statement without being followed by Input.get() or readLine(), is just 
  another way of entering commands. This means colon commands are available from CFT code.
</p>
<pre>
  stdin("2+3")
  &lt;int&gt;
  5
</pre>
<p>
  This can be exploited to let a script modify itself, by redefining
  functions, although that will be troublesome if those functions read input. A better
  use is that of running colon commands, particularly loading scripts. This is used
  frequently with shortcuts.
</p>
<pre>
  stdin(":load SomeScript","?")
</pre>




<h1>Clone any value</h1>
<p>
  The function Sys.clone() returns a copy of any value, as long as it is 
  synthesizable. If not, an error is returned. 
</p>
<pre>
  a=List(1,2,3)
  b=Sys.clone(a).add(4)  # b contains 1,2,3,4 while a remains unchanged
</pre>








<h1>CFT.props - mCat, mEdit and mMore lambdas</h1>
<p>
  The configuration fields mCat, mEdit and mMore ("m" for macro) define lambdas
  that are called for interactive commands cat/edit/more. This means it is possible
  to redefine what edit means. Currently, mEdit calls either "Lib:e". The
  mMore lambda calls "Lib:m", while the mCat macro just calls .read on file parameter.
</p>





<h1>CFT.props - shortcuts</h1>
<p>
  The CFT.props text is self explanatory.
</p>
<pre>
# Shortcuts
#
# The shortcuts are lines of code. If that code results in a macro, it is invoked with
# no parameters. Since we don't need parameters, there is really no need for macros
# here. The return value from a shortcut becomes the "last value", available
# via Sys.lastResult, as well as used by :syn etc
#
# Note that shortcuts only work when the prefix is at the start of the interactive
# input line. 
# ---
shortcutPrefix = @

shortcut:r = Sys.stdin(":load Release","?")
shortcut:p = Sys.stdin(":load Projects","?")

# List available shortcuts when typing '@' only
# ---
shortcut: = File("CFT.props").read-gt;line assert(line.contains("shortcut:")) out(line)
</pre>
<p>
  This means that typing @r loads the Release script, then executes the '?' command, which
  lists its content.
</p>

<h3>Show all shortcuts</h3>
<p>
  To list defined shortcut, just type 
</p>
<pre>
  $ @
</pre>
<p>
  This is a shortcut itself, that traverses the CFT.props file and identifies and 
  displays the
  shortcut definitions from it.
</p>







<h1>Some example code</h1>

<h2>Windows PowerShell</h2>
<p>
  The following code is an effective way of using PowerShell from CFT, saving lots of typing.
</p>
<pre>
  # Run remote PowerShell script-block
    host=P(1) 
    cmd=P(2)  
    fullCmd = List("powershell","invoke-command","-computername",host,"-scriptblock","{" + cmd + "}")
    Dir.run(fullCmd)
  /PSRun

  # List services via PowerShell (interactive)
    host = Input("Host").get
    Input("Service name (including wildcards)").get =service
    cmd = "get-service -name " + service  # no splitting
    PSRun(host, cmd)
  /PSGetService

</pre>


<h2>Windows CMD</h2>
<p>
  Running commands using CMD in windows, mostly requires the "/c" flag.
</p>
<pre>
  Dir("...")
  /DirProject

  # Add, commit and push with git
    DirProject.run("cmd","/c","git","add",".")
    msg=Input("Commit message").get
    DirProject.run("cmd","/c","git","commit","-m",msg)
    DirProject.run("cmd","/c","git","push","origin","master")
  /GitPush
</pre>




<h1>Lib.Text.Lexer</h1>
<p>
  <i>v1.3.2</i>
</p>
<p>
  The Lib.Text.Lexer objects adds 
  capability to match complex tokens with CFT, using the same Java tokenizer that is used when
  parsing CFT script code. 
</p>
<h2>Motivation</h2>
<p>
  Working with log data, it would be nice identifying data in log lines beyond
  doing free text searches. The Lexer is the first step, and will in time be followed by 
  some more classes, including a basic recursive-descent parser.
</p>

<h2>Concept</h2>
<p>
  The concept is that of a tree of maps, each map maps single characters to other maps, and so on.
  If map A contains mapping of digits 0-9 pointing at map B, and our parse process so far has led 
  us to map A, with next input character being 0,1,2,3..., then that character is "consumed", which is
  fancy speak for matched, and the current map becomes B. The process then repeates.
</p>
<p>
  If the current map has no mapping for the current next character, then one of the following happen:
</p>
<ol>
  <li>If the current map is marked with "this is a token", then parsing succeeds</li>
  <li>Otherwise, we backtrack, unconsuming previourly consumed characters, until finding a map that "is a token"</li>
  <lI>Or ,if no map in our parse tree has the "this is a token" mark set, then parsing fails</li>
</ol>


<h2>Implementation</h2>
<p>
  In the CFT functions, such maps are called nodes. They are created via the
  Lib.Text.Lexer.Node function.
</p>
<pre>
  $ Lib.Text.Lexer help
  
  # Node(firstChars?) - create empty node, possibly identifying firstChars list
  # addLine(line) - processes line, adds to internal token list - returns self
  # getTokenStream(rootNode) - get TokenStream object
  # getTokens(rootNode) - get list of tokens
</pre>
<p>
  The nodes in turn contain the following:
</p>
<pre>
  $ Lib.Text.Lexer.Node help

  # addToken(token) - create mappings for token string, returns resulting Node
  # addTokenComplex(token, charMapDict) - create mappings for complex string, returns resulting Node
  # setDefault(targetNode?) - map all non-specified characters to node, returns target node
  # setIsToken(tokenType?) - tokenType is an int, which defaults to 0 - returns self
  # sub(chars, targetNode) or sub(chars) or sub(targetNode) - add mapping, returns target Node
</pre>
<p>
  A simple example:
</p>
<pre>
  top=Lib.Text.Lexer.Node
  x=top.sub("0123456789")   # new node
  x.sub("0123456789",x)  # x points to itself for digits
  x.setIsToken(1) # token type: non-negative numbers for regular tokens

  top.match("300xx")  # returns 3, matching sequence '300'
</pre>
<p>
  The match() function is for testing only.
</p>



<h3>.sub()</h3>
<p>
  The sub() function of any node is used to connect pointers from one map to another. It takes 
  three forms:
</p>
<pre>
  (1)
  someNode.sub("abc",someOtherNode)  
    # when at someNode and one of the characters ("abc") are next character in input
    # string, then consume character, and move to that other node, which may of course
    # be the same node or some other node

  (2)
  someNode.sub("abc")
    # When no node parameter, an empty node is created, which "abc" points to from
    # someNode. The new node is returned

  (3)
  someNode.sub(someOtherNode)
    # When creating libraries of reusable nodes, they always must define a set of
    # characters which are called "firstChars". These are the characters that indicate
    # the start of some sort of data. For example for Lib.Text.Lexer.Identifier, the
    # "firstChars" are "a-zA-Z_". It's the letters an identifier can start
    # with. Similarly we can create our own library node functions, by supplying a
    # firstChars list as parameter to Lib.Text.Lexer.Node
    #
    # So what happens is that inside someNode, pointers are added to someOtherNode for
    # all characters in that node's firstChars.
</pre>


<h2>Reusable nodes - integer sequence</h2>
<p>
  To create a reusable node, we need to specify the "firstChars" of a node, which are given
  as parameter when creating an Node node. This means adding it as "sub" under some other node,
  lets those characters point at it.
</p>

<pre>
  # Create reusable node for integers. 
    "0123456789"=&gt;digits
    Lib.Text.Lexer.Node(digits) =&gt;x
    x.sub(digits,x)
    x.setIsToken(1)

    x
  /NodeInt

  # Now we can for example match a IP v4 address
    Lib.Text.Lexer.Node =top
    a=NodeInt
    b=NodeInt
    c=NodeInt
    d=NodeInt
    
    top.sub(a)
    a.sub(".").sub(b) # creates intermediary nodes for the dots
    b.sub(".").sub(c)
    c.sub(".").sub(d)
    d.setIsToken(2)

    top
  /MatchIPAddress

  # Test
  "192.168.1.1 255.255.x 10.0.0.1 1.2.3 .4".split-&gt;word
    report(word, MatchIPAddress.match(word))
    # should return 11,0,8,0,0
  /t1
</pre>


<h2>Processing single lines</h2>
<p>
  To process all text in a line, we need to build a root node to which we add
  pointers to sub-nodes for all valid tokens. For simplicity, let us match only
  identifiers.
</p>
<p>
  Since identifiers are separated by space, we also need to match
  whitespace. Since we are not interested in whitespace, we assign whitespace 
  tokens a negative token type, as those get automatically ignored.
</p>
<pre>
# Identifiers
  "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_" =&gt;firstChars
  firstChars+"0123456789" =&gt;innerChars
  
  ident = Lib.Text.Lexer.Node(firstChars)
  ident.sub(innerChars,ident)
  ident.setIsToken(1)
  
  ident
/Identifiers

# Whitespace
  " ^t^n^r".unEsc =&gt;chars
  Lib.Text.Lexer.Node(chars) =&gt;ws
  ws.sub(chars,ws)
  ws.setIsToken(-1)
    
  ws
/WhitesSpace

# Root node
  Lib.Text.Lexer.Node =&gt;root
  root.sub(Identifiers)
  root.sub(WhiteSpace)
/Root
</pre>
<p>
  With the Root node ready, we can now parse strings consisting of identifiers and space, 
  ignoring space.
</p>
<pre>
# Test
  Lib.Text.Lexer.addLine("this is a test").getTokens(Root)->token
    report(token.sourceLocation, token.str, token.tokenType)
/test
</pre>
<p>
  Now running the test we get
</p>
<pre>
  $ test
  &lt;List&gt;
   0: pos=1  | this | 1
   1: pos=6  | is   | 1
   2: pos=9  | a    | 1
   3: pos=11 | test | 1
</pre>



<h2>Limitations</h2>
<p>
  As there is at most one pointer per character in each node, we can not both recognize
  identifiers AND certain keywords, such as "begin" and "end", separately. Unless of course
  the keywords start with a different sequence of characters in front, that make them
  unique from identifiers.
</p>
<p>
  With the "symbols" we can easily recognize both "=" and "==" as symbols, because the second
  is an extension of the first, and the "=" node is not configured to match any stream
  of "=", such as identifiers are for letters and numbers.
</p>
<p>
  This also means we can not both match integer and dates on numeric format, such as
</p>
<pre>
  2020   # integer
  2020-09-12   # date
</pre>

<h2>Different uses</h2>
<p>
  Parsing a programming language or JSON structure, requires us to identify every
  token in the string. The lexer tree must house them all.
</p>
<p>
  Parsing a log line piece by piece does not have this requirement. Different 
  lexer nodes may be used for each part of the line, some allowing for alternatives,
  most just looking to match a fixed format string, for which regular expressions
  would also be suited.
</p>


<h2>Complex tokens</h2>
<p>
  For the case where we want to identify parts of a log line, one token at a time, 
  individual token definitions may not co-exist under a shared root, but that is
  exactly the point: we have clear expectations for what we look for, at any time.
</p>
<p>
  The Node.addTokenComplex() function is not one that lives happily together with
  others.
</p>

<h3>Regular Node.addToken() example</h3>
<p>
  With the normal .addToken() function, we can do something like this:
</p>
<pre>
  Lib.Text.Node =&gt;grade
  "A AA AAA B C".split->x grade.addToken(x).setIsToken
</pre>
<p>
  Overlapping definitions, such as "A" and "AA" and "AAA" is not a problem for Node.addToken()
</p>




<h3>Node.addTokenComplex() example</h3>
<p>
  This function adds a token, where some of the characters in the token string map to 
  sets of characters, via a Dict object. This function does not have the freedom to
  expand and reuse existing (overlapping) nodes, as with the regular .addToken() function.
</p>
<p>
  It is meant for matching one thing only, and not for collecting all token definitions
  under a shared root, as before. 
</p>
<pre>
  Lib.Text.Node =&gt;date
  Dict.set("i","0123456789") =&gt;mappings
  date.setTokenComplex("iiii-ii-ii", mappings).setIsToken

  date.match("2020-09-15xxx")  # returns 10 (characters matched)
  date.match("2020-009-15xxx") # returns 0 (no match)
</pre>
<p>
  Feels like Regex character classes, no?
</p>






<h1>Closures</h1>
<p><i>v1.3.1</i></p>
<p>
  A closure is created by binding a Lambda to a Dict object. The Closure
  has a .call function just like the Lambda, and invokes the lambda, with
  the Dict object referenced via "self" variable.
</p>
<p>
  Nice for event based callbacks.
</p>
<pre>
  Dict =&gt;data
  data.bind(Lambda{
    self.set("received_value", P(1))
  }) =&gt;closure

  closure.call("test")
  data.get("received_value")  # returns "test"
</pre>
<p>
  For robustness and testing, when lambdas are run directly (not via closures)
  there is also a "self" variable, which points at an empty Dict object.
</p>
<h2>Another example</h2>
<p>
  Here we create a Closure that when called strips N characters from the
  start and end of a string.
</p>
<pre>
  P(1)=&gt;n
  Dict.set("n",n).bind(Lambda{
    P(1)=&gt;s 
    self.get("n")=&gt;n
    s.sub(n,s.length-n)
  })
/Strip
</pre>
<p>
  Test:
</p>
<pre>
  $ Strip(2).call("this is a test")
  &lt;String&gt;
  is is a te
</pre>





<h1>Closures v2 - Objects</h1>
<p><i>v1.7.5</i></p>
<p>
  Letting the dictionary .set function detect lambdas, they are automatically wrapped inside
  closures, with "self" pointing to the dictionary in question.
</p>
<p>
   This means we can now do this:
</p>
<pre>
Dict
  .set("i",1)
  .set("incr",Lambda{
    amount=P(1,1)
    self.set("i",self.i+amount)
  })
  =&gt;data

  data.incr.call(10) # data.i is now 11
  println(data.i)
/test
</pre>



<h2>Member lambdas calling each other</h2>
<p>
  The mechanism of letting individual "member" lambdas have a shared idea of "self", also allows for this:
</p>
<pre>
Dict
  .set("i",1)
  .set("incr",Lambda{
    amount=P(1,1)
    self.set("i",self.i+amount)
  })
  .set("incr50",Lambda{
    self.incr.call(50)
  })
  =&gt;data

  data.incr50.call  # data.i is now 51
  println(data.i)
/test
</pre>
<p>
  The incr50 lambda calls the incr lambda within the environment defined by the Dict object.
</p>




<h2>Copy lambdas between dictionaries</h2>
<p>
  The Dict.set function also detects when it is fed a closure, unwrapping the
  Lambda inside, then wrapping it inside a new closure pointing back to 
  itself (via "self" variable in lambda).
</p>



<h2>Lambdas are synthesizable</h2>
<p>
  This means we can store function code in the database, or on file. 
</p>
<p>
  Also, Dict objects (with lambdas) are serializable, because even though Closures are not,
  the serialization of a Dict with Closures is rewritten into adding the original
  Lambda's which will in turn be wrapped into Closures at later runtime.
</p>
<p>
  This means stateful objects can be "serialized" to the database as well. 
</p>







<h1>ANSI escape codes</h1>
<p><b>v2.1.2</b></p>
<p>
  The Curses script contains code for producing ANSI escape sequences to set text color, 
  bold and underline, as well as clearing the screen, and moving the cursor, which
  enables drawing boxes, for example.
</p>
<p>
  Since curses may not be supported on every device, the ANSI support is disabled
  by default, but can be enabled
  via a call to 
</p>
<pre>
  Curses:Enable(true)
</pre>
  This changes all the functions inside Curses from returning empty strings, to return ANSI escape sequences.
</p>








<h1>Passwords, encryption, binary data</h1>
<p><b>v2.2.0</b></p>
<h2>Passwords</h2>
<p>
  To read a password (no echo), call Sys.readPassword function.
</p>



<h3>Encrypt / decrypt</h3>
<p>
  The Lib.Util object contains two functions, encrypt() and decrypt(), which both
  take a password string and a salt string. These together form a complete
  password, but the salt is not necessarily secret, just a way of differently initiate
  the encryption engine with the same (secret) password.
</p>
<pre>
  "password".getBytes("UTF-8")  # returns Binary object
  /password

  Lib.Util.Encrypt(password).processString("this is a message")
  /x
  Lib.Util.Decrypt(password).processString(x)
  &lt;String&gt;
  this is a message
</pre>



<h3>Binary data</h3>
<p>
  The processString() function of the Encrypt and Decrypt objects, is nice when
  storing encrypted strings in a database that only handles strings, such as Db2.
</p>
<p>
  The more generic function process() operates on binary data, and lets us
  save encrypted versions of files.
</p>
<pre>
  File("x.txt").readBinary             # returns Binary
  "some string".getBytes("UTF-8")      # returns Binary

  File("x.txt").binaryCreate(binary)
  &lt;someBinary&gt;.toString("UTF-8")
</pre>



<h3>Session data</h3>
<p>
  In addition to the public Sys.getSessionUUID, there is a secure value returned by
  Sys.getSecureSessionID(). It is a secure Binary object, which means it has no
  functions, and can only be passed as parameter to system functions, like encryption.
</p>

<p>
  See Db2:GetSessionPassword() function for example.
</p>




<h1>Reference: object types</h1>
<pre>
Grep("extends Obj") => g
Sys.homeDir.allFiles(Glob("*.java"))->f
  g.file(f)->line
  out(line.after("class").before("extends"))
| _.sort->x
  println(x)
/objects


ObjClosure 
ObjConvert 
ObjDD 
ObjData 
ObjDataFile 
ObjDate 
ObjDateSort 
ObjDb 
ObjDb2 
ObjDict 
ObjDir 
ObjDuration 
ObjEncrypt 
ObjExtProcess 
ObjFile 
ObjFiles 
ObjFilter 
ObjFilterReader 
ObjGlob 
ObjGlobal 
ObjGrep 
ObjInput 
ObjIntegrations 
ObjJava 
ObjJavaClass 
ObjJavaConstructor 
ObjJavaMethod 
ObjJavaObject 
ObjJavaValue 
ObjJavaValueBoolean 
ObjJavaValueInt 
ObjJavaValueLong 
ObjJavaValueNull 
ObjJavaValueObject 
ObjJavaValueString 
ObjLexer 
ObjLexerNode 
ObjLexerToken 
ObjLexerTokenStream 
ObjLib 
ObjLineReader 
ObjMSSql 
ObjMSSqlConnection 
ObjMSSqlParam 
ObjMSSqlResultSet 
ObjMath 
ObjPersistent 
ObjPlot 
ObjProcess 
ObjRegex 
ObjSentry 
ObjSys 
ObjTerm 
ObjText 
ObjUtil 
ObjVec2D 
Value 
</pre>


<h1>Reference: Value types</h1>
<pre>
Grep("extends Value") => g
Sys.homeDir.allFiles(Glob("*.java"))->f
  g.file(f)->line
  out(line.after("class").before("extends"))
| _.sort->x
  println(x)
/values


ValueBinary 
ValueBlock 
ValueBoolean 
ValueFloat 
ValueInt 
ValueList 
ValueNull 
ValueObj 
ValueObjFileLine 
ValueObjFloat 
ValueObjInt 
ValueObjStr 
ValueString 
</pre> 


<h1>Reference: Expressions vs statements</h1>
<p>
  Almost all code in CFT are expressions. Function calls are of course expressions, and so are assignments.
</p>

<p>
  Even blocks, both local and Inner, are expressions.
</p>

<p>
  Instead of describing all expressions, it is easier to list the statements.
</p>

<h2>Statements</h2>
<p>
  These are the statements in CFT:
</p>
<ul>
  <li>Looping and iteration over lists</li>
  <li>assert/reject/break</li>
  <li>out(), condOut() and report()</li>
  <li>the printDebug() command</li>
  <li>the help command</li>
  <li>interactive commands "cat", "edit", "ls", "cd"</li>
  <li>the "showCode" command</li>
</ul>
<p>
  <i>v2.7.3</i> Added global function _Stmt that displays 
  info about statements in CFT.
</p>












<h1>Reference: Colon commands</h1>
<p>
  Colon commands are best described by entering a single colon at the CFT prompt.
</p>

<pre>
$ :

Colon commands
--------------
:save [ident]?           - save script
:load [ident]?           - load script
:new                     - create new empty script
:sw [ident]?             - switch between loaded scripts
:delete ident [, ident]* - delete function(s)
:copy ident ident        - copy function
:wrap                    - line wrap on/off
:debug                   - enter or leave debug mode
:syn                     - synthesize last result
:&lt;int&gt;                   - synthesize a row from last result (must be list)
:quit                    - terminate CFT

</pre>
<p>
  Confusing colon commands with shortcuts? 
</p>
<p>
  Colon commands exist outside the language, and are fixed (written in Java), while shortcuts run CFT program
  code, and are defined in the CFT.props file. So far all good.
</p>
<p>
  The "problem" is that CFT code (and so shortcuts) can run colon commands via "abusing" the Sys.stdin() command.
</p>





<h1>Reference: Synthesizable types</h1>
<ul>
  <li>boolean</li>
  <li>int</li>
  <li>float</li>
  <li>string</li>
  <li>null</li>
  <li>List</li>
  <li>Dir</li>
  <li>File</li>
  <li>FileLine</li>
  <li>Date</li>
  <li>Date.Duration</li>
  <li>Int</li>
  <li>Float</li>
  <li>Str</li>
  <li>Dict</li>
  <li>Glob</li>
  <li>Regex</li>
  <li>Lambda</li>
</ul>






<h1>Comments and digressions</h1>


<h2>Function name AFTER code?</h2>
<pre>
  Dir.files
  /showFiles
</pre>
<p>
  This stems back to the time of entering code line by line. Having to decide the name of a function before
  seeing how much functionality you got crammed into one line, or if it at all worked,
  made little sense. Instead you write some code
  that does something useful, then decides what to call it.
</p>
<p>
  This might at some point be changed, at least for script files, as it still feels backward, but this 
  is the reason. 
</p>
<p>
  The syntax with the slash and an identifier was inspired by PostScript.
</p>
<p>
  Another issue is how to integrate or maintain the use of the P() function for
  parameter processing, which feels superior to what one can do in a
  more traditional format:
</p>
<pre>
  function X (a,b) { ... }
</pre>



<h2>Using Sys.stdin to run colon commands etc</h2>
<p>
  This functionality is an example of an "unexpected feature", as the Sys.stdin() was created to automate 
  functions that used
  Input and readLine(). There was a moment of confusion when discovering what happened to input lines not consumed
  by those interactive functions.
</p>




<h2>Code spaces / the "pipe"</h2>
<p>
  This all stems from the "one-line-at-a-time" period, where scripts were entered from
  the command line, at a time long before introducing block expressions. Being a fairly compact
  and efficient notation, and frequently used, code spaces and the "pipe" symbol will
  remain in the language.
</p>




<h2>Script and code size</h2>

<h3>2020-11-13</h3>
<pre>
  Script code:      ~5k lines
  Java code:        ~20k lines
  Functions:        ~290
  Object types:     ~45 (including Value types)
</pre>

<h3>2021-04-01</h3>
<pre>
  Script code:      ~8k lines
  Java code:        ~21k lines
  Functions:        317
  Object types:     36
  Value types:      12
</pre>

<h3>2021-09-26</h3>
<p>Created CodeStats script:</p>
<pre>
  Script code:      10922 lines
  Java code:        23907 lines
  Functions:        377
  Object types:     57
  Value types:      13
</pre>  






<h2>Poor man's EXIF date parser</h2>
<p>
  Need to sort camera photos by date? JPG files created by a camera, or via image processing
  software like Darktable, LightRoom and so on, will contain an initial block of metadata
  called EXIF, which contains numerous fields and values, and which may occupy up to 
  64 Kb at the start of the file.
</p>
<p>
  Not having written or included any third party implementation for parsing the EXIF data,
  the easy solution was to implement a function printableChars in the Binary value type, and
  search for dates using the Lib.Text.Lexer.
</p>
<p>
  The Lib.Text.Lexer.Node has support for "complex tokens", where we define a character
  string like "dddd-dd-dd", and then define what each chacter means, so that "d" may map
  to "0123456789", while letting "-" map only to itself.
</p>
<p>
  A utility function Util:ComplexPatternLineSearch was created for managing the details.
</p>

<pre>
  # Get EXIF date (as Date object) or return null
  # --
    P(1) => jpegFile

    pattern = "dddd:dd:dd"
    map = Dict.set("d","0123456789").set(":",":")

    str = jpegFile.readBinary(0,64*1024).printableChars
    date = Util:CompledPatternLineSearh(printableChars, pattern, map).first

    if (date != null) {
      Date.setFormat("yyyy:MM:dd").parse(date)
    } else {
      null
    }
  /GetJpgExifDate
</pre>


</body></html>

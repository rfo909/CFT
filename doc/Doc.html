<html>
<head>

<style type="text/css">
	* {font-family: arial}
	pre {font-family:courier; margin-left:1Em; padding-left: 1Em; font-size: 16pt}
	h1 {padding-top:1Em; color: blue}
</style>
</head>
<body>

<h1 style="padding-left:0; margin-left:0; font-size:24pt; font-family:monospace; color:black">
CFT / ConfigTool
</h1>

<pre style="padding-left:0; margin-left:0">

Last updated: 2020-11-04 RFO
v1.9.8

</pre>

<h1>Introduction</h1>

<p>
  CFT is an interactive programmable environment for automation.
</p>
<p>
  Automating tasks is done by creating functions, which are named sequences
  of code. Functions call each other, as well as a library of global functions, and functions
  inside system objects, such as:
</p>
<ul>
  <li>directories</li>
  <li>files</li>
  <li>lists</li>
  <li>dictionaries</li>
</ul>
<p>
  CFT is tested on Linux and Windows, and easily integrates with external commands
  on both, such as PowerShell, git, ssh. It should run anywhere that supports Java.
</p>

<p>
  Development has been going on since May 2018, and on github since July 2020.
</p>



<h1>Functionality</h1>
<p>
  The CFT programming language is a glue between library functions and -objects, user input, and 
  running external programs.
</p>
<p>
  It is command line based, but complex functions are created using editors.
<p>
  The language is object oriented, with all values being objects. Here we call a
  function "bin()" inside an integer object. 
</p>
<pre>
  $ 1.bin
  &lt;String&gt;
  00000001
</pre>
<p>
  The ".bin" calls the function "bin" inside the integer object. Parantheses are optional when no parameters.
</p>

<h2>Another example</h2>
<pre>
  $ Dir.files.length
  &lt;int&gt;
  12
</pre>
<ol>
  <li>The "Dir" global function returns the current directory as a Dir-object</li>
  <li>We call the "files" function in the directory object, it returns a list object</li>
  <li>We call the "length" function in the list object, it returns an int object</li>
</ol>

<h1>Getting help</h1>

<h2>Show all global functions</h2>
<pre>
  $ help
</pre>


<h2>Show functions inside objects</h2>
<p>
  To show all functions inside an object, create an instance of that object followed by the word help. 
  Specifically, the help statement takes the value on top of the stack and lists it's available
  functions.
</p>
<pre>
  $ 1 help               # integer
  $ 3.14 help            # float
  $ "xxx" help           # string
  $ List help
  $ Dict help
  $ Dir help
  $ File("x.txt") help   # the file needs not exist
</pre>



<h1>Create functions</h1>
<p>
  Everything you type in at the prompt is considered code, and executed.
</p>
<p>
  Then, if you want, you can assign a name to the last line of code, and now you have a function.
</p>
<pre>
  $ Dir.files.length
  &lt;int&gt;
  12
  $ /filesInDir
</pre>
<p>
  The code line that gives us the number of files in the current directory is now named "filesInDir", and can
  be run again as follows:
</p>
<pre>
  $ filesInDir
  &lt;int&gt;
  12
</pre>





<h1>Show your functions</h1>
<p>
  List all functions in current script
</p>
<pre>
  $ ?
</pre>
<p>
  To show the code of a function:
</p>
<pre>
  $ ? name
</pre>
<p>
  If the name doesn't match one function, it is used as a prefix to list a subset
  of all functions.
</p>



<h1>Save and load</h1>
<p>
  Functions are saved into script files, via "colon" commands, which are system commands outside
  the CFT language.
</p>
<pre>
  $ :save myscript
  $ :load otherscript
</pre>



<h1>Edit script file</h1>
<p>
  Instead of entering code via the command line, the script file can easily be opened in
  an editor. To do this, the current script must be saved, then enter the following:
</p>
<pre>
  $ @e
</pre>
<p>
  This opens the script in an editor. On linux you will be asked which editor you prefer.
  This is remembered within the session. To use a different editor, type @ee instead.
</p>
<p>
  After changing a script in the editor, and saving, CFT automatically detects the change, and
  reloads the script the next time you press ENTER.
</p>



<h1>Shortcuts vs colon commands</h1>
<p>
  Shortcuts are ways of running code, while colon commands are system commands.
</p>
<p>
  View all colon commands:
</p>
<pre>
  $ :
</pre>

<p>
  View all shortcuts:
</p>
<pre>
  $ @
</pre>
<p>
  Shortcuts are defined in the CFT.props file.
</p>






<h1>CFT as a shell</h1>
<p>
  Commands like "ls" and "cd" exist, with globbing, as well as "more" and "edit" (which opens a file
  in an editor), and they are meant for moving around the directory tree.
</p>
<pre>
  $ pwd
  $ cd ..
  $ ls *.txt
</pre>

<p>
  Performing changes, such as copying, deleting and creating files, is supposed to be scripted
  with code, so no "command line" style functionality exists for this. Example:
</p>
<pre>
  $ Dir.file("xxx.txt").delete
</pre>
<p>
  Or you can run the global "shell" function, perform your changes there, then return via "exit":
</p>
<pre>
  $ shell
  roar@pc01$ rm xxx.txt
  roar@pc01$ exit
    # Running bash completed
  $
</pre>



<h2>Show content of file</h2>
<p>
  Now if we want to list content of file "TODO.txt", we can enter
</p>

<pre>
  $ cat TODO.txt
  $ more TODO.txt
</pre>

<h2>Open a file in editor</h2>
<pre>
  $ edit TODO.txt
</pre>





<h1>List basics</h1>
<p>
  Lists are return value from many functions, such as getting the files in a directory. 
</p>
<p>
  Lists can also be created 
  with the global List() function, which takes any number of parameters, and creates a List object
  from those values.
</p>
<pre>
  $ List                 # empty list
  $ List(1,2,3,4)
  $ Dir.files
  $ "abcdef".chars
  $ "one two three".split
  $ "one:two:three".split(":")
</pre>

<p>
  Many functions are available on a List object. One frequently used is "nth", which
  gets a specific element, defaulting to 0 if no argument.
</p>
<pre>
  $ List("a","b","c").nth
  &lt;String&gt;
  a
</pre>

<p>
  For details of available functions, use the help system:
</p>
<pre>
  $ List help
</pre>





<h1>Introduction to loops</h1>

<p>
  Loops in CFT are mostly concerned with iterating over lists. Let's create a list:
</p>

<pre>
  $ Dir.allFiles(Glob("*.java"))
</pre>
<p>
  This line of code generates a list of all java files under the current directory or sub-directories.
  When we are satisfied with the result of the code line, we give it a name.
</p>

<pre>
  $ /JavaFiles
</pre>

<p>
  We then iterate over the list of files returned, and count the number of lines in each, then
  sum it all up, creating the "linecount" function.
</p>
<pre>
  $ JavaFiles-&gt;f out(f.read.length) | _.sum
  &lt;int&gt;
  18946
  /linecount
</pre>


<p>
  The "arrow" followed by an identifier is the "for each" construct, with the identifier becoming
  the "loop variable".  The out() statement is used to generate output from the loop.
</p>
<p>
  The "pipe" character terminates the loop, and delivers the result from the loop (list of int) to the next part,
  where the "_" (underscore) symbol picks it off the stack, then calls the sum() function on it,
  returning a single int value.
</p>
<p>
  <b>Note:</b> loop variables are not regular variables, and can not be reassigned.
</p>

<h2>Filtering</h2>
<p>
  Filtering list data is essential in CFT. Here is a simple example:
</p>
<pre>
  $ List(1,2,3,4,3,2,1)->x assert(x>2) out(x)
  &lt;List&gt;
  3
  4
  3
</pre>
<p>
  The assert() works like "if condition not satisfied, continue with next value"
</p>







<h1>Local variables</h1>
<p>
  Function code may use local variables for simplifying expressions.
</p>

<pre>
  $ a=3 b=2 a+b
  &lt;int&gt;
  5 
</pre>

<p>
  Can also use "stack based" notation, where the assignment picks the current value
  off the stack and stores it into a variable:
</p>
<pre>
  3=&gt;a 2=&gt;b a+b
  5
</pre>

<p>
  Example:
</p>
<pre>
  List("java","txt")
  /types

  Dir.allFiles-&gt;f type=f.name.afterLast(".") assert(types.contains(type)) out(f)
  /textfiles
</pre>
<p>
  This function lists all files of type .java and .txt
</p>





<h1>Files</h1>
  <pre>
  $ File("x.txt")
   &lt;obj: File&gt;
   x.txt   DOES-NOT-EXIST 
  </pre>

 <p>
  The File() function requires a name, and returns a File object. As seen
  above, the file needs not exist.
</p>
<p>
  File objects created with a simple file name (no path), are always located in
  the CFT home directory. This gives predictability for certain data files etc.
</p>
<p>
  To access or create files in other directories, enter an absolute or relative
  path in the parameter to File(), or use the file() function inside
  some Dir object:
</p>
<pre>
  $ Dir.sub("src").file("x.txt")
</pre>




<h2>Page through a file</h2>

<p>
  To page through text file
</p>
<pre>
  more x.txt
</pre>



<h2>Show bytes of file</h2>
<p>
  To page through hex listing of file
</p>
<pre>
  File("x.txt").hex
</pre>



<h2>Encoding</h2>
<p>
  Default encoding is "ISO_8859_1", but this can be changed, for example:
</p>
<pre>
  File("x.txt").encoding("UTF-8")
</pre>





<h1>Directories</h1>
<pre>
  $ Dir
  &lt;obj: Dir&gt;
  ConfigTool/ d:5 f:20
</pre>

<p>
  Calling the Dir function with no parameters returns a Dir object for the current directory.
</p>
<p>
   The Dir
  object offers multiple member functions, one of which is <b>.files()</b>, which produces a list of files in 
  the directory. Another is <b>.allFiles()</b> which return files from all subdirectories as well.
</p>


<h2>Create a subdirectory</h2>
<pre>
  Dir.sub("someDir").create
</pre>


<h2>Parent directory</h2>
<p>
  To get the parent directory of a Dir object:
</p>
<pre>
  Dir.sub("..")
</pre>

<h2>Get files in a directory</h2>
<pre>
  Dir.files
</pre>

<h2>Create a file in a directory</h2>
<pre>
  Dir.file("x.txt").create("something")
</pre>

<h2>Get immediate directories in a directory</h2>
<pre>
  Dir.dirs
</pre>
<h2>Get all files recursively under a directory</h2>
<pre>
  Dir.allFiles
</pre>
<h2>Get all directories recursively under a directory:</h2>
<pre>
  Dir.allDirs
</pre>
<h2>Delete a sub-directory</h2>
<p>
  The sub-directory must be empty
</p>
<pre>
  Dir.sub("something").delete
</pre>

<h2>Set current directory</h2>
<p>
  Apart from navigating interactively, to set current directory via code:
</p>
<pre>
  Dir.setAsCurrentDir
</pre>



<h1>The shell() function</h1>
<p>
  The global shell() function starts a shell inside CFT. When you exit from it, you're back
  in CFT.
</p>
<pre>
  $ shell
  (starts bash or cmd or Powershell or something else)
  exit
  # Running /usr/bin/bash completed: 25529ms
  $
</pre>
<p>
  The shell function is configured in the CFT.props file which must exist in the CFT 
  home directory.
</p>
<pre>
  shell = bash
  winShell = powershell
</pre>











<h1>Core types</h1>
<ul>
  <li>String</li>
  <li>int - (Java long)</li>
  <li>float - (Java double)</li>
  <li>boolean</li>
  <li>List</li>
  <li>Dict</li>
</ul>
<p>
  All values in CFT are objects, which may contain functions. Strings can be written using double
  or single quotes. 
</p>

<h2>String literals</h2>
<p>
  Strings are written in single or double quotes, and can be summed with '+', which allows
  for all kinds of combinations.
</p>
<pre>
  $ "double quotes"
  $ 'single quotes'

  $ "'a'"
  &lt;String&gt;
  'a'

  $ '"' + "'a'" + '"'
  &lt;String&gt;
  "'a'"
</pre>
<p>
  Also, backslash is not used as escape character, which means backslash is just another character,
  simplifying those Windows paths.
</p>


<h2>Dictionaries</h2>
<p>
  Dictionaries are maps that store any value identified by names (strings). 
</p>
<pre>
  $ x=Dict x.set("a",1) x.get("a")
  &lt;int&gt;
  1
</pre>

<p>
  For readability, values with names that are valid identifiers, and don't conflict with regular 
  member functions, can be referenced via dotted notation
</p>
<pre>
  Dict.set("a","b")
  /d
  d.a
  &lt;String&gt;
  b
</pre>  



<h1>List iteration / filtering</h1>

<p>
  Lists are essential for all processing with CFT.
</p>
<p>
  Lists can be created manually using the global List() function. 
</p>

<pre>
  $ List(1,2,3)
  $ List("a","b","c")
</pre>

<p>
  A much used way for creating lists of strings, is to use the string function split(), which by default
  splits a string on spaces. This means the following produce the same result.
</p>

<pre>
  $ List("a","b","c")
  $ "a b c".split
</pre>




<h2>Iterating over list content</h2>
<p>
  The iterator in CFT takes the form of an arrow followed by a loop variable. For a loop construct
  to return output, we use the out() statement inside.
</p>

<pre>
  $ "1 2 3".split-&gt;x out("a"+x)
  &lt;List&gt;
   0: a1
   1: a2
   2: a3
</pre>

<p>
  The result is a list of strings, as displayed.
</p>




<h2>Filtering with assert(), reject() and break() + out()</h2>
<p>
  Using the assert() statement, we may abort processing for elements that do not meet a condition. 
</p>
<pre>
  $ Dir.allFiles-&gt;f assert(f.name.endsWith(".java")) out(f)
</pre>
<p>
  The reject() statement is the inverse of assert(), and aborts processing for elements that meet
  a certain condition.
</p>
<pre>
  $ List(1,2,3,2,1)-&gt;x reject(x&gt;2) out(x)
  &lt;List&gt;
  1
  2
  2
  1
</pre>
<p>
  The break() statement terminates ALL LOOPS if the condition is true.
</p>
<pre>
  List(1,2,3,2,1)-&gt;x break(x&gt;2) out(x)
  &lt;List&gt;
  1
  2
</pre>



<h2>The condOut() statement</h2>
<p>
  In addition to controlling loops with assert/reject and break, there is the condOut()
  statement, which takes a boolean condition as first parameter, and the value to 
  be sent out as second parameter. Can be useful some times.
</p>
<pre>
  $ List(1,2,3,2,1)-&gt;x condOut(x&lt;2,"(") out("b") condOut(x&lt;2,")") | _.concat
  &lt;String&gt;
  (b)bbb(b)
</pre>





<h2>List addition</h2>
<p>
  Two lists can be added together with "+".
</p>
<pre>
  List(1,2) + List(3)
  &lt;List&gt;
  1
  2
  3
</pre>

<p>
  Also, elements can be added to a list with "+" as long as the list comes first.
</p>
<pre>
  List(1,2)+3
  &lt;List&gt;
  1
  2
  3
</pre>





<h1>Savefiles - "scripts"</h1>
<h2>Save</h2>
<p>
  To save all named functions, enter the special command below
</p>

<pre>
  $ :save Test
</pre>

<p>
  This creates a file under the CFT home directory,
  called savefileTest.txt. 
</p>

<h2>Load</h2>

<pre>
  $ :load Test
</pre>


<h2>Create new empty script</h2>
<p>
  To create a new script from scratch, there is the colon command:
</p>
<pre>
  $ :new
</pre>
<p>


<h2>The @e shortcut</h2>
<p>
  A common shortcut is @e, which opens current savefile in an editor:
</p>
<pre>
  $ @e
</pre>
<p>
  Shortcuts can be redefined in the CFT.props file.
</p>


<h2>CFT.props - codeDirs</h2>
<p>
  The CFT.props file contains the following line by default
</p>
<pre>
codeDirs = . ; code.examples ; code.lib
</pre>
<p>
  The codeDirs field defines a search order when loading scripts. 
  The first directory is <b>always</b> used when you type ":save".
</p>
<p>
  The code.examples contains some example code for various use, while code.lib contains
  library code, used by most other scripts.
</p>
<p>
  This means you are free to save a script using the name "Lib", and it will be written to
  the code.work directory. Doing this means it will hide the version in the code.lib directory.
  Which may be perfectly fine, as long as it is what you intended.
</p>







<h1>Comments</h1>
<p>
  The hash character '#' indicates that the rest of the line is a comment.
</p>










<h1>Calling functions in other scripts</h1>
<p>
  Sometimes we want to call a useful function in another script file. This is
  implemented with with the following syntax:
</p>
<pre>
  Script:Function (...)

  Example: 
    Lib:Header("This is a test")
</pre>
<p>
  Parameters are given as a list of values inside ()'s, which may be omitted if no parameters.
</p>





<h1>Examining external scripts</h1>
<p>
  The '?' interactive command has an extended syntax that allows you to list functions inside
  another script, as well as listing the code of particular function.
</p>
<pre>
  $ ?Lib:                  # lists functions inside Lib
  $ ?Lib:m                 # displays code of function 'm'
</pre>







<h1>Displaying all known scripts</h1>
<p>
  The function Lib:Scripts displays all available scripts, sorted by the directories given
  in the CFT.props file.
</p>
<p>
  The shortcut @S calls this function.
</p>










<h1>Nested loops</h1>
<p>
  Loops are implemented using the "for each" functionality of "-&gt; var". Loops may well be nested.
</p>

<pre>
  $ List(1,2,3)-&gt;x List(1,2,3)-&gt;y  out(x*y)
  &lt;List&gt;
   0: 1
   1: 2
   2: 3
   3: 2
   4: 4
   5: 6
   6: 3
   7: 6
   8: 9
</pre>

<p>
  In this case, the body of each loop is all code following the "-&gt; var"
  construct. But this can be changed using the "pipe" symbol, which "closes" all loops.
</p>



<h1>Loop spaces - "pipes"</h1>
<p>
  The body of any loop is the rest of the code of the function, or until a "pipe" symbol
  is found. The pipe symbol ("|") more accurately partitions the code into a sequence of
  <em>loop spaces</em>, which means acting as an end-point for 
  running loops.
</p>
<p>
  The way a "pipe" works, is to wait for all current loops to terminate, then take the
  return value from that loop space and putting it onto the stack for the next loop
  space to work with (or do something else). Example:
</p>
<pre>
  $ Dir.files-&gt;f out(f.length) | =&gt;sizes sizes.sum
</pre>
<p>
  This single line of code first contains a loop, which outputs a list of integers for
  the sizes of all files in the current directory. Then the "pipe" symbol terminates that
  loop space, and creates a new one, where we pick the result from the previous loop
  space off the stack and assigns it to a local variable. We then apply the sum() function to it.
</p>
<p>
  To save us some typing, the special expression "_" (underscore) pops the topmost value off
  the stack.
</p>
<pre>
  $ Dir.files-&gt;f out(f.length) | _.sum
</pre>

<p>
  As we see from the above code, a loop spaces don't <em>need</em> containing loops. The 
  following is perfectly legal, although a little silly.
</p>
<pre>
  $ 2+3 | | | | =&gt;x x | =&gt;y y | _ _ _ |
</pre>
<p>
  Yes, it returns 5.
</p>




<h2>Result value from a loop space</h2>
<p>
  All bodies of code in CFT consist of one or more <em>loop spaces</em>. The result value
  from any such body is the return value from the last loop space.
</p>

<h3>If the loop space contains looping ...</h3>
<p>
  If a loop space contains loop statements, the result value is a list of data generated
  via calls to out() or report() statements. If no actual iteraions take place, or
  filtering with assert(), reject() or break() means no data is generated via out() or report(), 
  then the result is an empty list.
</p>

<h3>Otherwise ...</h3>
<p>
  A loop space that doesn't contain loop statements, has as its return value the topmost
  element on the stack after all code has executed. If there is no value on the stack,
  the return value is <em>null</em>.
</p>












<h1>Function parameters</h1>
<p>
  Custom functions can also take parameters. This is done using the P() expression, which
  identifies the parameter by position. Note that <em>parameter position is 1-based</em>.  
</p>
<pre>
  $ P(1)=&gt;a P(2)=&gt;b a+b
</pre>
<p>
  This is a valid function, but entering it interactively fails, because it is immediately
  parsed and executed, and there are no parameters. To overcome this, the P() expressions
  take a second parameter, which is a default value.
</p>
<p>
  The default value parameter to P() is important for several reasons.
</p>
<ol>
  <li>Allows the function code to execute while being developed interactively</li> 
  <li>Allows for default values when function is called without parameters, or when called with null-values</li>
  <li>May act as documentation in the source</li>
  <li>
    Provides an elegant way of making functions interactive and non-interactive at the same time, 
    as the default expression is evaluated only when parameter is not given (or is null), 
    and may then ask the user to input the value.
</li>
</ol>
<p>
  Above example again, now with default values for parameters:
</p>
<pre>
  $ P(1,1)=&gt;a P(2,2)=&gt;b a+b
  &lt;int&gt;
  3
  $ /f
  $ f(5,10)
  &lt;int&gt;
  15
</pre>





<h1>User input</h1>
<p>
  CFT contains the following for asking the user to enter input:
</p>
<pre>
  value = Input("Enter value").get
  value = readLine("Enter value")
</pre>
<p>
  The difference is that Input remembers the last input values, and lets the user
  press enter to use the last value, or may enter colon to select between previous
  values. The readLine() is much simpler, and allows for empty input, as enter
  doesn't mean "last value" as for Input.
</p>
<p>
  The optional default value parameter to the P() expression for grabbing parameters to
  functions, can be used to produce functions that ask for missing values.
</p>
<pre>
  P(1,Input("Enter value").get) =&gt;value ...
</pre>









<h1>Block expressions</h1>
<p>
  The traditional blocks inside curly braces are present in CFT as well, and are used for different
  things.
</p>


<h2>Local blocks</h2>
<p>
  Local blocks are just for grouping code that runs in the same context as the code around it. Technically
  they are considered expressions.
</p>
<pre>
  if (a&gt;b) {
    ...
  }
</pre>


<h2>Lambdas</h2>
<p>
  A Lambda is an object (a value) that contains code, so it can be called, with parameters. The code
  inside runs detached from the caller, and behaves exactly like a function.
</p>
<pre>
  myLambda = Lambda { P(1)+P(2) } myLambda.call(1,2)
</pre>
<p>
  Great for local functions inside regular functions, and for sending as parameters to other functions,
  or lambdas.
</p>



<h2>Inner blocks</h2>
<p>
  An inner block is a cross between local blocks and the Lambda. An Inner block is executed
  immediately, and has access to the local variables inside the function, but maintain a separate
  context for loops and loop output. Technically, inner blocks are expressions, just as with local
  blocks. 
</p>
<p>
  In other words: Inner blocks define their own loop space.
</p>
<pre>
  Inner {
    someList->x out(x+1)
  } =&gt;resultList 
  ...
</pre>
<p>
  Inner blocks are a way of running loops isolated from the environment. Remember that loops by 
  default extend to the end of the function, or until hitting a "pipe". The third thing that 
  terminates loops are hitting the end of the current block.
</p>
<p>
  Even the end of local blocks terminate loops, but they share the loop space of the surrounding code, 
  providing somewhat "complicated" outcomes.
</p>
<p>




<h2>Block expressions summary</h2>
<p>
  Local (plain) blocks for non-looping blocks of code, typically used with "if". Running in
  the same loop space as outside the block, means it can call break() and out() as well as
  assert() and reject() and affect the (innermost) loop of those outside the block. 
</p>
<p>
  Inner blocks for isolated processing loops inside other code. This means calling break() and
  out() and assert() and reject() have no effect on loops outside the block.
</p>
<p>
  Lambdas are "functions" as values.
</p>





<h1>Conditionals - if expression</h1>
<p>
  Conditional execution of code is done in two ways in CFT, with the first being how we
  control processing loops with assert, reject and break.
</p>
<p>
  Then there is the if-exression. It takes two forms, but is always considered an expression, not a statement. The
  difference is that expressions always return a value, which statements need not.
</p>
<h3>Inline form</h3>
<pre>
  if (condition, expr1, expr2)
  if (condition, expr1)
</pre>
<p>
  The first selects between the two expressions, based on the condition, evaluating and returning 
  expr1 if condition is true, otherwise expr2. The second conditionally evaluates expr1, or if 
  the condition is false, returns null.
</p>

<h3>Traditional form</h3>
<pre>
  if (condition) expr1 else expr2
  if (condition) expr1
</pre>

<h3>Functionally identical</h3>
<p>
  The two forms are functionally the same. To select between two simple expressions, the inline
  form is probably most readable, while when using block expressions, the traditional form
  usually feels more natural. Also note that block expressions allow us to call statements, 
  such as out() and break() as well as assignments.
</p>
<pre>
  # Example: produce a default value if null
  if (value != null, value, "x") =&gt;value

  # Example: call statements inside blocks
  i=1
  loop
    if (i>10) {
       break
    } else {
      i=i+1
    }
</pre>


<h2>if-ladders</h2>
<p>
  The implementation in CFT supports chaining multiple if after each other.
</p>
<pre>
  if (cond) {
    ...
  } else if (condB) {
    ...
  } else if (condC) {
    ...
  }
</pre>
<p>
  Decoding some value x into a numeric code, we can enter the following
</p>
<pre>
  code = if (x=="a") 1 else if (x=="b") 2 else if (x=="c") 3 else 4
</pre>






<h2>Lazy evaluation</h2>
<h4>Lazy if</h4>
<p>
  The if-expression uses lazy evaluation, which means that only the selected
  value expression (if any) gets evaluated. This is the same as every other
  language.
</p>
<h4>Lazy AND, OR - &amp;&amp; ||</h4>
<p>
  Boolean expressions with logical AND and OR, are lazy, again as in
  every other language. 
</p>
<h4>Lazy P(N,defaultExpr)</h4>
<p>
  The P() expression to access function parameters only evaluates the default
  expression if parameter N is null.
</p>



<h1>The error() function</h1>
<p>
  The error() expression is another that contains a conditional part, and if true, throws
  an exception with the string part, terminating current execution. Alternatively it can
  be used without the condition, which means it always throws an exception.
</p>
<pre>
  error(1+1==2,"this should not happen")

  if (1+1==2) {
    error("oops again")
  }
</pre>



<h1>Output to screen</h1>
<pre>
  println("a")
  debug("b")
</pre>




<h1>Protecting files and directories</h1>
<p>
  To save typing, one often create functions that just return some directory, or 
  some files.  The JavaFiles example above illustrates this.
</p>
<p>
  The protect mechanism in CFT lets us attach a protect state to any Dir and File object,
  which guarantees that:
</p>
<ol>
  <li>all files and directories derived from it are also protected</li>
  <li>blocks destructive modifications</li>
</ol>


<h2>Example</h2>
<p>
  Adding .protect to each file that the JavaFiles function generates, ensures that all
  files returned from this function are blocked against accidental delete and modifications.
</p>
<pre>
  $ Dir.allFiles-&gt; f assert(f.name.endsWith(".java")) out(f.protect)
  $ /JavaFiles
</pre>
<p>
  Demonstration:
</p>
<pre>
  $ JavaFiles.nth.append("")   # Trying to append empty line to first file
  ERROR: [input:16] INVALID-OP append : /home/roar/.../xyz.java (PROTECTED: -) (java.lang.Exception)
</pre>
<p>
  The .protect() function can also take a description string, which if present, is displayed in this error.
</p>

<h2>A protected directory does not allow</h2>

<ul>
<li>create</li>
<li>delete</li>
<li>copy file into dir - includes blocking File.uncompress when target dir is protected</li>
</ul>


<h2>A protected file does not allow</h2>
<ul>
  <li>delete</li>
  <li>create</li>
  <li>append</li>
  <li>copyFrom (target)</li>
  <li>copyTo</li>
  <li>move (source or target)</li>
</ul>





<h2>No guarantee</h2>
<p>
  Calling .protect on a Dir object, before using it to locate files, will propagate the protected
  state to all those files. However, creating a new Dir object for the same path, without calling 
  .protect() on it, and then accessing content via this, does not protect anything.
</p>
<p>
  Note also that .protect can not detect for example using the path of a protected File object in
  an external program, or even to create a new File object (which will not be protected). Example:
</p>
<pre>
  File(protectedFile.path)
</pre>








<h1>Running external programs</h1>



<h2>Summary</h2>
<p>
  The functions for running external programs are part of the Dir object, implicitly defining
  working directory for the program.
</p>

<pre>
  $ Dir.run ( list|...)
  $ Dir.runCapture ( list | ...)
  $ Dir.runDetach ( list|...)
  $ Dir.runProcess ( stdinFile, stdoutFile, stdErrFile, list|... )
</pre>

<p>
  The parameters written as "list|..." means either a List object, or a list of
  String values, separated by comma.
</p>




<h2>Dir.run()</h2>
<p>
  This command is used for running external programs in the foreground. What this means is that if
  the program requires user input, we can give it, and the CFT code will not continue until
  the external process has terminated.
</p>
<pre>
  $ Dir.run("cmd","/c","git","pull","origin","master")
</pre>
<p>
  Many Windows programs require the "cmd","/c" in front of the actual program.
  For proper operating systems (Linux) you naturally skip the two first elements of the command list.
</p>



<h2>Dir.runCapture()</h2>
<p>
  This works the same as Dir.run(), but returns a List of strings representing stdout from the
  external program, to be processed further. Not suited for interactive use.
</p>

<pre>
  Dir.runCapture("which","leafpad") =&gt;lines lines.length&gt;0 && lines.nth.contains("leafpad")
  /HasLeafpad
</pre>



<h2>Dir.runDetach()</h2>
<p>
  Use to run external program in the background. The CFT code continues running after forking
  off the background process. Nice for editors etc.
</p>
<pre>
  $ Dir.runDetach("leafpad", Sys.savefile.path)
</pre>

<p>
  This example runs the leapad editor in the background, with the path of the current savefile as 
  argument.
</p>


<h2>Dir.runProcess</h2>
<p>
  Runs external program, reading input lines from text file, and deliver stdout and stderr to 
  files. Returns an ExtProcess object, which is used to monitor, terminate or wait for the
  external process to finish.
</p>
<p>
  The complexities of creating and removing temporary files, is encapsuled in the library
  function <b>Lib:runProcess</b>, which in turn is called from the simpler <b>Lib:run</b> function, which
  also handles waiting for the external process to finish, before returning. 
</p>
<p>
  Both of the Lib functions take the same four parameters, but often only the first is used, as the
  rest have useful defaults.
</p>
<p>
  <i>Lib:run</i> is the notation for calling a function in another script.
</p>


<h2>Lib:runProcess utility function</h2>
<p>
  This is a CFT function in the Lib script, which hides the complexities of 
  calling Dir.runProcess (above). 
</p>
<pre>
  Lib:runProcess(List("ls","-l)) =&gt; result
</pre>
<p>
  The result object is a Dict with various system info, representing the running
  process. It has two closures of interest.
</p>
<p>
  A <i>closure</i> is a callable object, which
  runs code "inside" a dictionary, via a <i>lambda</i>. Closures and lambdas are invoked
  via their .call(...) function.
</p>
<pre>
  result.isCompleted.call     # returns boolean
  result.wait.call            # waits for process to finish, then returns another Dict
</pre>
<p>
  The result.wait closure, when called, returns a Dict with the following content:
</p>
<ul>
  <li>cmd - the command (list)</li>
  <li>stdin - the stdin lines (list)</li>
  <li>stdout - stdout lines (list)</li>
  <li>stderr - stderr lines (list)</li>
  <li>exitCode - int</li>
</ul>
<p>
  To show the Lib:runProcess function code
</p>
<pre>
  $ ?Lib:runProcess
</pre>
<p>
  Warning: it's a bit complex
</p>




<h2>Lib:run utility function</h2>
<pre>
  Lib:run (List("ls","-l")) =&gt; result
</pre>
<p>
  The implementation of Lib:run consists of calling Lib:runProcess and then
  calling the wait closure, as seen above, returning the result from that call.
</p>
<p>
  To show the Lib:run function code
</p>
<pre>
  $ ?Lib:run
</pre>


<h2>Work directory issues</h2>
<p>
  For external programs that depend on running from a specific directly, either navigate to current directory
  interactively, or just let your code call the .setAsCurrentDir() function on some Dir object before
  calling Lib:run. 
</p>
<pre>
  Dir("/home/user/xyz").setAsCurrentDir
  Lib:run(...) =&gt; result
</pre>




<h2>Doing ssh</h2>
<p>
  If you need to run SSH commands on remote targets, use the SSH library script, which
  contains two major functions: run() and sudo(), These call Lib:run then filter the output
  to stdout using a marker to eliminate the welcome text when logging in etc.
</p>

<p><b>Side note: ssh without password</b></p>
<p>
  To set up ssh login without password, create and distribute an ssh key, then
  copy it to the target host, as follows (in Linux shell).
</p>
<pre>
  $ ssh-keygen -t rsa
  $ ssh-copy-id user@host
</pre>






<h1>Synthesis</h1>

<h2>The problem</h2>

<p>
  If we use "cd" and "ls" to move
  to a directory, and want to create a function that works on files or subdirectories under
  that location, we have to take care.
</p>

<p>
  The issue is that we can not just say
</p>
<pre>
  Dir.allFiles-&gt;f ...
</pre>
<p>
  ... because the Dir() function returns the current directory, which may change. 
</p>


<h2>Creating code from values</h2>
<p>
  This is where the <i>syntesis</i> functionality comes in. The most often used variant takes
  the form of two "colon commands". 
</p>
<ol>
  <li>The :syn command syntesizes code from the last result.</li>
  <li>The :NN  (where NN is an integer) syntesizes the indicated element of the last result list. If 
  last result is not a list, an error is reported.</li>
</ol>


<h2>Example using :syn</h2>

<pre>
  $ cd ..
    # /home/roar
    &lt;obj: Dir&gt;
    roar/ d:61 f:33 
  $ cd project1
    # /home/roar/project1
    &lt;obj: Dir&gt;
    project1/ d:0 f:0 
  $ :syn
  synthesize ok
  +-----------------------------------------------------
  | .  : Dir("/home/roar/project1")
  +-----------------------------------------------------
  Assign to name by /xxx as usual

  $ /DirProject1
</pre>

<p>
  When we use "cd" to change to a directory, it returns a Dir object. The shell remembers the last
  result value, and the ":syn" attempts to create code representing that value in as direct a way as 
  possible. If this succeeds, it inserts the generated code line tino the "code history", as the 
  last command, which means it can now be assigned a name, for example "DirProject"
</p>

<p>
  Calling function "DirProject" will now always generate a Dir object pointing to the same
  directory, and is no longer dependening on current directory.
</p>

<h2>Example using :NN</h2>

<p>
  To synthesize a single element when the last result was a list, use :NN, as follows
</p>

<pre>
  $ ls
  &lt;List&gt;
   0: runtime/              | d:2 | f:12
   1: CallScriptFunc.java   | 1k  | 1398  |             | 2020-02-28 22:38:09
   2: CodeHistory.java      | 10k | 10980 | 2d_22:23:24 | 2020-06-07 12:57:49
   3: CommandProcessor.java | 0k  | 365   |             | 2020-02-28 22:38:09

  $ :2
  synthesize ok
  +-----------------------------------------------------
  | .  : File("/home/roar/Prosjekter/Java/ConfigTool/src/rf/configtool/main/CodeHistory.java")
  +-----------------------------------------------------
  Assign to name by /xxx as usual  
</pre>

<p>
  If the last value was not a list, the ":NN" command will fail with an error.
</p>





<h1>Output format / Cfg</h1>
<p>
  Output to screen is regulated via a Cfg object. It is a session object, that contains default
  settings for number of lines and line width of the current window / terminal. It's default
  mode of operation is to disable wrapping, which means long lines are cut, ending with a simple '+'
  to indicate this.
</p>
<p>
  To change the current size of the terminal window, we may use global function Cfg() to obtain
  the Cfg object, and methods to set or view the properties.
</p>



<h2>The @term shortcut</h2>
<p>
  After the introduction of short cuts, the easiest way to set the terminal window width and
  height, is to enter
</p>
<pre>
  $ @term
</pre>

<p>
  This works on Linux (using stty command) and on Windows (powershell). 
</p>



<h2>Line wrapping</h2>
<p>
  By default, ouput line wrapping is off, which means that lines longer than the Cfg.w gets truncated
  with a '+' to indicate there is more. It can be switched on/off via the Cfg object, but there is also a
  colon command ":wrap" which toggles wrapping on or off.
</p>








<h1>Templating</h1>

<p>
  Templating is the task of merging data into text, or alternatively of selecting
  blocks of text to form a custom result. 
</p>
<p>
  This is useful for producing configuration files, generating code, and similar.
</p>



<h2>Merging text with Dict</h2>

<p>
  To merge values into a template, we use a dictionary object (Dict) combined with the
  merge() function of strings. This replaces occurrences of names in the dictionary
  with their values (as strings).
</p>
<pre>
  $ Dict.set("name","Julius")
  $ /data
  $ "Dear name".merge(data)
  &lt;String&gt;
  Dear Julius 
</pre>

<h2>Dict.mergeCodes()</h2>

<p>
  The merge is based on a direct match. Often we like to mark our merge codes. The Dict
  object has a function, ".mergeCodes()", which returns a new Dict object, where all names of fields
  are rewritten into ${name}. Changing the template correspondingly, this eliminates the risk of 
  accidentally matching text not meant as merge codes.
</p>
<pre>
  $ Dict.set("name","Julius").mergeCodes
  $ /data
  $ "Dear ${name}".merge(data)
  &lt;String&gt;
  Dear Julius 
</pre>

<h3>Custom merge codes</h3>
<p>
  The Dict.mergeCodes() also take an optional two parameters, which are the pre and post
  strings for creating the merge codes. Note that either none or both of these must be
  given.
</p>
<pre>
  $ Dict.set("name","Julius").mergeCodes("[","]")
  $ /data
  $ "Dear [name]".merge(data)
  &lt;String&gt;
  Dear Julius 
</pre>


<h2>PDict()</h2>
<p>
  With many parameters to be merged into the template text, the special expression PDict() saves
  us some typing. Instead of having to do this:
</p>
<pre>
  P(1) => name
  P(2) => ip
  Dict
    .set("name",name)
    .set("ip",ip)
    .mergeCodes =&gt; data
</pre>
<p>
  ... we can instead just say:
</p>
<pre>
  PDict("name","ip").mergeCodes =&gt; data
</pre>
<p>
  The PDict function takes a list of names, and map them to the function parameters
  in sequence. Missing values result in "null", which in turn (when calling String.merge),
  get replaced with empty strings. 
</p>
<p>
  If missing values are a problem:
</p>
<pre>
  PDict("name","ip").mergeCodes =&gt; data
  error(data.hasNullValue,"Missing parameters!")
</pre>



<h2>Example using raw strings and Sequence()</h2>
<p>
  <b>Raw strings</b> are a special notation for strings, that is as follows:
</p>
<pre>
  a = @ this is a "raw string" ...
</pre>
<p>
  The raw string starts following the "@ " prefix, and continues to the end of the line.
</p>
<p>
  <b>Sequence()</b> and <b>CondSequence()</b> are built-in expressions that are similar to 
  List, in that they create list objects, but with a relaxed syntax, which means commas
  between values are optional. 
</p>
<p>
  The CondSequence() is conditional, which means if the first parameter is false, it generates
  an empty list. Since lists can be concatenated with "+", we can do this:
</p>
<pre>
  PDict("replSetName","clusterRole").mergeCodes=&gt;data
  isConfNode = (P(2)=="configsvr")
  
  Sequence(
    @  :
    @  :
    @ replication:
    @   replSetName: '${replSetName}'
    @
  ) + CondSequence(isConf,
    @ 
    @ # NOTE: config replica set node
    @
  ) + CondSequence(!isConf,
    @
    @ # NOTE: data shard replica set node
    @
  )+Sequence(
    @ sharding:
    @   clusterRole: '${clusterRole}'
  )
  ->line out(line.merge(data))
  /CreateMongodCfg
</pre>


<h1>Processing text</h1>
<p>
  Here are different ways of working with text in CFT.
</p>
<ul>
  <li>Reading separate text files</li>
  <li>"here" documents in script files</li>
  <li>DataFile</li>
  <li>Sequence() and raw strings</li>
</ul>




<h2>Reading text files</h2>
<p>
  Any text file can be read and processed line by line as follows.
</p>
<pre>
  Dir.file("x.txt").read->line ...
</pre>



<h2>Script file "here" documents</h2>
<p>
  This is a special feature of script files, where a sequence of lines between two
  marker lines, are translated to a List expression on the fly, as the script file is loaded.
</p>
<pre>
  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Identifier
  This is
  some text
  &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Identifier
  /myTemplate
</pre>
 <p>
  Calling the myTemplate function from the interactive shell, produces the following result
</p>
<pre>
  $ myTemplate
  &lt;List&gt;
  0: This is
  1: some text
</pre>
<p>
  The markers need at least 3x of the '&lt;' or '&gt;' followed by space and a matching identifier.
</p>



<h2>DataFile</h2>
<p>
  The DataFile global function reads a special text file with individual sections identified
  by a user selectable selector string, and names.
</p>
<p>
  Example data file 'data.txt'
</p>
<pre>
  ### A

  This is
  template A
  
  ### B
  
  This is 
  template B
</pre>
<p>
  The code to use this file consists of creating the DataFile object, passing the separator
  string as a parameter, then accessing the individual templates.
</p>
<pre>
  $ DataFile(File("data.txt"),"###")
  $ /df

  $ df.get("A")
  &lt;List&gt;
  This is
  template A
</pre>

<h3>Include blank lines</h3>
<p>
  The function DataFile.get() returns only non-blank lines. To get all lines, use function getAll().
</p>

<h3>Filter away comments</h3>
<p>
  Also, DataFile has support for comments in the template text, which can be automatically
  removed. They are defined by another prefix string as follows:
</p>
<pre>
  $ DataFile(someFile,"###").comment("//")
  $ /df
</pre>
<p>
  Now all lines starting with "//" are automatically stripped from any output.
</p>




<h2>Sequence() and raw strings</h2>
<p>
  <i>v1.7.0</i>
</p>
<p>
  Raw strings start with '@' and consist of the rest of the line.
  In addition, two expressions have been added, called Sequence() and CondSequence(). These
  generate List elements, but with a relaxed syntax, making commas between values optional, 
  for max readability when creating a template.
</p>
<pre>
  Sequence(
    @ header
  )+CondSequence(&lt;condition&gt;
    @ optional-part 
  )+Sequence(
    @ footer
  )
</pre>
<p>
  What happens here is that the Sequence() and CondSequence() expressions result in List
  objects, which are then concatenated via the "+" operator. 
</p>
<p>
  The "@" type "raw" strings can be used in regular code as well. The behaviour is as follows:
</p>
<ul>
  <li>When "@" is followed by single space, that single space is removed from the string</li>
  <li>When "@" is followed by another "@", all characters following that sequence becomes the string</li>
  <li>When "@" is followed by anything else, all of the rest of the line becomes the string</li>
 </ul>
 <p>
  The advantage of this notation over that of "here"-documents, is that it allows proper
  indentation, for greatly improved readability in script code, and that it's easy to
  add conditional blocks, while the "here"-document means we can paste original text
  directly into the script code.
</p>








<h1>Use as a calculator</h1>


<h2>Expressions and "variables"</h2>
<p>
  Having a running instance of CFT on the desktop means access to a capable calculator.
</p>
<pre>
  $ 24*60*60
  &lt;int&gt;
  86400
  /x

  x*365
  &lt;int&gt;
  31536000
</pre>
<p>
  As noted before, the symbol "x" does not refer to the value 86400, but to the code that 
  generates the value.
</p>



<h2>Lib.Math</h2>
<p>
  The global function Lib() creates a Lib object, which in turn contains functions that
  create other objects, such as the Math object, which contains trigonometric functions.
</p>



<h2>Lib.Convert</h2>
<p>
  The Lib.Convert function returns another object, which contains code for lots of common
  conversions. Use the help system to show all options.
</p>
<pre>
  $ Lib.Convert help
</pre>



<h2>Lib.Plot</h2>
<p>
  The Lib.Plot function returns an object with functions for creating a primitive plot, for
  visualizing data. Again, use the help system to examine options.
</p>
<p>
  Note that Lib.Plot is a quick-and-dirty implementation. For better graphs, some external
  package should be invoked.
</p>
<pre>
  File("/tmp/" + currentTimeMillis+".txt")
  /tmpFile

  
  f = tmpFile
  Lib.Data.each(0,720)-&gt;i
    f.append(""+Lib.Math.sin(i) + "," + Lib.Math.cos(i))
  |
  Lib.Plot.typeTimeline.readCSVFile(f).plot(File("out.png"))
  f.delete
  /DemoPlot
</pre>
<p>
  The above code generates an example plot as a png file in the current directory.
</p>










<h1>Command line args</h1>
<p>
  If CFT is invoked with command line arguments, the first is the name of the script,
  that is, a savefile minus the "savefile" prefix and ".txt" ending.
</p>
<p>
 Then follows zero
  or more command lines, on string format. For values containing space or otherwise 
  have meaning to the shell, use quotes. Example:
</p>
<pre>
  ./cft Projects Curr
</pre>
<p>
  This loads script Projects, then calls the Curr function inside.
</p>
<pre>
  ./cft
  ./cft scriptName [commandLines]*
  ./cft -version
  ./cft -help
  ./cft -d scriptDir [scriptName [commandLines]*]?
</pre>








<h1>Working with pasted text lines from stdin</h1>
<p>
  If you've got some text in the copy-paste buffer that you want to work with, the 
  readLines() global functions can be used. It takes one parameter, which is an end-marker, which must 
  occur alone on a line, to mark the end.
</p>
<p>
  The readLines() function returns a list of strings, which you can turn into code and save under
  some function name, using synthesis.
</p>
<pre>
  readLines("XXX")
  (paste or enter text, then enter end-marker manually)
  XXX
  &lt;list&gt;
  0: ...
  1: ...

  :syn
  /someName
  
  ...
</pre>






<h1>Differing between Windows and Linux</h1>
<p>
  Calling function Sys.isWindows() is used to differ between the two in code. It does this
  by checking if (Java) File.separator is a backslash.
</p>
<pre>
  $ Sys.isWindows
  &lt;boolean&gt;
  false
</pre>








<h1>Predicate calls</h1>
<p>
  Example: to decide if a string is an integer, without
  resorting to either creating a built-in predicate function like .isInt, or even
  using regular expression matching, there is the <em>predicate call</em> functionality,
  where one calls a function in a special way, resulting in a boolean value that tells
  if the call was ok or not.
</p>
<p>
  All dotted calls are made into predicate calls, by adding a '?' questionmark between the dot 
  and the function name. 
<pre>
  "sdf".?parseInt
  &lt;boolean&gt;
  false

  "123".?parseInt
  &lt;boolean&gt;
  true
</pre>





<h1>Error handling</h1>
<p>
  Exception handling in CFT is split into two parts, reflecting two types of
  situations:
</p>
<ol>
  <li>CFT logical or data errors, called <b>soft errors</b></li>
  <li>General errors, stemming from underlying Java code, network situations etc, called <b>hard errors</b></li>
</ol>
</p>
<h2>Soft errors</h2>
<p>
  Soft errors are created by calling the error() function. 
</p>
<p>
  They can be specifically
  caught with tryCatchSoft(), which returns a Dict containing either:
</p>
<pre>
  ok: true
  result: ANY

  or

  ok: false
  msg: string
</pre>
<p>
  Hard errors propagate right through tryCatchSoft().
</p>

<h2>Hard errors</h2>
<p>
  Hard errors are all kind of error situations arising from the Java code running CFT.
</p>
<p> 
  The tryCatch() expression catches both hard and soft errors, and returns a Dict containing
</p>
<pre>
  ok: true
  result: ANY

  or 

  ok: false
  msg: string
  stack: List of string
</pre>
<p>
  An example of a hard error is trying to access a variable or function that doesn't
  exist.
</p>






<h1>Get type of value</h1>
<p>
  The global function getType() takes one parameter, and returns 
  the type name of that value, as a string
</p>
<pre>
  $ getType(3)
  &lt;String&gt;
  int
  $ getType(Dict)
  &lt;String&gt;
  Dict
</pre>



<h1>Clone any value</h1>
<p>
  The common function clone() of all values returns a copy of the value, as long as the value
  in question is synthesizable. If not, an error is returned. 
</p>
<pre>
  a=List(1,2,3)
  b=a.clone.add(4)  # b contains 1,2,3,4 while a remains unchanged
</pre>





<h1>Multitasking in CFT</h1>
<p><b>v1.9.8</b></p>
<p>
  CFT offers the ability to run multiple processes of CFT code, via the SpawnProcess() statement.
</p>
<p>
  It takes two parameters, a context dictionary and an expression. The named values from the 
  context dictionary become local variables when the expression is executed, which takes
  place in a separate process.
</p>
<p>
  The code runs in a virtualized environment. Output is buffered inside the Process object, and
  if the code requires input, it will block, until we supply input lines via the Process
  object.
</p>
<p>
  For details:
</p>
<pre>
  $ SpawnProcess(Dict,1) help

  # close() - close stdin for process
  # exitValue() - returns exit value or null if still running
  # isAlive() - true if process running
  # isDone() - true if process completed running
  # output() - get buffered output
  # sendLine(line) - send input line to process

</pre>




<h1>List.push()</h1>
<p>
  The push() function of the List object pushes a number of value from the list onto the stack
  to be assigned in "logical" order, and allows us to supply a default value if list too short.
</p>
<pre>
  $ List("x","y").split.push(3,"*") =&gt;a =&gt;b =&gt;c a+":"+b+":"+c
  &lt;String&gt;
  x:y:*
</pre>




<h1>Dict set with strings</h1>
<p>
  Reading name-value assignments from a property file or similar, is best done via the .setStr()
  function on the Dict object. It strips whitespace and accepts both colon and '='.
</p>
<pre>
  Dict.setStr("a : b")
  /d
  d.get("a")
  &lt;String&gt;
  b
</pre>
<p>
  To process a property file, assuming commented lines start with '#', we can do 
  this:
</p>
<pre>
  P(1) =&gt;propFile
    Dict =&gt;d
    propFile.read-&gt;line
      reject(line.trim.startsWith("#"))
      assert(line.contains(":") || line.contains("="))
      d.setStr(line)
    |
    d
  /GetProps
</pre>





<h1>Dict.get with default value</h1>
<p>
  The Dict.get() method takes an optional default-value which is returned if no value
  associated with the name, but in that case the default value is <em>also stored</em> in the
  dictionary. 
</p>

<pre>
  data=Dict
  data.get("a",3)  # returns 3
  data.keys        # returns list with "a"
  data.get("a",5)  # returns 3 as it was set above
</pre>




<h1>List.nth() negative indexes</h1>
<p>
  Using negative indexes to List.nth() counts from the end of the list. Using value -1 returns the
  last element, -2 the second last, and so on.
</p>
<pre>
  List(1,2,3,4).nth(-1)
  &lt;int&gt;
  
</pre>




<h1>Function parameters as List or Dict</h1>

<p>
  In addition to grabbing one parameter at a time, using P(pos), we can also process the
  parameter values as a list and as a dictionary.
</p>

<p>
  The function parameter expression P() when used with no parameters, returns a list of
  the parameter values as passed to the function.
</p>

<p>
  The PDict() expression takes a sequence of names to be mapped to parameters by position,
  resulting in a Dict object. Missing values lead to the special value null being stored
  in the dictionary.
</p>





<h1>The general loop statement</h1>
<p>
  In addition to looping over lists, there is a general loop construct. It identifies no
  loop variable, and loops forever, until break() is called. It also obeys assert()
  and reject() as with list iteration. 
</p>
<pre>
  a=0 loop break(a&gt;3) out(a) a=a+1
  &lt;List&gt;
  0
  1
  2
  3
</pre>
<p>
  If you forget to increment the variable a, or forget or create an invalid break(), then
  the loop may never terminate, and CFT has to be killed with ^C
</p>




<h1>Storing CFT data structures to file - syn() and eval()</h1>

<p>
  A  persistent solution for storing data is to store a data structure to file. This is done using
  the synthesis functionality, which is made available as a global function as well as the
  "colon command" used before. This means we can write huge lists and sets of files and
  directory objects to file, and restore it later, without going through possibly time
  consuming computations.
</p>
<p>
  To restore the structure, we use the global eval() function.

<pre>

  P(1)=&gt;file
  P(2,"data") =&gt;data
    file.create(syn(data))
  /saveData

  P(1)=&gt;file
  eval(file.read.nth)
  /restoreData
</pre>
<p>
  This can be used to save arbitrarily big structures, as long as they are synthesizable.
</p>




<h1>The CFT database</h1>
<p><i>v1.9.6</i></p>
<p>
  CFT implements its own primitive database, as found in Lib.Db.Db2, and which is usually
  interfaced via the Db2 script.
</p>
<pre>
  Db2:Set("myCollection", "field", "test")
</pre>
<p>
  The Db2 persists data to file, and handles all values that can be synthesized to code.
</p>
<p>
  Also there is a Db2Obj script, which saves data objects identified by UUID's, which are
  maode by calling the Lib.Db.UUID function.
</p>







<h1>String .esc() and .unEsc()</h1>
<p>
  As was mentioned initially, CFT doesn't use backslash as an escape character. 
  However, we still require a way of converting "difficult" strings to code,
  via synthesis. For this purpose, the two functions String.esc() and String.unEsc() was
  created.
</p>
<p>
  One rarely needs to call these manually, but they are worth mentioning, as sometimes synthesis
  of a string may result in code such as this:
</p>
<pre>
  "^q^aa^a^q".unEsc
</pre>



<h2>Escape codes</h2>
<p>
  For an escaped string, the escape character is the ^ symbol.
</p>
<ul>
  <li>"Double quotes" ^q</li>
  <li>'Single quotes' / Apostrophe ^a</li>
  <li>Newline ^n</li>
  <li>Carriage Return ^r</li>
  <li>Tab ^t</li>
  <li>The ^ symbol ^^</li>
</ul>
<p>
  To gives a way of creating strings with newlines inside.
</p>
<pre>
  "this^nis^na test".unEsc

  &lt;String&gt;
  this
  is
  a test 
</pre>



<h1>Automating interactive functions / Sys.stdin()</h1>
<p>
  Functions may query the user with Input("prompt").get and readLine("prompt"). If we want
  to automate such functions, we use function Sys.stdin() to buffer up any number of 
  input lines. 
</p>
<pre>
  Sys.stdin("read-this") Input("Enter data").get
  &lt;String&gt;
  read-this
</pre>
<p>
  Note that both Input.get() and readLine() detect if there is buffered input, and
  if so, do not display the prompt or other info. Particularly useful for Input.get(),
  since buffering the empty string "" with Sys.stdin() means repeating the last value.
</p>




<h2>Running colon commands from script code</h2>
<p>
  Using the Sys.stdin() statement without being followed by Input.get() or readLine(), is just 
  another way of entering commands. This means colon commands are available from CFT code.
</p>
<pre>
  stdin("2+3")
  &lt;int&gt;
  5
</pre>
<p>
  This can be exploited to let a script modify itself, by redefining
  functions, although that will be troublesome if those functions read input. A better
  use is that of running colon commands, particularly loading scripts. This is used
  frequently with shortcuts.
</p>
<pre>
  stdin(":load SomeScript","?")
</pre>






<h1>Simple line editing</h1>
<p>
  When using CFT mainly in interactive mode, a primitive line editor can be used to modify
  the code of an existing function, by optionally cutting off text following a pattern, as well
  as optionally adding text. 
</p>
<p>
  The syntax is as follows
</p>
<pre>
  $ !x!       # inserts code from function x as text, then executes it
  $ !x! txt   # inserts code from function x, followed by " txt", then executes it
  $ !x:p!     # inserts code from function x up to but not including pattern 'p'
  $ !x:p! txt
</pre>

<h3>Develop complex code in steps</h3>
<pre>
  $ Dir.files
  $ /x
  $ !x!-&gt;f out(f)
  $ /x!
  $ !x:out!assert(f.name.endsWith(".txt")) out(f)
  $ /x!
</pre>

<p>
  Note: this only applies to single-line functions.
</p>




<h1>CFT.props - mCat, mEdit and mMore lambdas</h1>
<p>
  The configuration fields mCat, mEdit and mMore ("m" for macro) define lambdas
  that are called for interactive commands cat/edit/more. This means it is possible
  to redefine what edit means. Currently, mEdit calls either "Lib:e". The
  mMore lambda calls "Lib:m", while the mCat macro just calls .read on file parameter.
</p>





<h1>CFT.props - shortcuts</h1>
<p>
  The CFT.props text is self explanatory.
</p>
<pre>
# Shortcuts
#
# The shortcuts are lines of code. If that code results in a macro, it is invoked with
# no parameters. Since we don't need parameters, there is really no need for macros
# here. The return value from a shortcut becomes the "last value", available
# via Sys.lastResult, as well as used by :syn etc
#
# Note that shortcuts only work when the prefix is at the start of the interactive
# input line. 
# ---
shortcutPrefix = @

shortcut:r = Sys.stdin(":load Release","?")
shortcut:p = Sys.stdin(":load Projects","?")

# List available shortcuts when typing '@' only
# ---
shortcut: = File("CFT.props").read-gt;line assert(line.contains("shortcut:")) out(line)
</pre>
<p>
  This means that typing @r loads the Release script, then executes the '?' command, which
  lists its content.
</p>

<h3>Show all shortcuts</h3>
<p>
  To list defined shortcut, just type 
</p>
<pre>
  $ @
</pre>
<p>
  This is a shortcut itself, that traverses the CFT.props file and identifies and 
  displays the
  shortcut definitions from it.
</p>





<h1>Some example code</h1>

<h2>Windows PowerShell</h2>
<p>
  The following code is an effective way of using PowerShell from CFT, saving lots of typing.
</p>
<pre>
  # Run remote PowerShell script-block
    host=P(1) 
    cmd=P(2)  
    fullCmd = List("powershell","invoke-command","-computername",host,"-scriptblock","{" + cmd + "}")
    Dir.run(fullCmd)
  /PSRun

  # List services via PowerShell (interactive)
    host = Input("Host").get
    Input("Service name (including wildcards)").get =service
    cmd = "get-service -name " + service  # no splitting
    PSRun(host, cmd)
  /PSGetService

</pre>


<h2>Windows CMD</h2>
<p>
  Running commands using CMD in windows, mostly requires the "/c" flag.
</p>
<pre>
  Dir("...")
  /DirProject

  # Add, commit and push with git
    DirProject.run("cmd","/c","git","add",".")
    msg=Input("Commit message").get
    DirProject.run("cmd","/c","git","commit","-m",msg)
    DirProject.run("cmd","/c","git","push","origin","master")
  /GitPush
</pre>




<h1>Lib.Text.Lexer</h1>
<p>
  <i>v1.3.2</i>
</p>
<p>
  The Lib.Text.Lexer objects adds 
  capability to match complex tokens with CFT, using the same Java tokenizer that is used when
  parsing CFT script code. 
</p>
<h2>Motivation</h2>
<p>
  Working with log data, it would be nice identifying data in log lines beyond
  doing free text searches. The Lexer is the first step, and will in time be followed by 
  some more classes, including a basic recursive-descent parser.
</p>

<h2>Concept</h2>
<p>
  The concept is that of a tree of maps, each map maps single characters to other maps, and so on.
  If map A contains mapping of digits 0-9 pointing at map B, and our parse process so far has led 
  us to map A, with next input character being 0,1,2,3..., then that character is "consumed", which is
  fancy speak for matched, and the current map becomes B. The process then repeates.
</p>
<p>
  If the current map has no mapping for the current next character, then one of the following happen:
</p>
<ol>
  <li>If the current map is marked with "this is a token", then parsing succeeds</li>
  <li>Otherwise, we backtrack, unconsuming previourly consumed characters, until finding a map that "is a token"</li>
  <lI>Or ,if no map in our parse tree has the "this is a token" mark set, then parsing fails</li>
</ol>

<h2>Implementation</h2>
<p>
  In the CFT functions, such maps are called nodes. They are created via the
  Lib.Text.Lexer.Node function.
</p>
<pre>
  $ Lib.Text.Lexer help
  
  # Node(firstChars?) - create empty node, possibly identifying firstChars list
  # getTokenStream() - get list of tokens identified via processLine as TokenStream object
  # getTokens() - get list of tokens identified via calls to processLine
  # processLine(rootNode,line,eolTokenType?) - processes line, adds to internal token list - returns self
</pre>
<p>
  The nodes in turn contain the following:
</p>
<pre>
  $ Lib.Text.Lexer.Node help

  # addToken(token) - create mappings for token string, returns resulting Node
  # match(Str) - returns number of characters matched
  # setDefault(targetNode?) - map all non-specified characters to node, returns target node
  # setIsToken(tokenType) - tokenType is an int - returns self
  # sub(chars, targetNode) or sub(chars) or sub(targetNode) - add mapping, returns target Node
</pre>
<p>
  A simple example:
</p>
<pre>
  top=Lib.Text.Lexer.Node
  x=top.sub("0123456789")   # new node
  x.sub("0123456789",x)  # x points to itself for digits
  x.setIsToken(1) # token type: non-negative numbers for regular tokens

  top.match("300xx")  # returns 3, matching sequence '300'
</pre>
<p>
  The match() function is for testing only.
</p>



<h3>.sub()</h3>
<p>
  The sub() function of any node is used to connect pointers from one map to another. It takes 
  three forms:
</p>
<pre>
  (1)
  someNode.sub("abc",someOtherNode)  
    # when at someNode and one of the characters ("abc") are next character in input
    # string, then consume character, and move to that other node, which may of course
    # be the same node or some other node

  (2)
  someNode.sub("abc")
    # When no node parameter, an empty node is created, which "abc" points to from
    # someNode. The new node is returned

  (3)
  someNode.sub(someOtherNode)
    # When creating libraries of reusable nodes, they always must define a set of
    # characters which are called "firstChars". These are the characters that indicate
    # the start of some sort of data. For example for Lib.Text.Lexer.Identifier, the
    # "firstChars" are "a-zA-Z_". It's the letters an identifier can start
    # with. Similarly we can create our own library node functions, by supplying a
    # firstChars list as parameter to Lib.Text.Lexer.Node
    #
    # So what happens is that inside someNode, pointers are added to someOtherNode for
    # all characters in that node's firstChars.
</pre>


<h2>Reusable nodes - integer sequence</h2>
<p>
  To create a reusable node, we need to specify the "firstChars" of a node, which are given
  as parameter when creating an Node node. This means adding it as "sub" under some other node,
  lets those characters point at it.
</p>

<pre>
  # Create reusable node for integers. 
    "0123456789"=&gt;digits
    Lib.Text.Lexer.Node(digits) =&gt;x
    x.sub(digits,x)
    x.setIsToken(1)

    x
  /NodeInt

  # Now we can for example match a IP v4 address
    Lib.Text.Lexer.Node =top
    a=NodeInt
    b=NodeInt
    c=NodeInt
    d=NodeInt
    
    top.sub(a)
    a.sub(".").sub(b) # creates intermediary nodes for the dots
    b.sub(".").sub(c)
    c.sub(".").sub(d)
    d.setIsToken(2)

    top
  /MatchIPAddress

  # Test
  "192.168.1.1 255.255.x 10.0.0.1 1.2.3 .4".split-&gt;word
    report(word, MatchIPAddress.match(word))
    # should return 11,0,8,0,0
  /t1
</pre>


<h2>Processing single lines</h2>
<p>
  To process all text in a line, we need to build a root node to which we add
  pointers to sub-nodes for all valid tokens. For simplicity, let us match only
  identifiers.
</p>
<p>
  Since identifiers are separated by space, we also need to match
  whitespace. Since we are not interested in whitespace, we assign whitespace 
  tokens a negative token type, as those get automatically ignored.
</p>
<pre>
# Identifiers
  "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_" =&gt;firstChars
  firstChars+"0123456789" =&gt;innerChars
  
  ident = Lib.Text.Lexer.Node(firstChars)
  ident.sub(innerChars,ident)
  ident.setIsToken(1)
  
  ident
/Identifiers

# Whitespace
  " ^t^n^r".unEsc =&gt;chars
  Lib.Text.Lexer.Node(chars) =&gt;ws
  ws.sub(chars,ws)
  ws.setIsToken(-1)
    
  ws
/WhitesSpace

# Root node
  Lib.Text.Lexer.Node =&gt;root
  root.sub(Identifiers)
  root.sub(WhiteSpace)
/Root
</pre>
<p>
  With the Root node ready, we can now parse strings consisting of identifiers and space, 
  ignoring space.
</p>
<pre>
# Test
  Lib.Text.Lexer.processLine(Root,"this is a test").getTokens->token
    report(token.sourceLocation, token.str, token.tokenType)
/test
</pre>
<p>
  Now running the test we get
</p>
<pre>
  $ test
  &lt;List&gt;
   0: pos=1  | this | 1
   1: pos=6  | is   | 1
   2: pos=9  | a    | 1
   3: pos=11 | test | 1
</pre>


<h2>Processing files</h2>
<p>
  Processing files is easy, using File.read and iterating over those, calling .processLine
  on the same Lexer object. If we want, we can let the lexer add "newline"-tokens at the end
  of each line, by just defining a token type, here we use 100.
</p>
<pre>
# Process file
  Root =&gt;root
  Lib.Text.Lexer =&gt;lexer

  File("...").read-&gt;line 
    lexer.processLine(root,lexer,100) 
  |
  
  lexer.getTokens-&gt;token
    report(token.sourceLocation, token.str, token.tokenType)
/ProcessFile
</pre>
<p>
  The Lexer.processLine is smart enough to detect when lines are read from a file, as
  lines read from file are not regular strings, but a subtype of String, which contain
  filename and line number. This info is included in the sourceLocation available
  for each token.
</p>


<h2>Limitations</h2>
<p>
  As there is at most one pointer per character in each node, we can not both recognize
  identifiers AND certain keywords, such as "begin" and "end", separately. Unless of course
  the keywords start with a different sequence of characters in front, that make them
  unique from identifiers.
</p>
<p>
  With the "symbols" we can easily recognize both "=" and "==" as symbols, because the second
  is an extension of the first, and the "=" node is not configured to match any stream
  of "=", such as identifiers are for letters and numbers.
</p>
<p>
  This also means we can not both match integer and dates on numeric format, such as
</p>
<pre>
  2020   # integer
  2020-09-12   # date
</pre>

<h2>Different uses</h2>
<p>
  Parsing a programming language or JSON structure, requires us to identify every
  token in the string. The lexer tree must house them all.
</p>
<p>
  Parsing a log line piece by piece does not have this requirement. Different 
  lexer nodes may be used for each part of the line, some allowing for alternatives,
  most just looking to match a fixed format string, for which regular expressions
  would also be suited.
</p>


<h2>Complex tokens</h2>
<p>
  For the case where we want to identify parts of a log line, one token at a time, 
  individual token definitions may not co-exist under a shared root, but that is
  exactly the point: we have clear expectations for what we look for, at any time.
</p>
<p>
  The Node.addTokenComplex() function is not one that lives happily together with
  others.
</p>

<h3>Regular Node.addToken() example</h3>
<p>
  With the normal .addToken() function, we can do something like this:
</p>
<pre>
  Lib.Text.Node =&gt;grade
  "A AA AAA B C".split->x grade.addToken(x).setIsToken
</pre>
<p>
  Overlapping definitions, such as "A" and "AA" and "AAA" is not a problem for Node.addToken()
</p>




<h3>Node.addTokenComplex() example</h3>
<p>
  This function adds a token, where some of the characters in the token string map to 
  sets of characters, via a Dict object. This function does not have the freedom to
  expand and reuse existing (overlapping) nodes, as with the regular .addToken() function.
</p>
<p>
  It is meant for matching one thing only, and not for collecting all token definitions
  under a shared root, as before. 
</p>
<pre>
  Lib.Text.Node =&gt;date
  Dict.set("i","0123456789") =&gt;mappings
  date.setTokenComplex("iiii-ii-ii", mappings).setIsToken

  date.match("2020-09-15xxx")  # returns 10 (characters matched)
  date.match("2020-009-15xxx") # returns 0 (no match)
</pre>
<p>
  Feels like Regex character classes, no?
</p>








<h1>Closures</h1>
<p><i>v1.3.1</i></p>
<p>
  A closure is created by binding a Lambda to a Dict object. The Closure
  has a .call function just like the Lambda, and invokes the lambda, with
  the Dict object referenced via "self" variable.
</p>
<p>
  Nice for event based callbacks.
</p>
<pre>
  Dict =&gt;data
  data.bind(Lambda{
    self.set("received_value", P(1))
  }) =&gt;closure

  closure.call("test")
  data.get("received_value")  # returns "test"
</pre>
<p>
  For robustness and testing, when lambdas are run directly (not via closures)
  there is also a "self" variable, which points at an empty Dict object.
</p>
<h2>Another example</h2>
<p>
  Here we create a Closure that when called strips N characters from the
  start and end of a string.
</p>
<pre>
  P(1)=&gt;n
  Dict.set("n",n).bind(Lambda{
    P(1)=&gt;s 
    self.get("n")=&gt;n
    s.sub(n,s.length-n)
  })
/Strip
</pre>
<p>
  Test:
</p>
<pre>
  $ Strip(2).call("this is a test")
  &lt;String&gt;
  is is a te
</pre>





<h1>Closures v2 - Objects</h1>
<p><i>v1.7.5</i></p>
<p>
  Letting the dictionary .set function detect lambdas, they are automatically wrapped inside
  closures, with "self" pointing to the dictionary in question.
</p>
<p>
   This means we can now do this:
</p>
<pre>
Dict
  .set("i",1)
  .set("incr",Lambda{
    amount=P(1,1)
    self.set("i",self.i+amount)
  })
  =&gt;data

  data.incr.call(10) # data.i is now 11
  println(data.i)
/test
</pre>



<h2>Member lambdas calling each other</h2>
<p>
  The mechanism of letting individual "member" lambdas have a shared idea of "self", also allows for this:
</p>
<pre>
Dict
  .set("i",1)
  .set("incr",Lambda{
    amount=P(1,1)
    self.set("i",self.i+amount)
  })
  .set("incr50",Lambda{
    self.incr.call(50)
  })
  =&gt;data

  data.incr50.call  # data.i is now 51
  println(data.i)
/test
</pre>
<p>
  The incr50 lambda calls the incr lambda within the environment defined by the Dict object.
</p>




<h2>Cloning dictionaries</h2>
<p>
  The Dict.set function also detects when it is fed a closure, unwrapping the
  Lambda inside, then wrapping it inside a new closure pointing back to 
  itself (via "self" variable in lambda).
</p>
<p>
  This means that if we create a function to clone a Dict, the new object will
  be independent of the first.
</p>
<pre>
# Clone dictionary
  P(1)=&gt;orig
  error(getType(orig) != "Dict", "Require Dict")
  new = Dict
  orig.keys->key 
    new.set(key,orig.get(key)) 
  |
  new
/CloneDict

# Test-code
# --
  Dict
  .set("i",1)
  .set("a",Lambda{
    self.b.call
  })
  .set("b",Lambda{
    self.set("i",self.i+1)
    self.i
  })
  =&gt; d1
  
  # Clone d1 into d2, then change its state
  CloneDict(d1) =&gt; d2
  d2.set("i",10)

  println("d1.a.call " + d1.a.call)
  println("d1.a.call " + d1.a.call)
  println("d2.a.call " + d2.a.call)
  println("d2.a.call " + d2.a.call)
/test

# Output
#
# d1.a.call 2
# d1.a.call 3
# d2.a.call 11
# d2.a.call 12
</pre>










<h1>Reference: Colon commands</h1>
<p>
  Colon commands are best described by entering a single colon at the CFT prompt.
</p>

<pre>
$ :

Colon commands
--------------
:save [ident]?           - save script
:load [ident]?           - load script
:new                     - create new empty script
:sw [ident]?             - switch between loaded scripts
:delete ident [, ident]* - delete function(s)
:copy ident ident        - copy function
:wrap                    - line wrap on/off
:debug                   - enter or leave debug mode
:syn                     - synthesize last result
:&lt;int&gt;                   - synthesize a row from last result (must be list)
:quit                    - terminate CFT

</pre>
<p>
  Confusing colon commands with shortcuts? You're not alone.
</p>
<p>
  Colon commands exist outside the language, and are fixed (written in Java), while shortcuts run CFT program
  code, and are defined in the CFT.props file. So far all good.
</p>
<p>
  The "problem" is that CFT code (and so shortcuts) can run colon commands via "abusing" the Sys.stdin() command.
</p>





<h1>Reference: Synthesizable types</h1>
<ul>
  <li>boolean</li>
  <li>int</li>
  <li>float</li>
  <li>string</li>
  <li>null</li>
  <li>List</li>
  <li>Dir</li>
  <li>File</li>
  <li>FileLine</li>
  <li>Date</li>
  <li>Date.Duration</li>
  <li>Int</li>
  <li>Float</li>
  <li>Str</li>
  <li>Dict</li>
  <li>Glob</li>
  <li>Regex</li>
</ul>






<h1>Comments and digressions</h1>



<h2>Why Input("label").get?</h2>
<p>
  Why can't the Input() function just ask the user for input? Why the .get()?
</p>
<p>
  This is because it was envisioned more functions on the Input object, such as 
  programming it to reset its remembered values, or get values from other sources.
</p>
<p>
  This never came to fruition, and with Input() being a pretty old function, Input("xxx") remains 
  creating an object, with a single .get() function inside. As a side note, it also has to be an 
  object in order to persist data in the session, though surely that's not a hard limitation.
</p>
<p>
  At least it leaves us with the option of adding clever stuff later.
</p>
<p>
  Another weakness or strength is that Input objects are mapped to persistent instances by
  the input label. This can be confusing, but often also what we want. 
</p>


<h2>Function name AFTER code?</h2>
<pre>
  Dir.files
  /showFiles
</pre>
<p>
  This stems back to the time of entering code line by line. Having to decide the name of a function before
  seeing how much functionality you got crammed into one line, or if it at all worked,
  made little sense. Instead you write some code
  that does something useful, then decides what to call it.
</p>
<p>
  This might at some point be changed, at least for script files, as it still feels backward, but this 
  is the reason. 
</p>
<p>
  The syntax with the slash and an identifier was inspired by PostScript.
</p>
<p>
  Another issue is how to integrate or maintain the use of the P() function for
  parameter processing, which feels superior to what one can do in a
  more traditional format:
</p>
<pre>
  function X (a,b) { ... }
</pre>

<h2>Using Sys.stdin to run colon commands etc</h2>
<p>
  That functionality an example of an "unexpected feature", as the Sys.stdin() was created to automate 
  functions that used
  Input and readLine(). There was a moment of confusion when discovering what happened to input lines not consumed
  by those interactive functions.
</p>




<h2>2020-09-12 Inner blocks??</h2>
<p>
  The first block expression added to CFT, was what is now called the Inner block. Then immediately followed
  macros, now called Lambdas. The local blocks were introduced in the v1.3 overhaul. 
</p>
<p>
  The previous "odd" syntax for creating macros has gotten more explicit, but who talks
  about "macros" these days? The functionality is the same, though.
</p>
<p>
  A search/replace on all the script files fixed the renaming easily.
</p>
<pre>
  {* ...} =&gt;macro  # old syntax - no longer supported
  Lambda{...} =&gt;lambda
</pre>
<p>
  The Inner block expressions do not resemble code blocks in Java, because in reality they are automatically
  executing lambdas, with scope extending out to the calling environment. Lambdas and block expressions were
  an afterthought, something created because it was possible. There was no real need, apart from 
  simplifying the odd conditional assigment .....
</p>
<pre>
  if(addOne, value+1, value) =value
</pre>
<p>
  Now, with local block expressions added in v1.3, and the "if" expression accepting dual syntax,
  code can be organized much more logically
  for Java/C/JS programmers.
</p>



<h2>2020-09-12 Closures and objects</h2>
<p>
  After creating v1.3.0 which rearranged two block expressions into three (Lambda, Inner and Local),
  I had pondered how to do closures and objects.
</p>
<p>
  These were created mainly created for fun, though they of course have uses.
</p>
<p>
  The solution ended up being very easy to implement, and is fairly elegant,
  as they really are about using the same mechanism, being that all running
  lambdas have a "self" variable pointing to some Dict object.
</p>


<h2>2020-09-12 A lexical analysis revelation</h2>
<p>
  As the Lib.Text.Lexer object was created, and I experimented with it, I discovered
  that what I had thought to be a limitation in the parser, was a "user error" made by me.
</p>
<p>
  The problem was that CFT did not handle calling functions inside integer literals,
  except with a space between the number and the dot, like this:
</p>
<pre>
  $ 3 .bin
</pre>
<p>
  The problem was that my configuration for parsing floating point numbers
  was flawed. Basically it looked like this (converted to Lib.Text.Lexer syntax)
</p>
<pre>
  "0123456780"=&gt;digits
  Lib.Text.Lexer.Empty(digits) =&gt;intMatcher
  intMatcher.sub(digits,intMatcher)
  intMatcher.setIsToken  # so far all good

  intMatcher.sub(".") =&gt;afterDot
  afterDot.sub(digits, afterDot)
  afterDot.setIsToken
</pre>
<p>
  The problem here is that when the intMatcher finds a ".", and follows the link to 
  the afterDot node, that node has the is-token flag set, so even if there are no
  digits following the dot, the matcher believes it has matched a float. The result
  is that "3." is considered a valid float, and that the the text following now is "bin", 
  which is correctly recognized as an identifier, but the parser does not recognize it
  as a dotted call, as the dot has been incorrectly consumed. 
</p>
<p>
  The fix is simple. The "." must point to a node that does not have the is-token flag set,
  but instead has pointers for digits 0-9 to another node, which does, and which
  gobbles up any additional digits via a self-loop. 
</p>
<pre>
  "0123456780"=&gt;digits
  Lib.Text.Lexer.Empty(digits) =&gt;intMatcher
  intMatcher.sub(digits,intMatcher)
  intMatcher.setIsToken(3)

  intMatcher.sub(".") =&gt;afterDot  
  afterDot.sub(digits) =&gt;afterDotDigits  # new node
  afterDotDigits.setIsToken(4)
  afterDotDigits.sub(digits,afterDotDigits)
</pre>
<p>
  Lexing and parsing is fun, and I really enjoyed learning new things about my own code after 2+ years
  of assuming I had hit a limitation.
</p>
<p>
  I am going to enjoy writing the parser. CFT uses a "hard-coded" recursive descent
  parser, with Java classes calling each other. 
</p>
<p>
  This means that a parser that is configurable from CFT code has to be written from
  scratch. With the v1.3.0 branch safely merged into master, and closures and dictionaries
  as objects implemented, it's time to start 
  considering parsing again.
</p>



<h2>2020-10-24 Objects ...</h2>
<p>
  The v1.7.5 "dictionary-as-object" turned out really nice, letting lambdas stored inside Dict's
  be wrapped into closures pointing at that dict. This eliminated the first syntax from v1.3.2 or
  thereabouts, which included a separate ".invoke"-function. 
</p>
<p>
  The fact is that this is one of those features that came about, not from a grand plan, but
  because it was possible and quite easy to implement, and only hours after upgrading to
  the v1.7.5 syntax, I wrote the Lib:runProcess, which uses this and some other new features,
  like the Process object.
</p>


<h2>2020-10-24 cleaning up - Java Parser</h2>
<p>
  Decided to delete the Lib.Text.Parser that was to triumphantly (is that a word?) follow the
  Lib.Text.Lexer. It got stuck, from lack of inspiration, and then I went ahead and created 
  a rudimentary JSON parser in pure CFT in under 150 lines.
</p>
<p>
  Though grammars are fun, for now they will have to wait.
</p>


<h2>2020-10-24 loop spaces / the "pipe"</h2>
<p>
  Having worked extensively through this document for the last days, it struck me as odd
  that I did not earlier add musings about the "loop space" concept, which decidedly is
  a bit ... odd?
</p>
<p>
  This all stems from the "one-line-at-a-time" period, where scripts were entered from
  the command line, and looooong before block expressions. Being a fairly compact
  and efficient notation, and frequently used, loop spaces will not be purged from the language
  just yet. 
</p>
<p>
  The "pipe" is completely optional, as Inner blocks can do all that "loop spaces" do (and more), but
  at the cost of a bit more notation.
</p>




</body></html>